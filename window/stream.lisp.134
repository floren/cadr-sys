;;; -*- Mode:LISP; Package:TV; Base:8; Lowercase:T -*-
;;;	** (c) Copyright 1980 Massachusetts Institute of Technology **

;This is overridden by loading SYS:WINDOW;RH, which is now standardly loaded.
(DEFVAR STREAM-MIXIN-RUBOUT-HANDLER 'DEFAULT-RUBOUT-HANDLER
  "Default rubout-handler to use for input from windows")

;;; Io stream stuff
(DEFFLAVOR STREAM-MIXIN
	   ((IO-BUFFER NIL)
	    (RUBOUT-HANDLER-BUFFER NIL)
	    (OLD-TYPEAHEAD NIL)			;Used for :PREEMPTABLE-READ.
;;Not patched in 98.!
	    (stream-rubout-handler))		;nil => use tv:stream-mixin-rubout-handler
	   ()
  (:REQUIRED-FLAVORS SHEET ESSENTIAL-WINDOW)	;Explicit presence of SHEET
						;helps init flavor-unmapped-instance-variables
  (:SELECT-METHOD-ORDER :TYO :STRING-OUT :LINE-OUT :TYI :TYI-NO-HANG :LISTEN)
  (:GETTABLE-INSTANCE-VARIABLES IO-BUFFER)
  (:INITABLE-INSTANCE-VARIABLES IO-BUFFER RUBOUT-HANDLER-BUFFER)
  (:SETTABLE-INSTANCE-VARIABLES OLD-TYPEAHEAD :stream-rubout-handler)
  (:INIT-KEYWORDS :ASYNCHRONOUS-CHARACTERS)
  (:DOCUMENTATION :MIXIN "Ordinary tv stream operations.
Gives all the meaningful stream operations for a display, such as :TYO, :TYI, :RUBOUT-HANDLER,
:STRING-OUT, etc.  Include this flavor someplace so that the window can be passed to functions
that take streams as arguments, and especially if TERMINAL-IO is going to be bound to the
window."))

;; The third, fourth and fifth components of this structure are used only by LMIO;RH,
;; and not by the default rubout handler.

(DEFSTRUCT (RUBOUT-HANDLER-BUFFER (:TYPE :ARRAY-LEADER)
				  (:MAKE-ARRAY (:LENGTH 1000))
				  (:DEFAULT-POINTER RUBOUT-HANDLER-BUFFER)
				  (:CONC-NAME "RHB-")
				  (:ALTERANT NIL))
  (FILL-POINTER 0 :documentation
    "Greatest input index")
  (SCAN-POINTER 0 :documentation
    "Furthest index which has been scanned by the reading function")
  (TYPEIN-POINTER 0 :documentation
    "Where the next input character goes")
  (DONT-SAVE-FLAG NIL :documentation
    "T means this input should not go on the input history")
  (INPUT-RING NIL :documentation
    "History of past input")
  (status nil :documentation
    "Possible values include NIL, :RESTORED, :INITIAL-ENTRY, :RUBOUT"))

(DEFMETHOD (STREAM-MIXIN :BEFORE :INIT) (INIT-PLIST)
  (SEND SELF ':WHICH-OPERATIONS)		;Pre-create this, certainly going to be used
  (UNLESS (TYPEP (TYPEP IO-BUFFER 'IO-BUFFER))
    (LET (SIZE INPUT-FUNCTION OUTPUT-FUNCTION)
      (IF (NUMBERP IO-BUFFER)
	  (SETQ SIZE IO-BUFFER
		INPUT-FUNCTION NIL
		OUTPUT-FUNCTION 'KBD-DEFAULT-OUTPUT-FUNCTION)
	(SETQ SIZE (OR (FIRST IO-BUFFER) 100)
	      INPUT-FUNCTION (SECOND IO-BUFFER)
	      OUTPUT-FUNCTION (OR (THIRD IO-BUFFER) 'KBD-DEFAULT-OUTPUT-FUNCTION)))
      (SETQ IO-BUFFER (MAKE-IO-BUFFER SIZE INPUT-FUNCTION OUTPUT-FUNCTION))))
  (IF (GETL INIT-PLIST '(:ASYNCHRONOUS-CHARACTERS))
      (PUTPROP (LOCF (IO-BUFFER-PLIST IO-BUFFER))
	       (GET INIT-PLIST ':ASYNCHRONOUS-CHARACTERS)
	       ':ASYNCHRONOUS-CHARACTERS))
  (OR RUBOUT-HANDLER-BUFFER
      (SETQ RUBOUT-HANDLER-BUFFER (MAKE-RUBOUT-HANDLER-BUFFER))))

(DEFMETHOD (STREAM-MIXIN :ADD-ASYNCHRONOUS-CHARACTER) (CHARACTER FUNCTION &REST ARGS)
  (CHECK-ARG-TYPE CHARACTER :FIXNUM)
  (CHECK-ARG FUNCTION FUNCTIONP "a function")
  (LET ((PLIST (LOCF (IO-BUFFER-PLIST IO-BUFFER))))
    (PUSH (LIST* CHARACTER FUNCTION (COPYLIST ARGS))
	  (GET PLIST ':ASYNCHRONOUS-CHARACTERS))))

(DEFMETHOD (STREAM-MIXIN :ASYNCHRONOUS-CHARACTER-P) (CHARACTER)
  (LET* ((PLIST (LOCF (IO-BUFFER-PLIST IO-BUFFER)))
	 (ALIST (GET PLIST ':ASYNCHRONOUS-CHARACTERS)))
    (ASSQ CHARACTER ALIST)))

(DEFMETHOD (STREAM-MIXIN :HANDLE-ASYNCHRONOUS-CHARACTER) (CHARACTER)
  (LET* ((PLIST (LOCF (IO-BUFFER-PLIST IO-BUFFER)))
	 (ALIST (GET PLIST ':ASYNCHRONOUS-CHARACTERS))
	 (TEM (ASSQ CHARACTER ALIST)))
    (WHEN TEM (APPLY (CADR TEM) (CAR TEM) SELF (CDDR TEM)))))
  
(DEFMETHOD (STREAM-MIXIN :REMOVE-ASYNCHRONOUS-CHARACTER) (CHARACTER)
  (LET* ((PLIST (LOCF (IO-BUFFER-PLIST IO-BUFFER)))
	 (ALIST (GET PLIST ':ASYNCHRONOUS-CHARACTERS)))
    (SETF (GET PLIST ':ASYNCHRONOUS-CHARACTERS)
	  (DELQ (ASSQ CHARACTER ALIST) ALIST))))

(DEFMETHOD (STREAM-MIXIN :DIRECTION) () ':BIDIRECTIONAL)

(DEFMETHOD (STREAM-MIXIN :BEFORE :SELECT) (&REST IGNORE)
  (KBD-CLEAR-SELECTED-IO-BUFFER))

(DEFMETHOD (STREAM-MIXIN :BEFORE :DESELECT) (&REST IGNORE)
  (KBD-CLEAR-SELECTED-IO-BUFFER))

(DEFMETHOD (STREAM-MIXIN :SET-IO-BUFFER) (NEW-BUFFER)
  (WITHOUT-INTERRUPTS
    (KBD-CLEAR-SELECTED-IO-BUFFER)
    (SETQ IO-BUFFER NEW-BUFFER)))

(DEFMETHOD (STREAM-MIXIN :PUSH-INPUT) (INPUT)
  (IF (STRINGP INPUT)
      (DO ((I (1- (STRING-LENGTH INPUT)) (1- I)))
	  ((MINUSP I))
	(IO-BUFFER-PUSH IO-BUFFER (AREF INPUT I)))
    (IO-BUFFER-PUSH IO-BUFFER INPUT)))

(DEFMETHOD (STREAM-MIXIN :DRAW-RECTANGLE) (RECTANGLE-WIDTH RECTANGLE-HEIGHT X Y
					   &OPTIONAL (ALU CHAR-ALUF))
  (PREPARE-SHEET (SELF)
    (DRAW-RECTANGLE-INSIDE-CLIPPED RECTANGLE-WIDTH RECTANGLE-HEIGHT X Y ALU SELF)))

(DEFMETHOD (STREAM-MIXIN :BITBLT) (ALU WID HEI FROM-ARRAY FROM-X FROM-Y TO-X TO-Y
				   &AUX (IL (SHEET-INSIDE-LEFT))
				        (IR (SHEET-INSIDE-RIGHT))
					(IT (SHEET-INSIDE-TOP))
					(IB (SHEET-INSIDE-BOTTOM)))
  (SETQ TO-X (+ IL TO-X) TO-Y (+ IT TO-Y))
  (LET* ((CLIPPED-TO-X				
	   (MIN (MAX IL TO-X) IR))
	 (CLIPPED-TO-Y
	   (MIN (MAX IT TO-Y) IB))
	 (WID-SIGN (IF (MINUSP WID) -1 1))
	 (HEI-SIGN (IF (MINUSP HEI) -1 1))
	 (LEFT-OVERRUN
	   (- CLIPPED-TO-X TO-X))
	 (RIGHT-OVERRUN
	   (MAX 0 (- (+ CLIPPED-TO-X (ABS WID)) IR)))
	 (TOP-OVERRUN
	   (- CLIPPED-TO-Y TO-Y))
	 (BOTTOM-OVERRUN
	   (MAX 0 (- (+ CLIPPED-TO-Y (ABS HEI)) IB)))
	 (CLIPPED-WID
	   (* WID-SIGN (MAX 0 (- (ABS WID) LEFT-OVERRUN RIGHT-OVERRUN))))
	 (CLIPPED-HEI
	   (* HEI-SIGN (MAX 0 (- (ABS HEI) TOP-OVERRUN BOTTOM-OVERRUN)))))

    (AND (NOT (ZEROP CLIPPED-WID))				;bitblt errs when w=h=0
	 (NOT (ZEROP CLIPPED-HEI))				;and dims are out of bounds
	 (PREPARE-SHEET (SELF)
	   (BITBLT ALU
		   CLIPPED-WID CLIPPED-HEI
		   FROM-ARRAY (+ FROM-X LEFT-OVERRUN) (+ FROM-Y TOP-OVERRUN)
		   SCREEN-ARRAY CLIPPED-TO-X CLIPPED-TO-Y)))))

(DEFMETHOD (STREAM-MIXIN :BITBLT-FROM-SHEET) (ALU WID HEI FROM-X FROM-Y TO-ARRAY TO-X TO-Y
					      &AUX (IL (SHEET-INSIDE-LEFT))
					           (IR (SHEET-INSIDE-RIGHT))
						   (IT (SHEET-INSIDE-TOP))
						   (IB (SHEET-INSIDE-BOTTOM)))
  (SETQ FROM-X (+ IL FROM-X) FROM-Y (+ IT FROM-Y))
  (LET* ((CLIPPED-FROM-X				
	   (MIN (MAX IL FROM-X) IR))
	 (CLIPPED-FROM-Y
	   (MIN (MAX IT FROM-Y) IB))
	 (WID-SIGN (IF (MINUSP WID) -1 1))
	 (HEI-SIGN (IF (MINUSP HEI) -1 1))
	 (LEFT-OVERRUN
	   (- CLIPPED-FROM-X FROM-X))
	 (RIGHT-OVERRUN
	   (MAX 0 (- (+ CLIPPED-FROM-X (ABS WID)) IR)))
	 (TOP-OVERRUN
	   (- CLIPPED-FROM-Y FROM-Y))
	 (BOTTOM-OVERRUN
	   (MAX 0 (- (+ CLIPPED-FROM-Y (ABS HEI)) IB)))
	 (CLIPPED-WID
	   (* WID-SIGN (MAX 0 (- (ABS WID) LEFT-OVERRUN RIGHT-OVERRUN))))
	 (CLIPPED-HEI
	   (* HEI-SIGN (MAX 0 (- (ABS HEI) TOP-OVERRUN BOTTOM-OVERRUN)))))

    (AND (NOT (ZEROP CLIPPED-WID))		;bitblt has this weird bug where it
	 (NOT (ZEROP CLIPPED-HEI))		;doesn't check to see if wid and hei are = 0
	 (PREPARE-SHEET (SELF)
	   (BITBLT ALU
		   CLIPPED-WID CLIPPED-HEI
		   SCREEN-ARRAY CLIPPED-FROM-X CLIPPED-FROM-Y
		   TO-ARRAY (+ TO-X LEFT-OVERRUN) (+ TO-Y TOP-OVERRUN))))))

(DEFMETHOD (STREAM-MIXIN :BITBLT-WITHIN-SHEET) (ALU WID HEI FROM-X FROM-Y TO-X TO-Y
						&AUX (IL (SHEET-INSIDE-LEFT))
					             (IR (SHEET-INSIDE-RIGHT))
						     (IT (SHEET-INSIDE-TOP))
						     (IB (SHEET-INSIDE-BOTTOM)))
  (SETQ FROM-X (+ IL FROM-X) FROM-Y (+ IT FROM-Y)
	TO-X (+ IL TO-X) TO-Y (+ IT TO-Y))
  (LET* ((CLIPPED-FROM-X
	   (MIN (MAX IL FROM-X) IR))		
	 (CLIPPED-FROM-Y
	   (MIN (MAX IT FROM-Y)	IB))		
	 (CLIPPED-TO-X
	   (MIN (MAX IL TO-X) IR))		
	 (CLIPPED-TO-Y
	   (MIN (MAX IT TO-Y) IB))         
	 (WID-SIGN (IF (MINUSP WID) -1 1))
	 (HEI-SIGN (IF (MINUSP HEI) -1 1))
	 (LEFT-OVERRUN
	   (MAX 0 (- CLIPPED-FROM-X FROM-X) (- CLIPPED-TO-X TO-X)))
	 (RIGHT-OVERRUN
	   (MAX 0 (- (+ CLIPPED-FROM-X (ABS WID)) IR) (- (+ CLIPPED-TO-X (ABS WID)) IR)))
	 (TOP-OVERRUN
	   (MAX 0 (- CLIPPED-FROM-Y FROM-Y) (- CLIPPED-TO-Y TO-Y)))
	 (BOTTOM-OVERRUN
	   (MAX 0 (- (+ CLIPPED-FROM-Y (ABS HEI)) IB) (- (+ CLIPPED-TO-Y (ABS HEI)) IB)))
	 (CLIPPED-WID
	   (* WID-SIGN (MAX 0 (- (ABS WID) LEFT-OVERRUN RIGHT-OVERRUN))))
	 (CLIPPED-HEI
	   (* HEI-SIGN (MAX 0 (- (ABS HEI) TOP-OVERRUN BOTTOM-OVERRUN)))))

    (AND (NOT (ZEROP CLIPPED-WID))
	 (NOT (ZEROP CLIPPED-HEI))
	 (PREPARE-SHEET (SELF)
	   (BITBLT ALU
		   CLIPPED-WID CLIPPED-HEI
		   SCREEN-ARRAY (+ FROM-X LEFT-OVERRUN) (+ FROM-Y TOP-OVERRUN)
		   SCREEN-ARRAY (+ TO-X LEFT-OVERRUN) (+ TO-Y TOP-OVERRUN))))))

(DEFMETHOD (STREAM-MIXIN :DRAW-CHAR) (FONT CHAR X-BITPOS Y-BITPOS &OPTIONAL (ALU CHAR-ALUF))
  (PREPARE-SHEET (SELF)
    (DRAW-CHAR FONT CHAR
	       (+ X-BITPOS LEFT-MARGIN-SIZE)
	       (+ Y-BITPOS TOP-MARGIN-SIZE)
	       ALU SELF)))

(DEFMETHOD (STREAM-MIXIN :UNTYI) (CH)
  (IF (AND (eq rubout-handler self)
	   ;; RUBOUT-HANDLER added as conjunct 6/1/83
	   ;; to avoid lossage entering editor rubout handler
	   ;; by typing (= 1 2) then stray ) while inside BREAK.
	   ( 1 (RHB-SCAN-POINTER) (RHB-FILL-POINTER))
	   (EQ CH (AREF RUBOUT-HANDLER-BUFFER (1- (RHB-SCAN-POINTER)))))
      (DECF (RHB-SCAN-POINTER))
    (IO-BUFFER-UNGET IO-BUFFER CH)))

(DEFMETHOD (STREAM-MIXIN :LISTEN) ()
  (NOT (AND ( (RHB-FILL-POINTER) (RHB-SCAN-POINTER))
	    (IO-BUFFER-EMPTY-P IO-BUFFER)
	    (WITHOUT-INTERRUPTS
	      (IF (NEQ IO-BUFFER (KBD-GET-IO-BUFFER))
		  T
		(AND (KBD-HARDWARE-CHAR-AVAILABLE)
		     (KBD-PROCESS-MAIN-LOOP-INTERNAL))
		(IO-BUFFER-EMPTY-P KBD-IO-BUFFER))))))

(DEFMETHOD (STREAM-MIXIN :WAIT-FOR-INPUT-WITH-TIMEOUT) (TIMEOUT)
  (KBD-WAIT-FOR-INPUT-WITH-TIMEOUT IO-BUFFER TIMEOUT))

(DEFMETHOD (STREAM-MIXIN :CLEAR-INPUT) ()
  (SETF (RHB-FILL-POINTER) 0)
  (SETF (RHB-SCAN-POINTER) 0)
  (IO-BUFFER-CLEAR IO-BUFFER)
  (AND (EQ IO-BUFFER (KBD-GET-IO-BUFFER))
       (KBD-CLEAR-IO-BUFFER)))

(DEFMETHOD (STREAM-MIXIN :TYI) (&OPTIONAL IGNORE &AUX CH)
  (DO-FOREVER
    (SETQ CH (SEND SELF ':ANY-TYI))
    (WHEN (NUMBERP CH)
      (RETURN CH))
    (WHEN (AND (CONSP CH)
	       (EQ (CAR CH) ':MOUSE-BUTTON)
	       (EQ (CADR CH) #/MOUSE-3-1))
      (MOUSE-CALL-SYSTEM-MENU))))

(DEFMETHOD (STREAM-MIXIN :TYI-NO-HANG) (&OPTIONAL IGNORE &AUX CH)
  (DO-FOREVER
    (SETQ CH (SEND SELF ':ANY-TYI-NO-HANG))
    (WHEN (OR (NULL CH)
	      (NUMBERP CH))
      (RETURN CH))
    (WHEN (AND (CONSP CH)
	       (EQ (CAR CH) ':MOUSE-BUTTON)
	       (EQ (CADR CH) #/MOUSE-3-1))
      (MOUSE-CALL-SYSTEM-MENU))))

(DEFMETHOD (STREAM-MIXIN :ANY-TYI) (&OPTIONAL IGNORE &AUX IDX)
  (COND ((> (RHB-FILL-POINTER) (SETQ IDX (RHB-SCAN-POINTER)))
	 (SETF (RHB-SCAN-POINTER) (1+ IDX))
	 (OR (AREF RUBOUT-HANDLER-BUFFER IDX)
	     (FERROR NIL "EOF on input from a window.")))
	((neq rubout-handler self)
;	 (SETF (RHB-SCAN-POINTER) (RHB-FILL-POINTER))
	 (LET ((CHAR
		 (COND ((KBD-IO-BUFFER-GET IO-BUFFER T))
		       (T
			(SEND SELF ':NOTICE ':INPUT-WAIT)
			(KBD-IO-BUFFER-GET IO-BUFFER)))))
	   (IF (AND (eq rubout-handler-inside self)
		    (EQ OLD-TYPEAHEAD T)
		    (CONSP CHAR)
		    (NEQ (CAR CHAR) 'REDISPLAY-RUBOUT-HANDLER))
	       ;; If inside the rubout handler in a :PREEMPTABLE-READ
	       ;; and we just got a blip that isn't intended for the rubout handler.
	       (PROGN
		 (MULTIPLE-VALUE-BIND (STRING INDEX)
		     (SEND SELF ':SAVE-RUBOUT-HANDLER-BUFFER)
		   (SETQ OLD-TYPEAHEAD (LIST STRING INDEX)))
		 ;; Save the text, rub it all out, and unread the blip.
		 ;; The :FULL-RUBOUT option will cause the RH to return to the caller
		 ;; who will then read the blip.
		 (SEND SELF ':UNTYI CHAR)
		 #/CLEAR)
	     CHAR)))
	(T
;;not patched in 98.
	 (OR (FUNCALL (or stream-rubout-handler stream-mixin-rubout-handler))
	     (FERROR NIL "EOF on input from a window.")))))

(DEFMETHOD (STREAM-MIXIN :ANY-TYI-NO-HANG) (&OPTIONAL IGNORE)
  (if (neq rubout-handler self)
      (KBD-IO-BUFFER-GET IO-BUFFER T)
    (FERROR NIL ":ANY-TYI-NO-HANG from inside a rubout handler.")))

;;;For things only prepared to deal with fixnums
(DEFMETHOD (STREAM-MIXIN :MOUSE-OR-KBD-TYI) (&AUX CH)
  (DO-FOREVER
    (SETQ CH (SEND SELF ':ANY-TYI))
    (WHEN (NUMBERP CH)
      (RETURN CH CH))
    (WHEN (AND (CONSP CH) (EQ (CAR CH) ':MOUSE-BUTTON))
      (RETURN (SECOND CH) CH))))

(DEFMETHOD (STREAM-MIXIN :MOUSE-OR-KBD-TYI-NO-HANG) (&AUX CH)
  (DO-FOREVER
    (SETQ CH (SEND SELF ':ANY-TYI-NO-HANG))
    (WHEN (OR (NULL ch) (NUMBERP CH))
      (RETURN CH CH))
    (WHEN (AND (CONSP CH) (EQ (CAR CH) ':MOUSE-BUTTON))
      (RETURN (SECOND CH) CH))))

(DEFMETHOD (STREAM-MIXIN :LIST-TYI) (&AUX CH)
  "Only return lists"
  (DO-FOREVER
    (SETQ CH (SEND SELF ':ANY-TYI))
    (AND (CONSP CH) (RETURN CH))))

;Return a circular buffer array describing the last however many input characters.
;The (array-leader array 1) points at the last slot stored into.
(DEFMETHOD (STREAM-MIXIN :PLAYBACK) ()
  (IO-BUFFER-RECORD IO-BUFFER))

(DEFMETHOD (STREAM-MIXIN :FORCE-KBD-INPUT) (CH-OR-STRING)
  (IF (STRINGP CH-OR-STRING)
      (DOTIMES (N (LENGTH CH-OR-STRING))
	(IO-BUFFER-PUT IO-BUFFER (AREF CH-OR-STRING N)))
    (IO-BUFFER-PUT IO-BUFFER CH-OR-STRING)))	;all of the old cases.

(DEFFLAVOR LIST-TYI-MIXIN () ()
  (:DOCUMENTATION :MIXIN "Makes :TYI discard non-keyboard input."))

(DEFFLAVOR ANY-TYI-MIXIN () ()
  (:DOCUMENTATION :MIXIN "Makes :TYI discard non-keyboard input."))

(DEFFLAVOR PREEMPTABLE-READ-ANY-TYI-MIXIN () ())

(DEFVAR RUBOUT-HANDLER-STARTING-X :UNBOUND
  "Within rubout handler, X position of beginning of input.")
(DEFVAR RUBOUT-HANDLER-STARTING-Y :UNBOUND
  "Within rubout handler, Y position of beginning of input.")
(DEFVAR RUBOUT-HANDLER-RE-ECHO-FLAG :UNBOUND
  "Within rubout handler, T when there are error messages in the middle of the input.
Set to NIL when the input is reprinted and they are gone.")
(DEFVAR RUBOUT-HANDLER-INSIDE NIL
  "Non-NIL while inside the rubout handler.")
(DEFVAR RUBOUT-HANDLER-ACTIVATION-CHARACTER NIL
  "The character or blip that is activating this invocation of :RUBOUT-HANDLER.")

(DEFVAR PROMPT-STARTING-X :UNBOUND
  "Within rubout handler, X position of beginning of printed prompt string.")
(DEFVAR PROMPT-STARTING-Y :UNBOUND
  "Within rubout handler, Y position of beginning of printed prompt string.")

(defmethod (stream-mixin :rubout-handler) (options function &rest args)
  (declare (arglist rubout-handler-options function &rest args))
  (if (and (eq rubout-handler self) (not (cdr (assq ':nonrecursive options))))
      (let ((rubout-handler-options (append options rubout-handler-options)))
	(apply function args))
    (let ((rubout-handler-options options))
      (if ( (rhb-fill-pointer) (rhb-scan-pointer))
	  (setf (rhb-fill-pointer) 0)
	(copy-array-portion rubout-handler-buffer (rhb-scan-pointer) (rhb-fill-pointer)
			    rubout-handler-buffer 0 (array-length rubout-handler-buffer))
	(if (numberp (rhb-typein-pointer))
	    (decf (rhb-typein-pointer) (rhb-scan-pointer)))
	(decf (rhb-fill-pointer) (rhb-scan-pointer)))
      (setf (rhb-scan-pointer) 0 (rhb-status) ':initial-entry)
      (*catch 'return-from-rubout-handler
	(let (prompt-starting-x prompt-starting-y
	      rubout-handler-starting-x rubout-handler-starting-y
	      (rubout-handler self)
	      (rubout-handler-inside self)
	      (rubout-handler-re-echo-flag nil)
	      (rubout-handler-activation-character nil))
	  (multiple-value (prompt-starting-x prompt-starting-y) (send self ':read-cursorpos))
	  (setq rubout-handler-starting-x prompt-starting-x
		rubout-handler-starting-y prompt-starting-y)
	  (do-forever
	    (setq rubout-handler-re-echo-flag nil)
	    (*catch 'rubout-handler			;Throw here when rubbing out
	      (condition-case (error)
		  (return
		   (multiple-value-prog1
		     (apply function args)		;Call READ or whatever.
		     (setf (rhb-fill-pointer) (rhb-scan-pointer))
		     (and (rhb-typein-pointer)
			  (> (rhb-typein-pointer) (rhb-fill-pointer))
			  (setf (rhb-typein-pointer) (rhb-fill-pointer)))))
		(sys:parse-error
		 (send self ':fresh-line)
		 (princ ">>ERROR: " self)
		 (send error ':report self)
		 (send self ':fresh-line)
		 (setq rubout-handler-re-echo-flag t)
		 (do-forever (send self ':tyi)))))	;If error, force user to rub out
	    ;;Maybe return when user rubs all the way back
	    (and (zerop (rhb-fill-pointer))
		 (let ((full-rubout-option (assq ':full-rubout rubout-handler-options)))
		   (when full-rubout-option
		     ;; Get rid of the prompt, if any.
		     (sheet-clear-between-cursorposes
		       self prompt-starting-x prompt-starting-y
		       (- cursor-x left-margin-size) (- cursor-y top-margin-size))
		     (sheet-set-cursorpos self prompt-starting-x prompt-starting-y)
		     (return nil (cadr full-rubout-option)))))))))))

(defmethod (stream-mixin :rescanning-p) ()
  (or (< (rhb-scan-pointer) (rhb-fill-pointer))
      rubout-handler-activation-character))

(defmethod (stream-mixin :force-rescan) ()
  (setf (rhb-scan-pointer) 0)
  (*throw 'rubout-handler t))

(defmethod (stream-mixin :read-bp) ()
  (rhb-scan-pointer))

;;; Foo. I still have to write this.
;(defmethod (stream-mixin :replace-input) (n string &optional (start 0) end)
;  )


(DEFMETHOD (STREAM-MIXIN :PREEMPTABLE-READ) (OPTIONS FUN &REST ARGS)
  (DO ((TYPEAHEAD OLD-TYPEAHEAD NIL)
       (RESULT) (FLAG))
      (())
    (SETQ OLD-TYPEAHEAD T)
    (UNWIND-PROTECT
      (MULTIPLE-VALUE (RESULT FLAG)
	(with-stack-list (initial-input ':initial-input
					(if (consp typeahead) (car typeahead)))
	  (with-stack-list (initial-input-pointer ':initial-input-pointer
					  (if (consp typeahead) (cadr typeahead)))
	    (with-stack-list* (options initial-input
				       initial-input-pointer
				       '((:full-rubout :full-rubout))
				       options)
	      (unless (consp typeahead) (setq options (cddr options)))
	      (lexpr-send self ':rubout-handler options FUN ARGS)))))
      (AND (EQ OLD-TYPEAHEAD T)
	   (SETQ OLD-TYPEAHEAD NIL)))
    (AND (NEQ FLAG ':FULL-RUBOUT)
	 (RETURN RESULT NIL))
    ;; Determine whether a mouse character caused the full-rubout
    (SETQ RESULT (SEND SELF ':ANY-TYI-NO-HANG))
    (COND (RESULT
	   (OR (NUMBERP RESULT)
	       (RETURN RESULT ':MOUSE-CHAR))
	   (SEND SELF ':UNTYI RESULT)))
    (AND (SETQ FLAG (CADR (ASSQ ':FULL-RUBOUT OPTIONS)))
	 (RETURN NIL FLAG))
    ;; Presumably after this point, the user didn't call us with :FULL-RUBOUT
    ;; option, so we should retry. We have to fix up the notion of :PROMPT
    ;; and :REPROMPT first though.
    (LET ((PROMPT (ASSQ ':PROMPT OPTIONS)))
      (WHEN PROMPT 
	(SETQ OPTIONS (REMQ PROMPT OPTIONS))
	;This next condition may be unnecessary, but just in case. --kmp
	(UNLESS (NOT (ASSQ ':REPROMPT OPTIONS))
	  ;; make fake reprompt info. our old prompt should still 
	  ;; be there --kmp
	  (PUSH `(:REPROMPT . ,(CDR PROMPT)) OPTIONS))))))

;;; Give a single character, or do rubout processing, throws to RUBOUT-HANDLER on editing.
(defun default-rubout-handler ()
  (declare (:self-flavor stream-mixin))
  (setf (rhb-typein-pointer) nil)		;Mark that old rubout handler is in use.
  (when (= (rhb-scan-pointer) most-positive-fixnum)
    (setf (rh-scan-pointer) 0)
    (*throw 'rubout-handler t))
  (let ((status (rhb-status))
	(rubbed-out-some nil)
	(rubout-handler nil))
    (setf (rhb-status) nil)
    (when (memq status '(:restored :initial-entry))
      ;;Prompt if desired
      (let ((prompt-option (assq ':prompt rubout-handler-options)))
	(when prompt-option
	  (rubout-handler-prompt (cadr prompt-option) self nil)))
      (multiple-value (rubout-handler-starting-x rubout-handler-starting-y)
	(send self ':read-cursorpos))
      ;; Output any "typeahead"
      (when (plusp (rhb-fill-pointer))
	(send self ':string-out rubout-handler-buffer))
      ;;no point looking for :initial-input-pointer since this rh can't do anything with it
      (let ((initial-input (cadr (assq ':initial-input rubout-handler-options))))
	(when initial-input
	  (string-nconc rubout-handler-buffer initial-input))))
    (or (prog1 rubout-handler-activation-character
	       (setq rubout-handler-activation-character nil))
	(do ((editing-command (cdr (assq ':editing-command rubout-handler-options)))
	     (do-not-echo (cdr (assq ':do-not-echo rubout-handler-options)))
	     (pass-through (cdr (assq ':pass-through rubout-handler-options)))
	     (command-handler
	       (assq ':command rubout-handler-options))
	     (preemptable (assq ':preemptable rubout-handler-options))
	     (activation-handler
	       (assq ':activation rubout-handler-options))
	     ch len)
	    (nil)
	  (setq ch (send self ':any-tyi))
	  (cond ((and (consp ch) (eq (car ch) 'redisplay-rubout-handler))
		 (send self ':set-cursorpos prompt-starting-x prompt-starting-y)
		 (send self ':clear-eol)
		 (and (setq len (or (assq ':reprompt rubout-handler-options)
				    (assq ':prompt rubout-handler-options)))
		      (rubout-handler-prompt (cadr len) self ch))
		 (multiple-value (rubout-handler-starting-x rubout-handler-starting-y)
		   (send self ':read-cursorpos))
		 (send self ':string-out rubout-handler-buffer))
		((consp ch)
		 (when preemptable
		   (setf (rhb-scan-pointer) 0)
		   (*throw 'return-from-rubout-handler
			   (values ch (cadr preemptable)))))
		((and command-handler
		      (apply (cadr command-handler) ch (cddr command-handler)))
		 (setf (rhb-scan-pointer) 0)
		 (*throw 'return-from-rubout-handler
			 (values
			   `(:command ,ch 1)
			   ':command)))
		;; Don't touch this character, just return it to caller.
		((or (memq ch editing-command)
		     (si:assq-careful ch editing-command))
		 ;; Cause rubout handler rescan next time the user does :TYI.
		 (if rubbed-out-some (setf (rh-scan-pointer) most-positive-fixnum))
		 (return ch))
		;; Is it an editing character?
		((and (not (or (memq ch do-not-echo)
			       (and activation-handler
				    (apply (cadr activation-handler) ch (cddr activation-handler)))))
		      (or (ldb-test %%kbd-control-meta ch)
			  (and (memq ch '(#/Rubout #/Clear-input #/Clear-screen #/Delete))
			       (not (memq ch pass-through)))))
		 (cond ((memq ch '(#/Clear-screen #/Delete))	;Retype buffered input
			(send self ':tyo ch)		;Echo it
			(if (= ch #/Clear-screen) (send self ':clear-screen)
			  (send self ':tyo #/Newline))
			(multiple-value (prompt-starting-x prompt-starting-y)
			  (send self ':read-cursorpos))
			(and (setq len (or (assq ':reprompt rubout-handler-options)
					   (assq ':prompt rubout-handler-options)))
			     (rubout-handler-prompt (cadr len) self ch))
			(multiple-value (rubout-handler-starting-x rubout-handler-starting-y)
			  (send self ':read-cursorpos))
			(send self ':string-out rubout-handler-buffer))
		       ((memq ch '(#/Rubout #/M-rubout #/Clear-input)) ;Delete some characters
			(cond ((not (zerop (setq len (rhb-fill-pointer))))
			       (setf (rhb-fill-pointer)
				     (setq len (selectq ch
						 (#/Rubout (1- len))
						 (#/M-rubout (string-backward-word
							       rubout-handler-buffer len))
						 (#/Clear-input 0))))
			       (setf rubbed-out-some t
				     (rhb-status) ':rubout)
			       (multiple-value-bind (x y)
				   (send self ':compute-motion rubout-handler-buffer 0 len
						 rubout-handler-starting-x rubout-handler-starting-y)
				 (if rubout-handler-re-echo-flag
				     (setq x rubout-handler-starting-x y rubout-handler-starting-y))
				 (multiple-value-bind (cx cy) (send self ':read-cursorpos)
				   (send self ':clear-between-cursorposes x y cx cy))
				 (send self ':set-cursorpos x y)
				 (and rubout-handler-re-echo-flag
				      (send self ':string-out rubout-handler-buffer))))))
		       (t (beep)))				;Undefined editing character
		 (cond ((and (zerop (rhb-fill-pointer))
			     (assq ':full-rubout rubout-handler-options))
			(setf (rhb-scan-pointer) 0)
			(*throw 'rubout-handler t))))
		(t
		 ;; It's a self-inserting character.
		 ;; If this is first character typed in, re-get starting cursorpos since while
		 ;; waiting for input a notification may have been typed out.
		 (and (zerop (rhb-fill-pointer))
		      (multiple-value (rubout-handler-starting-x rubout-handler-starting-y)
			(send self ':read-cursorpos)))
		 (cond ((memq ch do-not-echo)
			(setq rubout-handler-activation-character ch))
		       ((and activation-handler
			     (apply (cadr activation-handler) ch (cddr activation-handler)))
			(setq ch `(:activation ,ch 1))
			(setq rubout-handler-activation-character ch))
		       (t
			(send self ':tyo ch)
			(array-push-extend rubout-handler-buffer ch)))
		 (cond (rubbed-out-some
			(setf (rhb-scan-pointer) 0)
			(*throw 'rubout-handler t))
		       (t
			(setf (rhb-scan-pointer) (rhb-fill-pointer))
			(setq rubout-handler-activation-character nil)
			(return ch)))))))))

;; Use ZWEI's syntax table if ZWEI is around...
(DEFUN STRING-BACKWARD-WORD (STRING INDEX &AUX ALPHA-P-FCN)
  (SETQ ALPHA-P-FCN
	(IF (BOUNDP 'ZWEI:*WORD-SYNTAX-TABLE*)
	    #'(LAMBDA (X) (EQ (ZWEI:CHAR-SYNTAX X ZWEI:*WORD-SYNTAX-TABLE*)
			      ZWEI:WORD-ALPHABETIC))
	    'ALPHA-CHAR-P))
  (DO ((I (1- INDEX) (1- I))
       (INSIDE-WORD NIL))
      ((MINUSP I) 0)
    (IF (FUNCALL ALPHA-P-FCN (AREF STRING I))
	(SETQ INSIDE-WORD T)
	(AND INSIDE-WORD (RETURN (1+ I))))))

(DEFUN RUBOUT-HANDLER-PROMPT (PROMPT-OPTION STREAM CH)
  (IF (STRINGP PROMPT-OPTION)
      (FUNCALL STREAM ':STRING-OUT PROMPT-OPTION)
    (FUNCALL PROMPT-OPTION STREAM CH)))
		
(defmethod (stream-mixin :save-rubout-handler-buffer) ()
  (when (eq rubout-handler-inside self)
    ;; Give rubout handler function a chance to put its internal data
    ;; into RUBOUT-HANDLER-BUFFER where we look for it.
;; not patched in 98.
    (let ((prop (get (or stream-rubout-handler
			 stream-mixin-rubout-handler)
		     'save-rubout-handler-buffer)))
      (when prop (funcall prop self)))
    (values (copy-seq rubout-handler-buffer) (rhb-typein-pointer))))

(defmethod (stream-mixin :restore-rubout-handler-buffer) (string &optional pointer)
  (let ((length (array-active-length string)))
    (or ( (array-length rubout-handler-buffer) length)
	(adjust-array-size rubout-handler-buffer length))
    (copy-array-contents string rubout-handler-buffer)
    (setf (rhb-fill-pointer) length))
  (setf (rhb-typein-pointer) pointer)
  (send self ':refresh-rubout-handler)
  (setf (rhb-scan-pointer) 0)
  (setf (rhb-status) ':restored)
  (*throw 'rubout-handler t))

(defmethod (stream-mixin :refresh-rubout-handler) (&optional discard-last-character)
  (if discard-last-character
      (setf (rhb-fill-pointer) (max 0 (1- (rhb-fill-pointer)))))
  (if (rhb-typein-pointer)
      (setf (rhb-typein-pointer)
	    (min (rhb-typein-pointer) (rhb-fill-pointer))))
  (send self ':fresh-line)
  (let ((prompt (or (assq ':reprompt rubout-handler-options)
		    (assq ':prompt rubout-handler-options))))
    (when prompt (rubout-handler-prompt (cadr prompt) self #/Delete)))
  (multiple-value (rubout-handler-starting-x rubout-handler-starting-y)
    (send self ':read-cursorpos))
  (send self ':string-out rubout-handler-buffer))

(DEFFLAVOR LINE-TRUNCATING-MIXIN () ()
  (:REQUIRED-FLAVORS STREAM-MIXIN)
  (:DOCUMENTATION :MIXIN "Causes stream output functions to truncate if the
SHEET-TRUNCATE-LINE-OUT-FLAG in the window is set."))

(DEFWRAPPER (LINE-TRUNCATING-MIXIN :TYO) (IGNORE . BODY)
  `(*CATCH 'LINE-OVERFLOW
     . ,BODY))

(DEFMETHOD (LINE-TRUNCATING-MIXIN :BEFORE :END-OF-LINE-EXCEPTION) ()
  (OR (ZEROP (SHEET-TRUNCATE-LINE-OUT-FLAG))
      (*THROW 'LINE-OVERFLOW T)))

(DEFMETHOD (LINE-TRUNCATING-MIXIN :STRING-OUT) (STRING &OPTIONAL (START 0) END)
  (OR END (SETQ END (STRING-LENGTH STRING)))
  (DO ((I START (1+ CR-IDX))
       (CR-IDX))
      (( I END))
    (SETQ CR-IDX (STRING-SEARCH-CHAR #/RETURN STRING I END))
    (*CATCH 'LINE-OVERFLOW
      (SHEET-STRING-OUT SELF STRING I (OR CR-IDX END)))
    (OR CR-IDX (RETURN NIL))
    (SHEET-CRLF SELF)))

(DEFFLAVOR TRUNCATING-WINDOW () (LINE-TRUNCATING-MIXIN WINDOW)
  (:DEFAULT-INIT-PLIST :TRUNCATE-LINE-OUT-FLAG 1)
  (:DOCUMENTATION :COMBINATION "A window that truncates line of output."))

(DEFFLAVOR AUTOEXPOSING-MORE-MIXIN () ()
  (:REQUIRED-FLAVORS WINDOW)
  (:DOCUMENTATION :MIXIN
   "Makes a window expose itself if output on it stops at a **MORE**."))

(DEFMETHOD (AUTOEXPOSING-MORE-MIXIN :BEFORE :MORE-EXCEPTION) ()
  (SEND SELF ':EXPOSE))

;;; Stream operations which all streams are required to support or ignore
;;; I'm afraid these will appear in the :WHICH-OPERATIONS even though they
;;; aren't "really supported"

;These 3 are ignored since we don't have buffered output
(DEFMETHOD (STREAM-MIXIN :CLEAR-OUTPUT) ()
  NIL)

(DEFMETHOD (STREAM-MIXIN :FORCE-OUTPUT) ()
  NIL)

(DEFMETHOD (STREAM-MIXIN :FINISH) ()
  NIL)

(DEFMETHOD (STREAM-MIXIN :CLOSE) (&OPTIONAL IGNORE)
  NIL)

(DEFMETHOD (STREAM-MIXIN :LINE-IN) (&OPTIONAL LEADER)
  (STREAM-DEFAULT-HANDLER SELF ':LINE-IN LEADER NIL))

(DEFMETHOD (STREAM-MIXIN :STRING-IN) (EOF &REST REST)
  (DECLARE (ARGLIST EOF STRING &OPTIONAL START END))
  (STREAM-DEFAULT-HANDLER SELF ':STRING-IN EOF REST))

(DEFMETHOD (STREAM-MIXIN :STRING-LINE-IN) (EOF &REST REST)
  (DECLARE (ARGLIST EOF STRING &OPTIONAL START END))
  (STREAM-DEFAULT-HANDLER SELF ':STRING-LINE-IN EOF REST))

(DEFFLAVOR GRAPHICS-MIXIN () ()
  ;; Explicit presence of SHEET helps init the flavor-unmapped-instance-variables.
  (:REQUIRED-FLAVORS SHEET ESSENTIAL-WINDOW)
  (:DOCUMENTATION :MIXIN
   "Provides graphics output operations for windows."))

(DEFMETHOD (GRAPHICS-MIXIN :POINT) (X Y)
  (SETQ X (+ X (SHEET-INSIDE-LEFT)) Y (+ Y (SHEET-INSIDE-TOP)))
  (IF (OR (< X (SHEET-INSIDE-LEFT)) ( X (SHEET-INSIDE-RIGHT))
	  (< Y (SHEET-INSIDE-TOP)) ( Y (SHEET-INSIDE-BOTTOM)))
      0
      (PREPARE-SHEET (SELF)
	(AR-2-REVERSE SCREEN-ARRAY X Y))))

(DEFMETHOD (GRAPHICS-MIXIN :DRAW-POINT) (X Y &OPTIONAL (ALU CHAR-ALUF) (VALUE -1))
  (SETQ X (+ X (SHEET-INSIDE-LEFT)) Y (+ Y (SHEET-INSIDE-TOP)))
  (OR (< X (SHEET-INSIDE-LEFT)) ( X (SHEET-INSIDE-RIGHT))
      (< Y (SHEET-INSIDE-TOP)) ( Y (SHEET-INSIDE-BOTTOM))
      (PREPARE-SHEET (SELF)
	 (AS-2-REVERSE (BOOLE ALU VALUE (AR-2-REVERSE SCREEN-ARRAY X Y))
		       SCREEN-ARRAY X Y))))

(DEFUN DRAW-LINE-CLIP-VISIBILITY (POINT-X POINT-Y &AUX VISIBILITY)
  (DECLARE (:SELF-FLAVOR GRAPHICS-MIXIN))
  (SETQ VISIBILITY (COND ((< POINT-X (SHEET-INSIDE-LEFT)) 1)
			 (( POINT-X (SHEET-INSIDE-RIGHT)) 2)
			 (T 0)))
  (COND ((< POINT-Y (SHEET-INSIDE-TOP)) (LOGIOR 4 VISIBILITY))
	(( POINT-Y (SHEET-INSIDE-BOTTOM)) (LOGIOR 8 VISIBILITY))
	(T VISIBILITY)))

(DEFMETHOD (GRAPHICS-MIXIN :DRAW-LINE) (FROM-X FROM-Y TO-X TO-Y
					&OPTIONAL (ALU CHAR-ALUF) (DRAW-END-POINT T))
  (SETQ FROM-X (+ FROM-X (SHEET-INSIDE-LEFT))
	FROM-Y (+ FROM-Y (SHEET-INSIDE-TOP))
	TO-X (+ TO-X (SHEET-INSIDE-LEFT))
	TO-Y (+ TO-Y (SHEET-INSIDE-TOP)))
  (DO ((FROM-VISIBILITY (DRAW-LINE-CLIP-VISIBILITY FROM-X FROM-Y)
			(DRAW-LINE-CLIP-VISIBILITY FROM-X FROM-Y))
       (TO-VISIBILITY (DRAW-LINE-CLIP-VISIBILITY TO-X TO-Y))
       (EXCHANGED NIL))
      ;;When completely visible, draw the line
      ((AND (ZEROP FROM-VISIBILITY) (ZEROP TO-VISIBILITY))
       (AND EXCHANGED (PSETQ FROM-X TO-X TO-X FROM-X FROM-Y TO-Y TO-Y FROM-Y))
       (PREPARE-SHEET (SELF)
	 (%DRAW-LINE FROM-X FROM-Y TO-X TO-Y ALU DRAW-END-POINT SELF)))
    ;;If all off the screen, dont draw anything
    (OR (ZEROP (LOGAND FROM-VISIBILITY TO-VISIBILITY)) (RETURN NIL))
    ;;Exchange points to try to make to point visible
    (AND (ZEROP FROM-VISIBILITY)
	 (PSETQ FROM-X TO-X TO-X FROM-X FROM-Y TO-Y TO-Y FROM-Y
		FROM-VISIBILITY TO-VISIBILITY TO-VISIBILITY FROM-VISIBILITY
		EXCHANGED (NOT EXCHANGED)))
    ;;If TO-X = FROM-X then FROM-VISIBILITY = 0, 4 or 8 so there is no danger
    ;; of divide by zero in the next "Push"
    (COND ((LDB-TEST 0001 FROM-VISIBILITY)	;Push toward left edge
	   (SETQ FROM-Y (+ FROM-Y (TRUNCATE (* (- TO-Y FROM-Y) (- (SHEET-INSIDE-LEFT) FROM-X))
				      (- TO-X FROM-X)))
		 FROM-X (SHEET-INSIDE-LEFT)))
	  ((LDB-TEST 0101 FROM-VISIBILITY)	;Push toward right edge
	   (SETQ FROM-Y (+ FROM-Y (TRUNCATE (* (- TO-Y FROM-Y) (- (SHEET-INSIDE-RIGHT) FROM-X 1))
				      (- TO-X FROM-X)))
		 FROM-X (1- (SHEET-INSIDE-RIGHT)))))
    (COND ((LDB-TEST 0201 FROM-VISIBILITY)	;Push toward top
	   ;;It is possible that TO-Y = FROM-Y at this point because of the effects of
	   ;; the last "Push", but in that case TO-X is probably equal to FROM-X as well
	   ;; (or at least close to it) so we needn't draw anything:
	   (AND (= TO-Y FROM-Y) (RETURN NIL))
	   (SETQ FROM-X (+ FROM-X (TRUNCATE (* (- TO-X FROM-X) (- (SHEET-INSIDE-TOP) FROM-Y))
				      (- TO-Y FROM-Y)))
		 FROM-Y (SHEET-INSIDE-TOP)))
	  ((LDB-TEST 0301 FROM-VISIBILITY)	;Push toward bottom
	   ;; Same:
	   (AND (= TO-Y FROM-Y) (RETURN NIL))
	   (SETQ FROM-X (+ FROM-X (TRUNCATE (* (- TO-X FROM-X) (- (SHEET-INSIDE-BOTTOM) FROM-Y 1))
				      (- TO-Y FROM-Y)))
		 FROM-Y (1- (SHEET-INSIDE-BOTTOM)))))))

;This never draws any end points, thus it is good for making closed polygons.
;Calls the :DRAW-LINE method to do the clipping.
(DEFMETHOD (GRAPHICS-MIXIN :DRAW-LINES) (ALU X1 Y1 &REST END-XS-AND-YS)
  (DO ((X2) (Y2) (METH (GET-HANDLER-FOR SELF ':DRAW-LINE))) ((NULL END-XS-AND-YS))
    (SETQ X2 (CAR END-XS-AND-YS)
	  Y2 (CADR END-XS-AND-YS)
	  END-XS-AND-YS (CDDR END-XS-AND-YS))
    (FUNCALL METH NIL X1 Y1 X2 Y2 ALU NIL)
    (SETQ X1 X2
	  Y1 Y2)))

(DEFMETHOD (GRAPHICS-MIXIN :DRAW-DASHED-LINE)
	   (X0 Y0 X1 Y1 &OPTIONAL (ALU CHAR-ALUF)
	    (DASH-SPACING 20.) SPACE-LITERALLY-P (OFFSET 0)
	    (DASH-LENGTH (FLOOR DASH-SPACING 2)))
  (LET (N-DASHES DISTANCE
	(REAL-DASH-SPACING DASH-SPACING)
	(REAL-DASH-LENGTH DASH-LENGTH)
	(METH (GET-HANDLER-FOR SELF ':DRAW-LINE)))
    (SETQ DISTANCE (SQRT (SMALL-FLOAT (+ (^ (- X1 X0) 2) (^ (- Y1 Y0)  2)))))
    (IF (ZEROP DISTANCE)
	(SEND SELF ':DRAW-POINT X0 Y0 ALU)
      (PROGN
	(IF SPACE-LITERALLY-P
	    ;; Get number of dashes of specified size that will fit.
	    (SETQ N-DASHES
		  (FLOOR (+ DISTANCE (- DASH-SPACING DASH-LENGTH)) DASH-SPACING))
	  ;; Get approximate number of dashes that will fit,
	  ;; then change spacing to make them fit exactly.
	  (SETQ N-DASHES (ROUND (+ DISTANCE (- DASH-SPACING DASH-LENGTH)) DASH-SPACING))
	  (IF (= N-DASHES 1)
	      (SETQ REAL-DASH-SPACING DISTANCE
		    REAL-DASH-LENGTH (- DISTANCE OFFSET OFFSET))
	    (SETQ REAL-DASH-SPACING
		  (// (- DISTANCE OFFSET OFFSET DASH-LENGTH) (1- N-DASHES)))))
	(LET ((X (+ X0 (* OFFSET (// (- X1 X0) DISTANCE))))
	      (Y (+ Y0 (* OFFSET (// (- Y1 Y0) DISTANCE))))
	      (DX (* REAL-DASH-LENGTH (// (- X1 X0) DISTANCE)))
	      (DY (* REAL-DASH-LENGTH (// (- Y1 Y0) DISTANCE)))
	      (DX2 (* REAL-DASH-SPACING (// (- X1 X0) DISTANCE)))
	      (DY2 (* REAL-DASH-SPACING (// (- Y1 Y0) DISTANCE))))
	  (DOTIMES (I N-DASHES)
	    (FUNCALL METH ':DRAW-LINE (FIXR X) (FIXR Y)
		     (FIXR (+ X DX)) (FIXR (+ Y DY))
		     ALU (< (1+ I) N-DASHES))
	    (INCF X DX2)
	    (INCF Y DY2)))))))
	
;This clips in microcode
(DEFMETHOD (GRAPHICS-MIXIN :DRAW-TRIANGLE) (X1 Y1 X2 Y2 X3 Y3 &OPTIONAL (ALU CHAR-ALUF))
  (PREPARE-SHEET (SELF)
    (%DRAW-TRIANGLE (+ X1 (SHEET-INSIDE-LEFT)) (+ Y1 (SHEET-INSIDE-TOP))
		    (+ X2 (SHEET-INSIDE-LEFT)) (+ Y2 (SHEET-INSIDE-TOP))
		    (+ X3 (SHEET-INSIDE-LEFT)) (+ Y3 (SHEET-INSIDE-TOP))
		    ALU SELF)))

;;; Very special kludgey macro for :DRAW-CIRCLE.
(DEFMACRO DRAW-CLIPPED-POINT (X-FORM Y-FORM)
  `(PROGN
     (SETQ X-VAL ,X-FORM
	   Y-VAL ,Y-FORM)
     (OR (< X-VAL IL) ( X-VAL IR)
	 (< Y-VAL IT) ( Y-VAL IB)
	 (AS-2-REVERSE (BOOLE ALU -1 (AR-2-REVERSE SCREEN-ARRAY X-VAL Y-VAL))
		       SCREEN-ARRAY X-VAL Y-VAL))))

(DEFMETHOD (GRAPHICS-MIXIN :DRAW-CIRCLE)
	   (CENTER-X CENTER-Y RADIUS &OPTIONAL (ALU CHAR-ALUF))
  (LET* ((IL (SHEET-INSIDE-LEFT))
	 (IT (SHEET-INSIDE-TOP))
	 (IR (SHEET-INSIDE-RIGHT))
	 (IB (SHEET-INSIDE-BOTTOM))
	 (CENTER-X (+ CENTER-X IL))
	 (CENTER-Y (+ CENTER-Y IT)))
    (PREPARE-SHEET (SELF)
      (DO ((Y 0)
	   (X-VAL) (Y-VAL)
	   (F 0)				; F is just Y squared without any multiplies
	   (X RADIUS))
	  (NIL)
	(DRAW-CLIPPED-POINT (+ CENTER-X X) (- CENTER-Y Y))
	(DRAW-CLIPPED-POINT (- CENTER-X X) (+ CENTER-Y Y))
	(DRAW-CLIPPED-POINT (+ CENTER-X Y) (+ CENTER-Y X))
	(DRAW-CLIPPED-POINT (- CENTER-X Y) (- CENTER-Y X))
	(SETQ F (+ F Y Y 1) Y (1+ Y))
	(COND (( F X) (SETQ F (- F X X -1) X (- X 1))))
	(COND ((> Y X) (RETURN)))
	(DRAW-CLIPPED-POINT (+ CENTER-X X) (+ CENTER-Y Y))
	(DRAW-CLIPPED-POINT (- CENTER-X X) (- CENTER-Y Y))
	(DRAW-CLIPPED-POINT (+ CENTER-X Y) (- CENTER-Y X))
	(DRAW-CLIPPED-POINT (- CENTER-X Y) (+ CENTER-Y X))
	(COND ((= Y X) (RETURN)))))))

;;;faster method by drm@xx
(DEFMETHOD (GRAPHICS-MIXIN :DRAW-FILLED-IN-CIRCLE)
           (CENTER-X CENTER-Y RADIUS &OPTIONAL (ALU CHAR-ALUF))
  (PREPARE-SHEET (SELF)
     (DO ((X RADIUS)
	  (Y 0 (1+ Y))
	  (ERROR 0 (+ ERROR Y Y 1))
	  OLD-Y)
	 ((> Y X))
       (WHEN ( ERROR X)			; Will the next chord be shorter?
	 ;; Draw the middle region.
	 (IF (NULL OLD-Y)			; First time through, draw one big rectangle.
	     (DRAW-RECTANGLE-INSIDE-CLIPPED (+ X X 1) (+ Y Y 1)
					    (- CENTER-X X) (- CENTER-Y Y) ALU SELF)
	   ;; Otherwise draw upper & lower rectangles.
	   (DRAW-RECTANGLE-INSIDE-CLIPPED (+ X X 1) (- Y OLD-Y)
					  (- CENTER-X X) (- CENTER-Y Y) ALU SELF)
	   (DRAW-RECTANGLE-INSIDE-CLIPPED (+ X X 1) (- Y OLD-Y)
					  (- CENTER-X X) (+ CENTER-Y OLD-Y 1) ALU SELF))
	 (SETQ OLD-Y Y)
	 (AND (= X Y) (RETURN NIL))		;Finished?
	 ;; Draw the top line.
	 (DRAW-RECTANGLE-INSIDE-CLIPPED (+ Y Y 1) 1
					(- CENTER-X Y) (+ CENTER-Y X) ALU SELF)
	 ;; Draw the bottom line.
	 (DRAW-RECTANGLE-INSIDE-CLIPPED (+ Y Y 1) 1
					(- CENTER-X Y) (- CENTER-Y X) ALU SELF)
	 (SETQ ERROR (- ERROR X X -1))
	 (DECF X)))))

;(DEFMETHOD (GRAPHICS-MIXIN :DRAW-FILLED-IN-CIRCLE)
;	   (CENTER-X CENTER-Y RADIUS &OPTIONAL (ALU CHAR-ALUF))
;  (LET ((CENTER-X (+ CENTER-X (SHEET-INSIDE-LEFT)))
;	(CENTER-Y (+ CENTER-Y (SHEET-INSIDE-TOP))))
;    (PREPARE-SHEET (SELF)
;      (DO ((X 0)
;	   (F 0)				; F is just x^2. Don't use multiplication!
;	   (Y RADIUS))
;	  ((> X Y))
;	(UNLESS (= X Y)
;	  (DRAW-RECTANGLE-INSIDE-CLIPPED (+ Y Y 1) 1 (- CENTER-X Y) (+ CENTER-Y X)
;					 ALU SELF)
;	  (UNLESS (ZEROP X)
;	    (DRAW-RECTANGLE-INSIDE-CLIPPED (+ Y Y 1) 1 (- CENTER-X Y) (- CENTER-Y X)
;					   ALU SELF)))
;	(SETQ F (+ F X X 1) X (1+ X))
;	(WHEN ( F Y)
;	  (SETQ F (- F Y Y -1) Y (- Y 1))
;	  (DRAW-RECTANGLE-INSIDE-CLIPPED (+ X X -1) 1
;					 (- CENTER-X X -1) (+ CENTER-Y Y 1)
;					 ALU SELF)
;	  (DRAW-RECTANGLE-INSIDE-CLIPPED (+ X X -1) 1
;					 (- CENTER-X X -1) (- CENTER-Y Y 1)
;					 ALU SELF))))))


(DEFMETHOD (GRAPHICS-MIXIN :DRAW-CIRCLE-OCTANT-ARC)
	   (CENTER-X CENTER-Y RADIUS &OPTIONAL (ALU CHAR-ALUF)
	    RIGHT-UP-START RIGHT-UP-END TOP-RIGHT-START TOP-RIGHT-END
	    TOP-LEFT-START TOP-LEFT-END LEFT-UP-START LEFT-UP-END
	    LEFT-DOWN-START LEFT-DOWN-END BOTTOM-LEFT-START BOTTOM-LEFT-END
	    BOTTOM-RIGHT-START BOTTOM-RIGHT-END RIGHT-DOWN-START RIGHT-DOWN-END)
  "Draw a portion of each octant of a circle.
There is one pair of a -START and a -END argument for each octant,
which controls the portion of that octant which is actually drawn."
  (LET* ((IL (SHEET-INSIDE-LEFT))
	 (IT (SHEET-INSIDE-TOP))
	 (IR (SHEET-INSIDE-RIGHT))
	 (IB (SHEET-INSIDE-BOTTOM))
	 (MAX-END (MAX RIGHT-UP-END TOP-LEFT-END LEFT-DOWN-END BOTTOM-RIGHT-END
		       (- (// 3.14159S0 4)
			  (MIN RIGHT-DOWN-END BOTTOM-LEFT-END
			       LEFT-UP-END TOP-RIGHT-END))))
	 (CENTER-X (+ CENTER-X IL))
	 (CENTER-Y (+ CENTER-Y IT)))
    (IF (NOT (ZEROP RADIUS))
	(PREPARE-SHEET (SELF)
	  (DO ((Y 0)
	       (X-VAL) (Y-VAL)
	       ANGLE
	       (F 0)				; F is just R squared without any multiplies
	       (X RADIUS))
	      (NIL)
	    (SETQ ANGLE (ATAN2 (SMALL-FLOAT Y) (SMALL-FLOAT X)))
	    ;; Octants counter clockwise from an axis
	    (IF (AND (< ANGLE RIGHT-UP-END) ( ANGLE RIGHT-UP-START))
		(DRAW-CLIPPED-POINT (+ CENTER-X X) (- CENTER-Y Y)))
	    (IF (AND (< ANGLE LEFT-DOWN-END) ( ANGLE LEFT-DOWN-START))
		(DRAW-CLIPPED-POINT (- CENTER-X X) (+ CENTER-Y Y)))
	    (IF (AND (< ANGLE BOTTOM-RIGHT-END) ( ANGLE BOTTOM-RIGHT-START))
		(DRAW-CLIPPED-POINT (+ CENTER-X Y) (+ CENTER-Y X)))
	    (IF (AND (< ANGLE TOP-LEFT-END) ( ANGLE TOP-LEFT-START))
		(DRAW-CLIPPED-POINT (- CENTER-X Y) (- CENTER-Y X)))
	    (IF (> ANGLE MAX-END) (RETURN))
	    (SETQ F (+ F Y Y 1) Y (1+ Y))
	    (COND (( F X) (SETQ F (- F X X -1) X (- X 1))))
	    (COND ((> Y X) (RETURN)))
	    ;; Clockwise
	    (SETQ ANGLE (- (// 3.14159S0 4) ANGLE))
	    (IF (AND (< ANGLE RIGHT-DOWN-END) ( ANGLE RIGHT-DOWN-START))
		(DRAW-CLIPPED-POINT (+ CENTER-X X) (+ CENTER-Y Y)))
	    (IF (AND (< ANGLE LEFT-UP-END) ( ANGLE LEFT-UP-START))
		(DRAW-CLIPPED-POINT (- CENTER-X X) (- CENTER-Y Y)))
	    (IF (AND (< ANGLE TOP-RIGHT-END) ( ANGLE TOP-RIGHT-START))
		(DRAW-CLIPPED-POINT (+ CENTER-X Y) (- CENTER-Y X)))
	    (IF (AND (< ANGLE BOTTOM-LEFT-END) ( ANGLE BOTTOM-LEFT-START))
		(DRAW-CLIPPED-POINT (- CENTER-X Y) (+ CENTER-Y X)))
	    (COND ((= Y X) (RETURN))))))))

(DEFMETHOD (GRAPHICS-MIXIN :DRAW-CIRCULAR-ARC)
	   (CENTER-X CENTER-Y RADIUS START-THETA END-THETA &OPTIONAL (ALU CHAR-ALUF)
	    &AUX (PI//4 (// 3.14159s0 4)))
  (LET* ((START-OCTANT (MULTIPLE-VALUE-BIND (NIL TEM)
			   (FLOOR (FIX (FLOOR START-THETA PI//4)) 8)
			 TEM))
	 (END-OCTANT (MULTIPLE-VALUE-BIND (NIL TEM)
			 (FLOOR (FIX (FLOOR END-THETA PI//4)) 8)
		       TEM))
	 N-OCTANTS)
    (IF (= START-OCTANT END-OCTANT)
	(SETQ N-OCTANTS
	      (IF ( START-THETA END-THETA (+ START-THETA PI//4))
		  1 9))
      (MULTIPLE-VALUE-BIND (NIL TEM)
	  (FLOOR (- END-OCTANT START-OCTANT) 8)
	(SETQ N-OCTANTS (1+ TEM))))
    ;; STARTS-AND-ENDS is a list of two angles for each octant,
    ;; a start and an end.  Both are between 0 and pi/4.
    (DO ((STARTS-AND-ENDS (MAKE-LIST 20 ':INITIAL-VALUE 0))
	 (OCTANT*2 (* START-OCTANT 2) (\ (+ 2 OCTANT*2) 20))
	 (COUNT 0 (1+ COUNT)))
	((= COUNT N-OCTANTS)
	 (LEXPR-SEND SELF ':DRAW-CIRCLE-OCTANT-ARC CENTER-X CENTER-Y RADIUS
		     ALU STARTS-AND-ENDS))
      (WHEN (= COUNT 10)
	;; if the arc is more than 7/4 pi and ends in same quadrant it starts in...
	;; Output all but the tail that ends in that octant,
	(LEXPR-SEND SELF ':DRAW-CIRCLE-OCTANT-ARC CENTER-X CENTER-Y RADIUS
		    ALU STARTS-AND-ENDS)
	;; Then zero the starts and ends so we can output that one last piece.
	(DO ((X STARTS-AND-ENDS (CDR X))) ((NULL X))
	  (RPLACA X 0)))
      (SETF (NTH OCTANT*2 STARTS-AND-ENDS)
	    (IF (ZEROP COUNT)
		(MULTIPLE-VALUE-BIND (NIL TEM)
		    (FLOOR START-THETA PI//4)
		  TEM)
	      0))
      (SETF (NTH (1+ OCTANT*2) STARTS-AND-ENDS)
	    (IF (= (1+ COUNT) N-OCTANTS)
		(MULTIPLE-VALUE-BIND (NIL TEM)
		    (FLOOR END-THETA PI//4)
		  TEM)
	      PI//4)))))

(DEFMETHOD (GRAPHICS-MIXIN :DRAW-FILLED-IN-SECTOR) (CENTER-X CENTER-Y RADIUS THETA-1 THETA-2
						    &OPTIONAL (ALU CHAR-ALUF))
  (PREPARE-SHEET (SELF)
    (DO ((Y (- RADIUS) (1+ Y))
	 (X 0)
	 (U0 0) (U1 0)				;Clipped plane 1
	 (V0 0) (V1 0)				;Clipped plane 2
	 (CO-X0 (FIX (* -1000.0 (SIN THETA-1))))
	 (CO-Y0 (FIX (*  1000.0 (COS THETA-1))))
	 (CO-X1 (FIX (* -1000.0 (SIN THETA-2))))
	 (CO-Y1 (FIX (*  1000.0 (COS THETA-2))))
	 (FLAG (> (ABS (- THETA-1 THETA-2)) 3.14159))
	 (R2 (* RADIUS RADIUS)))
	((> Y RADIUS))
      (SETQ X (ISQRT (- R2 (* Y Y))))		;Unclipped line
      (SETQ U0 (- X) U1 X
	    V0 (- X) V1 X)			;Init clipped lines
      
      (AND (PLUSP (- (* CO-Y0 Y) (* CO-X0 U1)))	;Clip with first plane
	   (SETQ U1 (IF (= 0 CO-X0) 0 (TRUNCATE (* CO-Y0 Y) CO-X0))))
      (AND (PLUSP (- (* CO-Y0 Y) (* CO-X0 U0)))
	   (SETQ U0 (IF (= 0 CO-X0) 0 (TRUNCATE (* CO-Y0 Y) CO-X0))))
      
      (AND (MINUSP (- (* CO-Y1 Y) (* CO-X1 V1)))	;Clip with second plane
	   (SETQ V1 (IF (= 0 CO-X1) 0 (TRUNCATE (* CO-Y1 Y) CO-X1))))
      (AND (MINUSP (- (* CO-Y1 Y) (* CO-X1 V0)))
	   (SETQ V0 (IF (= 0 CO-X1) 0 (TRUNCATE (* CO-Y1 Y) CO-X1))))
      
      ;; Ok, we have two lines, [U0 U1] and [V0 V1].
      ;; If the angle was greater than pi, then draw both of them,
      ;; otherwise draw their intersection
      (COND (FLAG
	     (AND (> U1 U0)
		  (SEND SELF ':DRAW-LINE
				(+ CENTER-X U0) (+ CENTER-Y Y)
				(+ CENTER-X U1) (+ CENTER-Y Y)
				ALU T))
	     (AND (> V1 V0)
		  (SEND SELF ':DRAW-LINE 
				(+ CENTER-X V0) (+ CENTER-Y Y)
				(+ CENTER-X V1) (+ CENTER-Y Y)
				ALU T)))
	    (T					;Compute intersection
	     (LET ((LEFT  (MAX U0 V0))
		   (RIGHT (MIN U1 V1)))
	       (AND (> RIGHT LEFT)
		    (SEND SELF ':DRAW-LINE 
				  (+ CENTER-X LEFT)  (+ CENTER-Y Y)
				  (+ CENTER-X RIGHT) (+ CENTER-Y Y)
				  ALU T))))))))

;;; Given an edge and a number of sides, draw something
;;; The sign of N determines which side of the line the figure is drawn on.
;;; If the line is horizontal, the rest of the polygon is in the positive direction
;;; when N is positive.
(DEFMETHOD (GRAPHICS-MIXIN :DRAW-REGULAR-POLYGON) (X1 Y1 X2 Y2 N &OPTIONAL (ALU CHAR-ALUF)
						   &AUX THETA)
  (IF (NOT (ZEROP N))
      (PROGN
	(SETQ THETA (* 3.14159 (1- (// 2.0 N)))
	      N (ABS N))  
	(PREPARE-SHEET (SELF)
	  (DO ((I 2 (1+ I))
	       (SIN-THETA (SIN THETA))
	       (COS-THETA (COS THETA))
	       (X0 X1) (Y0 Y1)
	       (X3) (Y3))
	      (( I N))
	    (SETQ X3 (+ (- (- (* X1 COS-THETA)
			      (* Y1 SIN-THETA))
			   (* X2 (1- COS-THETA)))
			(* Y2 SIN-THETA))
		  Y3 (- (- (+ (* X1 SIN-THETA)
			      (* Y1 COS-THETA))
			   (* X2 SIN-THETA))
			(* Y2 (1- COS-THETA))))
	    (%DRAW-TRIANGLE (+ (SHEET-INSIDE-LEFT) (FIX X0)) (+ (SHEET-INSIDE-TOP) (FIX Y0))
			    (+ (SHEET-INSIDE-LEFT) (FIX X2)) (+ (SHEET-INSIDE-TOP) (FIX Y2))
			    (+ (SHEET-INSIDE-LEFT) (FIX X3)) (+ (SHEET-INSIDE-TOP) (FIX Y3))
			    ALU SELF)
	    (SETQ X1 X2 Y1 Y2
		  X2 X3 Y2 Y3))))))

;;; Display vectors of points
(DEFMETHOD (GRAPHICS-MIXIN :DRAW-CURVE) (PX PY &OPTIONAL END (ALU CHAR-ALUF)
					 CLOSED-CURVE-P)
  (OR END (SETQ END (ARRAY-ACTIVE-LENGTH PX)))
  (LET ((X0)
	(X1 (FIX (AREF PX 0)))
	(Y0)
	(Y1 (FIX (AREF PY 0)))
	(METH (GET-HANDLER-FOR SELF ':DRAW-LINE)))
    (DO ((I 1 (1+ I)))
	(( I END))
      (SETQ X0 X1)
      (OR (SETQ X1 (AREF PX I)) (RETURN NIL))
      (SETQ X1 (FIX X1))
      (SETQ Y0 Y1)
      (OR (SETQ Y1 (AREF PY I)) (RETURN NIL))
      (SETQ Y1 (FIX Y1))
      (FUNCALL METH NIL X0 Y0 X1 Y1 ALU NIL))
    (WHEN CLOSED-CURVE-P
      (FUNCALL METH NIL X1 Y1 (FIX (AREF PX 0)) (FIX (AREF PY 0)) ALU NIL))))

;;; Display vectors of points
(DEFMETHOD (GRAPHICS-MIXIN :DRAW-CLOSED-CURVE) (PX PY &OPTIONAL END (ALU CHAR-ALUF))
  (SEND SELF ':DRAW-CURVE PX PY END ALU T))

(DEFMETHOD (GRAPHICS-MIXIN :DRAW-WIDE-CURVE) (PX PY -WIDTH- &OPTIONAL END (ALU CHAR-ALUF)
					      CLOSED-CURVE-P)
  (OR END (SETQ END (ARRAY-ACTIVE-LENGTH PX)))
  (SETQ -WIDTH- (// -WIDTH- 2.0s0))
  (PREPARE-SHEET (SELF)
    (DO ((I 0 (1+ I))
	 (X0) (Y0)
	 (X1) (Y1)
	 (PX1) (PY1)
	 (PX2) (PY2)
	 (PX3) (PY3)
	 (PX4) (PY4)
	 EXIT-NEXT-TIME)
	(EXIT-NEXT-TIME)
      (SETQ X0 X1)
      (SETQ Y0 Y1)
      (IF ( I END)
	  (SETQ X1 NIL Y1 NIL)
	(SETQ X1 (AREF PX I))
	(SETQ Y1 (AREF PY I)))
      (UNLESS (AND X1 Y1)
	;; If we have passed the last point, either exit now or close the curve and then exit.
	(IF CLOSED-CURVE-P
	    (SETQ X1 (AREF PX 0) Y1 (AREF PY 0)
		  EXIT-NEXT-TIME T)
	  (RETURN NIL)))
      (OR (= I 0)
	  (LET ((DX (- X1 X0))
		(DY (- Y1 Y0))
		LEN)
	    (SETQ LEN (SMALL-FLOAT (SQRT (+ (* DX DX) (* DY DY)))))
	    (AND (ZEROP LEN) (= I 1) (SETQ LEN 1))
	    (COND ((NOT (ZEROP LEN))
		   (PSETQ DX (// (* -WIDTH- DY) LEN)
			  DY (// (* -WIDTH- DX) LEN))
		   (IF (= I 1)
		       (SETQ PX1 (FIX (- X0 DX)) PY1 (FIX (+ Y0 DY))
			     PX2 (FIX (+ X0 DX)) PY2 (FIX (- Y0 DY)))
		       (SETQ PX1 PX3 PY1 PY3 PX2 PX4 PY2 PY4))
		   (SETQ PX3 (FIX (- X1 DX)) PY3 (FIX (+ Y1 DY))
			 PX4 (FIX (+ X1 DX)) PY4 (FIX (- Y1 DY)))
		   (%DRAW-TRIANGLE (+ (SHEET-INSIDE-LEFT) PX1) (+ (SHEET-INSIDE-TOP) PY1)
				   (+ (SHEET-INSIDE-LEFT) PX2) (+ (SHEET-INSIDE-TOP) PY2)
				   (+ (SHEET-INSIDE-LEFT) PX4) (+ (SHEET-INSIDE-TOP) PY4)
				   ALU SELF)
		   (%DRAW-TRIANGLE (+ (SHEET-INSIDE-LEFT) PX1) (+ (SHEET-INSIDE-TOP) PY1)
				   (+ (SHEET-INSIDE-LEFT) PX3) (+ (SHEET-INSIDE-TOP) PY3)
				   (+ (SHEET-INSIDE-LEFT) PX4) (+ (SHEET-INSIDE-TOP) PY4)
				   ALU SELF))))))))

;;; Cubic splines from Rogers and Adams, "Mathematical Elements
;;; for Computer Graphics".  This began as a translation from
;;; a BASIC program, but has been changed a bit.  The original
;;; program uses a full matrix inversion when the boundary conditions
;;; are cyclic or anti-cyclic, which is inefficient; in this version
;;; the special-case tridiagonal solver is extended to handle the
;;; cyclic and anti-cyclic end conditions.  (Also, the original program
;;; has a bug wherein it neglects to initialize one diagonal of the M matrix.)

(DEFUN SPLINE (PX PY Z &OPTIONAL CX CY (C1 ':RELAXED) (C2 C1)
	       P1-PRIME-X P1-PRIME-Y PN-PRIME-X PN-PRIME-Y
	       &AUX N N-1 N-2 N-3 BX BY L UX UY N1 N2 N3 N4 SIGN
		    (ZUNDERFLOW T) CLEN)
  "Compute cubic splines.  PX and PY are arrays of X-coords and Y-coords.
They describe a sequeuce of points through which a smooth
curve should be drawn.  This program generates Z intermediate
points between each pair of points, returning a sequence of points
in CX and CY that includes the original points with the intermediate
points inserted.  The caller can then plot lines between successive
pairs of points of CX and CY to draw the curve.

The caller may pass in arrays to be filled in with the answers (used as
CX and CY); they should be (+ N (* Z (- N 1))) long.  If NIL is passed,
this function creates the arrays itself.  If they are not long enough,
they are adjusted with ADJUST-ARRAY-SIZE.

The optional argument C1 is the initial end condition, one of
:RELAXED, :CLAMPED, :CYCLIC, or :ANTI-CYCLIC; C2 is the final end
condition, one of :RELAXED or :CLAMPED.  The first defaults to
:RELAXED, and the second defaults to the first.  The second must be
the same as the first if the first is :CYCLIC or :ANTI-CYCLIC.  The
last four arguments are the X and Y values to which the endpoints are
being clamped if the corresponding boundary condition is :CLAMPED.
For cyclic splines that join themselves, the caller must pass the same
point twice, as both the first point and the last point.

P1-PRIME-X, etc., specify the slopes at the two endpoints,
for the sake of :CLAMPED constraints.

Three values are returned: The two arrays CX and CY, and the number
of active elements those arrays."
  (DECLARE (RETURN-LIST CX CY NUMBER-OF-POINTS))
  (SETQ N (ARRAY-ACTIVE-LENGTH PX)		;The number of points
	N-1 (1- N)
	N-2 (1- N-1)
	N-3 (1- N-2))
  (SETQ CLEN (+ N (* N-1 Z)))

  ;; Create the arrays if they were not given them, or redimension them if needed.
  (COND ((NULL CX)
	 (SETQ CX (MAKE-ARRAY CLEN)))
	((< (ARRAY-LENGTH CX) CLEN)
	 (SETQ CX (ADJUST-ARRAY-SIZE CX CLEN))))
  (COND ((NULL CY)
	 (SETQ CY (MAKE-ARRAY CLEN)))
	((< (ARRAY-LENGTH CY) CLEN)
	 (SETQ CY (ADJUST-ARRAY-SIZE CY CLEN))))

  ;; Set up L to hold the approximate spline segment lengths.
  ;; The Nth element of L holds the distance between the Nth and N+1st
  ;; points of PX,PY.  The last element of L is not used.
  (SETQ L (MAKE-ARRAY N))
  (LOOP FOR J FROM 0 TO N-2
	DO (ASET (SMALL-FLOAT (SQRT (+ (^ (- (AREF PX (1+ J)) (AREF PX J)) 2)
				       (^ (- (AREF PY (1+ J)) (AREF PY J)) 2))))
		 L J))

  ;; The bulk of the code here is concerned with solving a set of
  ;; simultaneous linear equations, expressed by the matrix equation
  ;; M * U = B.  M is an N by N square matrix, and B and U are N by 1
  ;; column matricies.  U will hold the values of the slope of the curve
  ;; at each point PX, PY.

  ;; The M matrix is tridiagonal for :RELAXED and :CLAMPED end conditions.
  ;; We represent it by storing M(I,I-1) in N1(I), M(I,I) in N2(I), and
  ;; M(I,I+1) in N3(I).  This means N1(0) and N3(N-1) are unused.
  (SETQ N1 (MAKE-ARRAY N)
	N2 (MAKE-ARRAY N)
	N3 (MAKE-ARRAY N))

  ;; These quantities are meaningless, but they get referred to as part
  ;; of array bound conditions; these values just prevent errors from happening.
  (ASET 0.0s0 N1 0)
  (ASET 0.0s0 N3 N-1)

  (COND ((MEMQ C1 '(:CYCLIC :ANTI-CYCLIC))
	 ;; With these conditions, the M matrix is not quite tri-diagonal;
	 ;; it is initialize with a 1 in the upper-right hand corner, and
	 ;; during the solution of the equations the whole right column
	 ;; gets non-zero values.  Also, it is only N-1 by N-1!  So the upper
	 ;; right corner is M(0, N-2).  N4 represents the N-2 column; element
	 ;; M(I,N-2) is stored in N4(I).  The last two elements are not
	 ;; used, because N4(N-2) = N2(N-2) and N4(N-3) = N3(N-3).  We also
	 ;; set up this handy SIGN variable.
	 (SETQ N4 (MAKE-ARRAY (1- N)))
	 (SETQ SIGN (IF (EQ C1 ':CYCLIC) 1.0s0 -1.0s0)))
	((NOT (MEMQ C1 '(:RELAXED :CLAMPED)))
	 (FERROR NIL "~S is not known spline type" C1)))
  ;; B is just a column vector, represented normally.
  (SETQ BX (MAKE-ARRAY N)
	BY (MAKE-ARRAY N))

  ;; Set up the boundary conditions.
  ;; The 0th row of M and B are determined by the initial boundary conditions,
  ;; and the N-1st row is determined by the final boundary condition.
  ;; Note that the 0th row of M is implemented as the 0th element of N2, N3,
  ;; and sometimes N4; N1(0) is not used.  A similar thing is true of the
  ;; N-1st row.
  (SELECTQ C1
    (:CLAMPED
       (ASET 1.0s0 N2 0)
       (ASET 0.0s0 N3 0)
       (ASET P1-PRIME-X BX 0)
       (ASET P1-PRIME-Y BY 0))
    (:RELAXED
       (ASET 1.0s0 N2 0)
       (ASET 0.5s0 N3 0)
       (LET ((TEM (// 3.0s0 (* 2.0s0 (AREF L 0)))))
	 (ASET (* TEM (- (AREF PX 1) (AREF PX 0))) BX 0)
	 (ASET (* TEM (- (AREF PY 1) (AREF PY 0))) BY 0)))
    ((:CYCLIC :ANTI-CYCLIC)
       (LET ((S3 (// (AREF L N-2) (AREF L 0))))
	 (ASET (+ 2.0s0 (* S3 2.0s0)) N2 0)
	 (ASET S3 N3 0)
	 (ASET SIGN N4 0)
	 (LET ((TEM (// 3.0s0 (AREF L 0))))
	   (ASET (* TEM (+ (* S3 (- (AREF PX 1) (AREF PX 0)))
			   (* SIGN (// (- (AREF PX N-1) (AREF PX N-2)) S3))))
		 BX 0)
	   (ASET (* TEM (+ (* S3 (- (AREF PY 1) (AREF PY 0)))
			   (* SIGN (// (- (AREF PY N-1) (AREF PY N-2)) S3))))
		 BY 0)))))
  (SELECTQ C2
    (:CLAMPED
       (ASET 0.0s0 N1 N-1)
       (ASET 1.0s0 N2 N-1)
       (ASET PN-PRIME-X BX N-1)
       (ASET PN-PRIME-Y BY N-1))
    (:RELAXED
       (ASET 2.0s0 N1 N-1)
       (ASET 4.0s0 N2 N-1)
       (LET ((TEM (// 6.0s0 (AREF L N-2))))
	 (ASET (* TEM (- (AREF PX N-1) (AREF PX N-2))) BX N-1)
	 (ASET (* TEM (- (AREF PY N-1) (AREF PY N-2))) BY N-1)))
    ;; Note: there are no final end conditions for :CYCLIC and :ANTI-CYCLIC,
    ;; since they are the same at each end.  The M matrix has no N-1st row,
    ;; either, as it is smaller by one row and one column.
    )

  ;; Now fill in the insides of M and B arrays.
  (LOOP FOR J FROM 1 TO N-2
	AS L0 := (AREF L 0) THEN L1
	AS L1 := (AREF L 1) THEN (AREF L J)
	AS PX0 := (AREF PX 0) THEN PX1
	AS PX1 := (AREF PX 1) THEN PX2
	AS PX2 := (AREF PX (1+ J))
	AS PY0 := (AREF PY 0) THEN PY1
	AS PY1 := (AREF PY 1) THEN PY2
	AS PY2 := (AREF PY (1+ J))
	DO (ASET L1 N1 J)
	   (ASET (* 2 (+ L0 L1)) N2 J)
	   (ASET L0 N3 J)
	   (IF N4 (ASET 0.0s0 N4 J))
	   (ASET (// (* 3.0s0 (+ (* (^ L0 2) (- PX2 PX1)) (* (^ L1 2) (- PX1 PX0))))
		     (* L0 L1)) BX J)
	   (ASET (// (* 3.0s0 (+ (* (^ L0 2) (- PY2 PY1)) (* (^ L1 2) (- PY1 PY0))))
		     (* L0 L1)) BY J))

  ;; Now that we have the matricies filled in, we solve the equations.
  ;; We use Gaussian elimination, with a special version that takes
  ;; advantage of the sparsity of this tridiagonal or almost-tridiagonal
  ;; matrix to run in time O(n) instead of O(n**3).  No pivoting is used,
  ;; because for any real dat (not all zeroes, for example) the matrix
  ;; is both irreducible and diagonally-dominant, and therefore pivoting
  ;; is not needed (Forsythe and Moler, p. 117,  exercise 23.10).
  ;; The first step is to make the matrix upper-triangular, by making all of
  ;; N1 be zero.
  (LET ((Q (AREF N2 0)))				;Normalize row 0.
    (ASET (// (AREF N3 0) Q) N3 0)
    (IF N4 (ASET (// (AREF N4 0) Q) N4 0))
    (ASET (// (AREF BX 0) Q) BX 0)
    (ASET (// (AREF BY 0) Q) BY 0))
  (LOOP FOR I FROM 1 TO (IF (NULL N4) N-1 N-2)
	AS N1I := (AREF N1 I)
	WHEN (NOT (ZEROP N1I))				;If it is zero already, OK.
	DO (LET ((D (// 1.0s0 N1I)))
	     ;; D = M(I-1, I-1) / M(I, I-1)  so multiply row I
	     ;;   by D and subtract row I-1 from row I.
	     (ASET (- (* D (AREF N2 I)) (AREF N3 (1- I))) N2 I)
	     (ASET (* D (AREF N3 I)) N3 I) ; Uses N3(N-1), a garbage element.
	     (COND (N4
		    (ASET (- (* D (AREF N4 I)) (AREF N4 (1- I))) N4 I)
		    (IF (= I N-3)
			;; In this case, N4(N-4) is above N3(N-3), so
			;; it must be subtracted out.
			(ASET (- (AREF N3 I) (AREF N4 (1- I))) N3 I))))
	     (ASET (- (* D (AREF BX I)) (AREF BX (1- I))) BX I)
	     (ASET (- (* D (AREF BY I)) (AREF BY (1- I))) BY I)
	     )
	;; Next normalize, by dividing row I through by M(I,I).
	;; This leaves the center diagonal all 1.0s0, which the
	;; back-solver in R&A doesn't take advantage of.
	   (LET ((Q (AREF N2 I)))
	     (ASET (// (AREF N3 I) Q) N3 I)
	     (IF N4 (ASET (// (AREF N4 I) Q) N4 I))
	     (ASET (// (AREF BX I) Q) BX I)
	     (ASET (// (AREF BY I) Q) BY I)))

  ;; Create the arrays to hold the answers.
  (SETQ UX (MAKE-ARRAY N)		;Tangent vector matrix
	UY (MAKE-ARRAY N))

  ;; Backsolve the upper-triangular matrix.
  (COND ((NOT N4)
	 ;; Simpler version if there is no N4.
	 (ASET (AREF BX N-1) UX N-1)
	 (ASET (AREF BY N-1) UY N-1)
	 (LOOP FOR J FROM N-2 DOWNTO 0
	       DO (LET ((N3J (AREF N3 J)))
		    (ASET (- (AREF BX J) (* N3J (AREF UX (1+ J)))) UX J)
		    (ASET (- (AREF BY J) (* N3J (AREF UY (1+ J)))) UY J))))
	(T
	 ;; Hairier version with N4.
	 (LET ((UXN-2 (AREF BX N-2))
	       (UYN-2 (AREF BY N-2)))
	   (ASET UXN-2 UX N-2)
	   (ASET UYN-2 UY N-2)
	   (ASET (- (AREF BX N-3) (* (AREF N3 N-3) UXN-2)) UX N-3)
	   (ASET (- (AREF BY N-3) (* (AREF N3 N-3) UYN-2)) UY N-3)
	   (LOOP FOR J FROM (1- N-3) DOWNTO 0
		 DO (LET ((N3J (AREF N3 J))
			  (N4J (AREF N4 J)))
		      (ASET (- (AREF BX J)
			       (* N3J (AREF UX (1+ J)))
			       (* N4J UXN-2))
			    UX J)
		      (ASET (- (AREF BY J)
			       (* N3J (AREF UY (1+ J)))
			       (* N4J UYN-2))
			    UY J))))
	 (ASET (* SIGN (AREF UX 0)) UX N-1)
	 (ASET (* SIGN (AREF UY 0)) UY N-1)))

  (MULTIPLE-VALUE (CX CY)
    (CURGEN N PX PY Z CX CY L UX UY))		; Generate it

  (RETURN-ARRAY UY)
  (RETURN-ARRAY UX)
  (RETURN-ARRAY BY)
  (RETURN-ARRAY BX)
  (IF N4 (RETURN-ARRAY N4))
  (RETURN-ARRAY N3)
  (RETURN-ARRAY N2)
  (RETURN-ARRAY N1)
  (RETURN-ARRAY L)

  (VALUES CX CY CLEN))

;;; Generate the spline curve points.
;;; This is a separate function because if it got merged, there would
;;; be too many local variables.
(DEFUN CURGEN (N PX PY Z CX CY L UX UY)
  (LOOP WITH I := 0
	FOR J FROM 0 TO (- N 2)
	FOR LEN := (AREF L J)
	FOR LEN^2 := (^ LEN 2)
	FOR LEN^3 := (* LEN^2 LEN)
	FOR FX1 := (AREF PX J)
	FOR FX2 := (AREF UX J)
	FOR TEMX := (- (AREF PX (1+ J)) FX1)
	FOR TEMX1 := (+ (AREF UX (1+ J)) FX2)
	FOR FX3 := (- (* (// 3.0s0 LEN^2) TEMX) (// (+ TEMX1 FX2) LEN))
	FOR FX4 := (+ (* (// -2.0s0 LEN^3) TEMX) (// TEMX1 LEN^2))
	FOR FY1 := (AREF PY J)
	FOR FY2 := (AREF UY J)
	FOR TEMY := (- (AREF PY (1+ J)) FY1)
	FOR TEMY1 := (+ (AREF UY (1+ J)) FY2)
	FOR FY3 := (- (* (// 3.0s0 LEN^2) TEMY) (// (+ TEMY1 FY2) LEN))
	FOR FY4 := (+ (* (// -2.0s0 LEN^3) TEMY) (// TEMY1 LEN^2))
	DO (LOOP FOR K FROM 0 TO Z
		 FOR X FROM 0 BY (// LEN (1+ Z))
		 DO (ASET (+ FX1 (* FX2 X) (* FX3 (^ X 2)) (* FX4 (^ X 3))) CX I)
		    (ASET (+ FY1 (* FY2 X) (* FY3 (^ X 2)) (* FY4 (^ X 3))) CY I)
		    (SETQ I (1+ I)))
	FINALLY (PROGN (ASET (SMALL-FLOAT (AREF PX (1- N))) CX I)
		       (ASET (SMALL-FLOAT (AREF PY (1- N))) CY I)
		       (RETURN CX CY))))

(DEFMETHOD (GRAPHICS-MIXIN :DRAW-CUBIC-SPLINE)
	   (PX PY Z &OPTIONAL CURVE-WIDTH ALU (C1 ':RELAXED) (C2 C1)
	               P1-PRIME-X P1-PRIME-Y PN-PRIME-X PN-PRIME-Y)
  (IF (NULL CURVE-WIDTH)
      (SETQ CURVE-WIDTH 1))
  (IF (NULL ALU)
      (SETQ ALU CHAR-ALUF))
  (MULTIPLE-VALUE-BIND (CX CY I)
      (SPLINE PX PY Z NIL NIL C1 C2 P1-PRIME-X P1-PRIME-Y PN-PRIME-X PN-PRIME-Y)
    (IF (= CURVE-WIDTH 1)
	(SEND SELF ':DRAW-CURVE CX CY I ALU)
	(SEND SELF ':DRAW-WIDE-CURVE CX CY CURVE-WIDTH I ALU))))



