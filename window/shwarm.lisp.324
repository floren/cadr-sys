;;; -*- Mode: LISP; Package: TV; Base: 8 -*-
;;;	** (c) Copyright 1980, 1981 Massachusetts Institute of Technology **

(DEFMACRO COERCE-FONT (FONT-VARIABLE SHEET)
  `(UNLESS (TYPEP ,FONT-VARIABLE 'FONT)
     (SETQ ,FONT-VARIABLE (SEND (SHEET-GET-SCREEN ,SHEET) ':PARSE-FONT-SPECIFIER
				,FONT-VARIABLE))))

;;;Miscellaneous user functions
(COMMENT
(DEFUN SCREEN-CLEAR (&OPTIONAL (SCREEN DEFAULT-SCREEN))
  "This function is obsolete, but may still be called."
  ;; It isn't really obsolete, the initialization right below calls it
  ;; No it doesn't!!
  (WITHOUT-INTERRUPTS
    (PREPARE-SHEET (SCREEN)
      (%DRAW-RECTANGLE (SHEET-WIDTH SCREEN) (SHEET-HEIGHT SCREEN)
		       0 0
		       ALU-ANDCA SCREEN))
    (AND (FBOUNDP 'WHO-LINE-CLOBBERED)
	 (WHO-LINE-CLOBBERED))
    (AND (FBOUNDP 'SCREEN-MANAGE-FLUSH-KNOWLEDGE)
	 (SCREEN-MANAGE-FLUSH-KNOWLEDGE SCREEN)))))

(DEFUN SCREEN-REDISPLAY (&OPTIONAL (TYPE ':COMPLETE-REDISPLAY) (SCREEN DEFAULT-SCREEN))
  "Redisplay the entire contents of SCREEN"
  (FUNCALL SCREEN ':REFRESH TYPE)
  (WHO-LINE-CLOBBERED))

(DEFMETHOD (SCREEN :BEEP) (&OPTIONAL BEEP-TYPE)
  "Beep the beeper."
  BEEP-TYPE  ;We wanted to make this soo hairy, that we punted until we could do it right
  (AND BEEP
       (WITHOUT-INTERRUPTS  ;otherwise might quit out and leave screen complemented
	 (OR (EQ BEEP ':BEEP) (COMPLEMENT-BOW-MODE SELF))
	 (IF (EQ BEEP ':FLASH)
	     (%BEEP 0 BEEP-DURATION)	;Delay same time without making any noise
	   (BEEP BEEP-TYPE 'IGNORE))
	 (OR (EQ BEEP ':BEEP) (COMPLEMENT-BOW-MODE SELF)))))

(DEFMETHOD (SHEET :BEEP) (&OPTIONAL BEEP-TYPE)
  (AND SUPERIOR (FUNCALL SUPERIOR ':BEEP BEEP-TYPE)))

(DEFUN BEEP (&OPTIONAL BEEP-TYPE (STREAM TERMINAL-IO))
  "Ring the bell and flash the screen.
Works via the :BEEP operation on STREAM if STREAM supports it.
The value of BEEP controls what this function does:
 T means flash the screen and make noise,
 :BEEP means just make noise, :FLASH means just flash.
 NIL means do nothing.
BEEP-TYPE says why the beep is being done.  Standard values are:
 ZWEI:CONVERSE-PROBLEM -- Converse was unable to send a message.
 ZWEI:CONVERSE-MESSAGE-RECEIVED -- A Converse message has come in.
 ZWEI:NO-COMPLETION -- Completion in a minibuffer failed.
 TV:NOTIFY -- A notification cannot be printed on the selected window.
 SUPDUP:TERMINAL-BELL -- ``Bell'' received for terminal
 FQUERY -- When a question needs to be answered
 NIL -- anything else.
BEEP-TYPE does not have any effect, currently,
but you can redefine BEEP to to different things for different beep types."
  (WHEN BEEP
    (IF (MEMQ ':BEEP (FUNCALL STREAM ':WHICH-OPERATIONS))
	(FUNCALL STREAM ':BEEP BEEP-TYPE)
      (%BEEP BEEP-WAVELENGTH BEEP-DURATION))))


(DEFUN BLACK-ON-WHITE (&OPTIONAL (SCREEN DEFAULT-SCREEN))
  "Set SCREEN to display one bits as black and zeros as white."
  (SELECT PROCESSOR-TYPE-CODE
    (SI:CADR-TYPE-CODE
     (%XBUS-WRITE (SCREEN-CONTROL-ADDRESS SCREEN)
		    (LOGIOR 4 (%XBUS-READ (SCREEN-CONTROL-ADDRESS SCREEN)))))
    (SI:LAMBDA-TYPE-CODE
     (%NUBUS-WRITE TV:TV-QUAD-SLOT 4
		   (LOGIOR 20 (%NUBUS-READ TV:TV-QUAD-SLOT 4))))))

(DEFUN WHITE-ON-BLACK (&OPTIONAL (SCREEN DEFAULT-SCREEN))
  "Set SCREEN to display one bits as white and zeros as black."
  (SELECT PROCESSOR-TYPE-CODE
    (SI:CADR-TYPE-CODE
     (%XBUS-WRITE (SCREEN-CONTROL-ADDRESS SCREEN)
		  (LOGAND -5 (%XBUS-READ (SCREEN-CONTROL-ADDRESS SCREEN))))) ;1's comp of 4
    (SI:LAMBDA-TYPE-CODE
     (%NUBUS-WRITE TV:TV-QUAD-SLOT 4
		   (LOGAND (LOGNOT 20) (%NUBUS-READ TV:TV-QUAD-SLOT 4))))))

(DEFUN COMPLEMENT-BOW-MODE (&OPTIONAL (SCREEN DEFAULT-SCREEN))
  "Complement whether SCREEN displays one bits as white or as black."
  (SELECT PROCESSOR-TYPE-CODE
    (SI:CADR-TYPE-CODE
     (%XBUS-WRITE (SCREEN-CONTROL-ADDRESS SCREEN)
		    (LOGXOR 4 (%XBUS-READ (SCREEN-CONTROL-ADDRESS SCREEN)))))
    (SI:LAMBDA-TYPE-CODE
     (%NUBUS-WRITE TV:TV-QUAD-SLOT 4
		   (LOGXOR 20 (%NUBUS-READ TV:TV-QUAD-SLOT 4))))))

(DEFMETHOD (SHEET :DRAW-RECTANGLE) (RECTANGLE-WIDTH RECTANGLE-HEIGHT X Y
				    &OPTIONAL (ALU CHAR-ALUF))
  (PREPARE-SHEET (SELF)
    (DRAW-RECTANGLE-INSIDE-CLIPPED RECTANGLE-WIDTH RECTANGLE-HEIGHT X Y ALU SELF)))

(DEFMETHOD (SHEET :BITBLT) (ALU WID HEI FROM-ARRAY FROM-X FROM-Y TO-X TO-Y
				   &AUX (IL (SHEET-INSIDE-LEFT))
				        (IR (SHEET-INSIDE-RIGHT))
					(IT (SHEET-INSIDE-TOP))
					(IB (SHEET-INSIDE-BOTTOM)))
  (SETQ TO-X (+ IL TO-X) TO-Y (+ IT TO-Y))
  (LET* ((CLIPPED-TO-X				
	   (MIN (MAX IL TO-X) IR))
	 (CLIPPED-TO-Y
	   (MIN (MAX IT TO-Y) IB))
	 (WID-SIGN (IF (MINUSP WID) -1 1))
	 (HEI-SIGN (IF (MINUSP HEI) -1 1))
	 (LEFT-OVERRUN
	   (- CLIPPED-TO-X TO-X))
	 (RIGHT-OVERRUN
	   (MAX 0 (- (+ CLIPPED-TO-X (ABS WID)) IR)))
	 (TOP-OVERRUN
	   (- CLIPPED-TO-Y TO-Y))
	 (BOTTOM-OVERRUN
	   (MAX 0 (- (+ CLIPPED-TO-Y (ABS HEI)) IB)))
	 (CLIPPED-WID
	   (* WID-SIGN (MAX 0 (- (ABS WID) LEFT-OVERRUN RIGHT-OVERRUN))))
	 (CLIPPED-HEI
	   (* HEI-SIGN (MAX 0 (- (ABS HEI) TOP-OVERRUN BOTTOM-OVERRUN)))))

    (AND (NOT (ZEROP CLIPPED-WID))				;bitblt errs when w=h=0
	 (NOT (ZEROP CLIPPED-HEI))				;and dims are out of bounds
	 (PREPARE-SHEET (SELF)
	   (BITBLT ALU
		   CLIPPED-WID CLIPPED-HEI
		   FROM-ARRAY (+ FROM-X LEFT-OVERRUN) (+ FROM-Y TOP-OVERRUN)
		   SCREEN-ARRAY CLIPPED-TO-X CLIPPED-TO-Y)))))

(DEFMETHOD (SHEET :BITBLT-FROM-SHEET) (ALU WID HEI FROM-X FROM-Y TO-ARRAY TO-X TO-Y
					      &AUX (IL (SHEET-INSIDE-LEFT))
					           (IR (SHEET-INSIDE-RIGHT))
						   (IT (SHEET-INSIDE-TOP))
						   (IB (SHEET-INSIDE-BOTTOM)))
  (SETQ FROM-X (+ IL FROM-X) FROM-Y (+ IT FROM-Y))
  (LET* ((CLIPPED-FROM-X				
	   (MIN (MAX IL FROM-X) IR))
	 (CLIPPED-FROM-Y
	   (MIN (MAX IT FROM-Y) IB))
	 (WID-SIGN (IF (MINUSP WID) -1 1))
	 (HEI-SIGN (IF (MINUSP HEI) -1 1))
	 (LEFT-OVERRUN
	   (- CLIPPED-FROM-X FROM-X))
	 (RIGHT-OVERRUN
	   (MAX 0 (- (+ CLIPPED-FROM-X (ABS WID)) IR)))
	 (TOP-OVERRUN
	   (- CLIPPED-FROM-Y FROM-Y))
	 (BOTTOM-OVERRUN
	   (MAX 0 (- (+ CLIPPED-FROM-Y (ABS HEI)) IB)))
	 (CLIPPED-WID
	   (* WID-SIGN (MAX 0 (- (ABS WID) LEFT-OVERRUN RIGHT-OVERRUN))))
	 (CLIPPED-HEI
	   (* HEI-SIGN (MAX 0 (- (ABS HEI) TOP-OVERRUN BOTTOM-OVERRUN)))))

    (AND (NOT (ZEROP CLIPPED-WID))		;bitblt has this weird bug where it
	 (NOT (ZEROP CLIPPED-HEI))		;doesn't check to see if wid and hei are = 0
	 (PREPARE-SHEET (SELF)
	   (BITBLT ALU
		   CLIPPED-WID CLIPPED-HEI
		   SCREEN-ARRAY CLIPPED-FROM-X CLIPPED-FROM-Y
		   TO-ARRAY (+ TO-X LEFT-OVERRUN) (+ TO-Y TOP-OVERRUN))))))

(DEFMETHOD (SHEET :BITBLT-WITHIN-SHEET) (ALU WID HEI FROM-X FROM-Y TO-X TO-Y
						&AUX (IL (SHEET-INSIDE-LEFT))
					             (IR (SHEET-INSIDE-RIGHT))
						     (IT (SHEET-INSIDE-TOP))
						     (IB (SHEET-INSIDE-BOTTOM)))
  (SETQ FROM-X (+ IL FROM-X) FROM-Y (+ IT FROM-Y)
	TO-X (+ IL TO-X) TO-Y (+ IT TO-Y))
  (LET* ((CLIPPED-FROM-X
	   (MIN (MAX IL FROM-X) IR))		
	 (CLIPPED-FROM-Y
	   (MIN (MAX IT FROM-Y)	IB))		
	 (CLIPPED-TO-X
	   (MIN (MAX IL TO-X) IR))		
	 (CLIPPED-TO-Y
	   (MIN (MAX IT TO-Y) IB))         
	 (WID-SIGN (IF (MINUSP WID) -1 1))
	 (HEI-SIGN (IF (MINUSP HEI) -1 1))
	 (LEFT-OVERRUN
	   (MAX 0 (- CLIPPED-FROM-X FROM-X) (- CLIPPED-TO-X TO-X)))
	 (RIGHT-OVERRUN
	   (MAX 0 (- (+ CLIPPED-FROM-X (ABS WID)) IR) (- (+ CLIPPED-TO-X (ABS WID)) IR)))
	 (TOP-OVERRUN
	   (MAX 0 (- CLIPPED-FROM-Y FROM-Y) (- CLIPPED-TO-Y TO-Y)))
	 (BOTTOM-OVERRUN
	   (MAX 0 (- (+ CLIPPED-FROM-Y (ABS HEI)) IB) (- (+ CLIPPED-TO-Y (ABS HEI)) IB)))
	 (CLIPPED-WID
	   (* WID-SIGN (MAX 0 (- (ABS WID) LEFT-OVERRUN RIGHT-OVERRUN))))
	 (CLIPPED-HEI
	   (* HEI-SIGN (MAX 0 (- (ABS HEI) TOP-OVERRUN BOTTOM-OVERRUN)))))

    (AND (NOT (ZEROP CLIPPED-WID))
	 (NOT (ZEROP CLIPPED-HEI))
	 (PREPARE-SHEET (SELF)
	   (BITBLT ALU
		   CLIPPED-WID CLIPPED-HEI
		   SCREEN-ARRAY (+ FROM-X LEFT-OVERRUN) (+ FROM-Y TOP-OVERRUN)
		   SCREEN-ARRAY (+ TO-X LEFT-OVERRUN) (+ TO-Y TOP-OVERRUN))))))

(DEFMETHOD (SHEET :DRAW-CHAR) (FONT CHAR X-BITPOS Y-BITPOS &OPTIONAL (ALU CHAR-ALUF))
  (PREPARE-SHEET (SELF)
    (DRAW-CHAR FONT CHAR
	       (+ X-BITPOS LEFT-MARGIN-SIZE)
	       (+ Y-BITPOS TOP-MARGIN-SIZE)
	       ALU SELF)))

(DEFMETHOD (SHEET :INCREMENT-BITPOS) (DX DY)
  (SHEET-INCREMENT-BITPOS SELF DX DY))

(DEFUN SHEET-INCREMENT-BITPOS (SHEET DX DY &AUX X Y MORE-VPOS)
  "Increment cursor X and cursor Y, keeping within sheet.
Sets exception flags according to new positions"
  (SETF (SHEET-CURSOR-X SHEET)
	(SETQ X (MAX (+ DX (SHEET-CURSOR-X SHEET)) (SHEET-INSIDE-LEFT SHEET))))
  (SETF (SHEET-CURSOR-Y SHEET)
	(SETQ Y (MAX (+ DY (SHEET-CURSOR-Y SHEET)) (SHEET-INSIDE-TOP SHEET))))
  (AND (> (+ Y (SHEET-LINE-HEIGHT SHEET)) (SHEET-INSIDE-BOTTOM SHEET))
       (SETF (SHEET-END-PAGE-FLAG SHEET) 1))
  (AND (SETQ MORE-VPOS (SHEET-MORE-VPOS SHEET))
       ( Y MORE-VPOS)
       (SETF (SHEET-MORE-FLAG SHEET) 1))
  NIL)

(DEFUN SHEET-SET-FONT (SHEET FONT)
  "Set the current font of SHEET to FONT.
The current font is what ordinary output is printed in.
FONT may be a font object, a name of one, a name of a name, etc."
  (FUNCALL SHEET ':SET-CURRENT-FONT FONT T))

(DEFMETHOD (SHEET :SIZE-IN-CHARACTERS) ()
  (VALUES (TRUNCATE (SHEET-INSIDE-WIDTH) CHAR-WIDTH) (SHEET-NUMBER-OF-INSIDE-LINES)))

(DEFMETHOD (SHEET :SET-SIZE-IN-CHARACTERS) (WIDTH-IN-CHARS HEIGHT-IN-CHARS
							   &OPTIONAL OPTION)
   (FUNCALL-SELF ':SET-SIZE
		 (DECODE-CHARACTER-WIDTH-SPEC WIDTH-IN-CHARS)
		 (DECODE-CHARACTER-HEIGHT-SPEC HEIGHT-IN-CHARS)
		 OPTION))

(DEFMETHOD (SHEET :SET-CURSORPOS) (X Y &OPTIONAL (UNIT ':PIXEL))
  (SELECTQ UNIT
    (:PIXEL)
    (:CHARACTER
      (AND X (SETQ X (* X CHAR-WIDTH)))
      (AND Y (SETQ Y (* Y LINE-HEIGHT))))
    (OTHERWISE
      (FERROR NIL "~S is not a known unit." UNIT)))
  (SHEET-SET-CURSORPOS SELF X Y))

(DEFUN SHEET-SET-CURSORPOS (SHEET X Y)
  "Set 'cursor' position of SHEET in terms of raster units.
The cursor is where ordinary output will appear
/(the top left corner of the next character).
Cursorposes are relative to the left and top margins.
The arguments are `clipped' to stay inside the sheet's margins."
  (DO ((INHIBIT-SCHEDULING-FLAG T T)  ;Keep trying until we get the lock
       (LOCK) (BL))
      ((AND (SETQ LOCK (SHEET-CAN-GET-LOCK SHEET))
	    (NOT (SHEET-OUTPUT-HELD-P SHEET)))
       (SETQ X (IF X (MIN (+ (MAX (FIX X) 0) (SHEET-INSIDE-LEFT SHEET))
			  (SHEET-INSIDE-RIGHT SHEET))
		   (SHEET-CURSOR-X SHEET)))
       (SETQ Y (IF Y (MIN (+ (MAX (FIX Y) 0) (SHEET-INSIDE-TOP SHEET))
			  (SHEET-INSIDE-BOTTOM SHEET))
		   (SHEET-CURSOR-Y SHEET)))
       (AND (= (SHEET-CURSOR-X SHEET) X) (= (SHEET-CURSOR-Y SHEET) Y)
	    (RETURN NIL))			;Not moving, don't open the blinker
       (AND (SETQ BL (SHEET-FOLLOWING-BLINKER SHEET))
	    (OPEN-BLINKER BL))
       (AND (SHEET-MORE-VPOS SHEET)		;If more processing enabled, delay until
						; bottom of sheet
	    (SETF (SHEET-MORE-VPOS SHEET) (SHEET-DEDUCE-MORE-VPOS SHEET)))
       (SETF (SHEET-CURSOR-X SHEET) X)
       (SETF (SHEET-CURSOR-Y SHEET) Y)
       (SETF (SHEET-EXCEPTIONS SHEET) 0)
       (AND (> (+ Y (SHEET-LINE-HEIGHT SHEET)) (SHEET-INSIDE-BOTTOM SHEET))
	    (SETF (SHEET-END-PAGE-FLAG SHEET) 1))
       T)
    (SETQ INHIBIT-SCHEDULING-FLAG NIL)
    (IF LOCK
	(FUNCALL SHEET ':OUTPUT-HOLD-EXCEPTION)
	(PROCESS-WAIT "Window Lock" #'SHEET-CAN-GET-LOCK SHEET))))

(DEFMETHOD (SHEET :INCREMENT-CURSORPOS) (DX DY &OPTIONAL (UNIT ':PIXEL))
  (SELECTQ UNIT
    (:PIXEL)
    (:CHARACTER
     (AND DX (SETQ DX (- (* CHAR-WIDTH DX)
			 (NTH-VALUE 1 (CEILING (- CURSOR-X LEFT-MARGIN-SIZE) CHAR-WIDTH)))))
     (AND DY (SETQ DY (- (* LINE-HEIGHT DY)
			 (NTH-VALUE 1 (CEILING (- CURSOR-Y TOP-MARGIN-SIZE) LINE-HEIGHT))))))
    (OTHERWISE
      (FERROR NIL "~S is not a known unit." UNIT)))
  (PREPARE-SHEET (SELF)
    (OR (ZEROP (SHEET-EXCEPTIONS)) (SHEET-HANDLE-EXCEPTIONS SELF))
    (SHEET-INCREMENT-BITPOS SELF DX DY)))

(DEFMETHOD (SHEET :READ-CURSORPOS) (&OPTIONAL (UNIT ':PIXEL))
  (SELECTQ UNIT
    (:PIXEL
     (VALUES (- CURSOR-X LEFT-MARGIN-SIZE)
	     (- CURSOR-Y TOP-MARGIN-SIZE)))
    (:CHARACTER
     (VALUES (CEILING (- CURSOR-X LEFT-MARGIN-SIZE) CHAR-WIDTH)
	     (CEILING (- CURSOR-Y TOP-MARGIN-SIZE) LINE-HEIGHT)))
    (OTHERWISE
     (FERROR NIL "~S is not a known unit." UNIT))))

(DEFUN SHEET-READ-CURSORPOS (SHEET)
  "Return the cursor position in raster units relative to margins"
  (DECLARE (RETURN-LIST CURSOR-X CURSOR-Y))
  (VALUES (- (SHEET-CURSOR-X SHEET) (SHEET-INSIDE-LEFT SHEET))
	  (- (SHEET-CURSOR-Y SHEET) (SHEET-INSIDE-TOP SHEET))))

(DEFMETHOD (SHEET :HOME-CURSOR) ()
  (SHEET-HOME SELF))

(DEFUN SHEET-HOME (SHEET)
  "Position SHEET's cursor to upper left corner (inside the margins)."
  (PREPARE-SHEET (SHEET)
    (AND (SHEET-MORE-VPOS SHEET)		;If MORE processing, put it off 'til last line
	 (SETF (SHEET-MORE-VPOS SHEET) (SHEET-DEDUCE-MORE-VPOS SHEET)))
    (SETF (SHEET-CURSOR-X SHEET) (SHEET-INSIDE-LEFT SHEET))
    (SETF (SHEET-CURSOR-Y SHEET) (SHEET-INSIDE-TOP SHEET))
    (SETF (SHEET-EXCEPTIONS SHEET) 0)))

(DEFMETHOD (SHEET :HOME-DOWN) ()
  (SHEET-SET-CURSORPOS SELF 0
		       (* (TRUNCATE (- (SHEET-INSIDE-HEIGHT) LINE-HEIGHT)
				     LINE-HEIGHT)
				 LINE-HEIGHT))
  (AND MORE-VPOS (SETQ MORE-VPOS (LOGIOR 100000 MORE-VPOS)))) ;Delay until next time

(DEFMETHOD (SHEET :TERPRI) ()
  (SHEET-CRLF SELF))

(DEFUN SHEET-CRLF (SHEET)
  "Move SHEET's cursor to beginning of next line, and clear the line."
  (PREPARE-SHEET (SHEET)
    (OR (ZEROP (SHEET-EXCEPTIONS SHEET))	;Handle exceptions first
	(SHEET-HANDLE-EXCEPTIONS SHEET))
    (SETF (SHEET-CURSOR-X SHEET) (SHEET-INSIDE-LEFT SHEET))
    (SHEET-INCREMENT-BITPOS SHEET 0 (SHEET-LINE-HEIGHT SHEET))
    (SHEET-CLEAR-EOL SHEET)))

(DEFMETHOD (SHEET :LINE-OUT) (STRING &OPTIONAL (START 0) END)
  (FUNCALL-SELF ':STRING-OUT STRING START END)
  (FUNCALL-SELF ':TERPRI))

(DEFMETHOD (SHEET :FRESH-LINE) ()
  (IF (= CURSOR-X (SHEET-INSIDE-LEFT))
      (PROGN (SHEET-CLEAR-EOL SELF) NIL)
    (SHEET-CRLF SELF)
    T))

(DEFMETHOD (SHEET :CLEAR-CHAR) (&OPTIONAL CHAR)
  (SHEET-CLEAR-CHAR SELF CHAR))

(DEFUN SHEET-CLEAR-CHAR (SHEET &OPTIONAL CHAR)
  "Clear the character position SHEET's cursor points at.
CHAR may be a character whose width controls how wide an area to clear."
  (PREPARE-SHEET (SHEET)
    (OR (ZEROP (SHEET-EXCEPTIONS SHEET))
	(SHEET-HANDLE-EXCEPTIONS SHEET))
    (%DRAW-RECTANGLE (IF CHAR (SHEET-CHARACTER-WIDTH SHEET CHAR
						     (SHEET-CURRENT-FONT SHEET))
			      (SHEET-CHAR-WIDTH SHEET))
		     (SHEET-LINE-HEIGHT SHEET)
		     (SHEET-CURSOR-X SHEET) (SHEET-CURSOR-Y SHEET)
		     (SHEET-ERASE-ALUF SHEET) SHEET)))

(DEFMETHOD (SHEET :CLEAR-EOL) ()
  (SHEET-CLEAR-EOL SELF))

(DEFMETHOD (SHEET :CLEAR-REST-OF-WINDOW) ()
  (SHEET-CLEAR-EOL SELF))

(DEFUN SHEET-CLEAR-EOL (SHEET)
  "Clear from SHEET's cursor to the right margin."
  (PREPARE-SHEET (SHEET)
    ;; Note that this need not handle **MORE** exception, because the **more**
    ;; would bash the line this is clearing anyway.  We don't want to **more**
    ;; if the next operation is going to be tyi.
    (OR (ZEROP (SHEET-END-PAGE-FLAG SHEET))
	(SHEET-HANDLE-EXCEPTIONS SHEET))
    (%DRAW-RECTANGLE (MAX (- (SHEET-INSIDE-RIGHT SHEET) (SHEET-CURSOR-X SHEET))
			  0)
		     (MIN (- (SHEET-INSIDE-BOTTOM SHEET) (SHEET-CURSOR-Y SHEET))
			  (SHEET-LINE-HEIGHT SHEET))
		     (SHEET-CURSOR-X SHEET) (SHEET-CURSOR-Y SHEET)
		     (SHEET-ERASE-ALUF SHEET) SHEET)))

(DEFMETHOD (SHEET :CLEAR-STRING) (STRING &OPTIONAL START END)
  (SHEET-CLEAR-STRING SELF STRING START END))

(DEFUN SHEET-CLEAR-STRING (SHEET STRING &OPTIONAL START END)
  "Clear enough space after SHEET's cursor to hold STRING, or part of it.
If STRING contains Return characters, we clear space on each line
to hold the characters of STRING on that line."
  (PREPARE-SHEET (SHEET)
    (OR (ZEROP (SHEET-EXCEPTIONS SHEET))
	(SHEET-HANDLE-EXCEPTIONS SHEET))
    (DO ((LINE-START (OR START 0))
	 (WHOLE-END (OR END (LENGTH STRING)))
	 (PSEUDO-CURSOR-X (SHEET-CURSOR-X SHEET)
			  (SHEET-INSIDE-LEFT SHEET))
	 (PSEUDO-CURSOR-Y (SHEET-CURSOR-Y SHEET)
			  (+ PSEUDO-CURSOR-Y LINE-HEIGHT))
	 MAXIMUM-X FINAL-INDEX
	 (LINE-HEIGHT (SHEET-LINE-HEIGHT SHEET))
	 (LINE-END))
	(())
      ;; Do vertical wrap around at bottom of sheet.
      (IF (>= (+ PSEUDO-CURSOR-Y LINE-HEIGHT) (SHEET-INSIDE-BOTTOM SHEET))
	  (SETQ PSEUDO-CURSOR-Y (SHEET-INSIDE-TOP SHEET)))
      ;; Find end of this line of the string.
      (SETQ LINE-END (OR (STRING-SEARCH-CHAR #\RETURN STRING LINE-START WHOLE-END)
			 WHOLE-END))
      ;; Does it fit in one screen-line?  If not, how much does?
      (MULTIPLE-VALUE (NIL FINAL-INDEX MAXIMUM-X)
	(SHEET-STRING-LENGTH SHEET STRING LINE-START LINE-END
			     (SHEET-INSIDE-RIGHT SHEET)
			     (SHEET-CURRENT-FONT SHEET)
			     PSEUDO-CURSOR-X))
      ;; We only handle what fits in this screen-line.
      (IF (= FINAL-INDEX LINE-END)
	  (SETQ LINE-START (1+ LINE-END))
	(SETQ LINE-START FINAL-INDEX
	      MAXIMUM-X (SHEET-INSIDE-RIGHT SHEET)))
      ;; Clear that much.
      (%DRAW-RECTANGLE (- MAXIMUM-X PSEUDO-CURSOR-X)
		       LINE-HEIGHT
		       PSEUDO-CURSOR-X PSEUDO-CURSOR-Y
		       (SHEET-ERASE-ALUF SHEET) SHEET)
      ;; If entire specified portion of string is done, exit.
      (IF (>= LINE-START WHOLE-END) (RETURN NIL)))))

(DEFMETHOD (SHEET :CLEAR-BETWEEN-CURSORPOSES) (START-X START-Y END-X END-Y)
  (SHEET-CLEAR-BETWEEN-CURSORPOSES SELF START-X START-Y END-X END-Y))

(DEFUN SHEET-CLEAR-BETWEEN-CURSORPOSES (SHEET START-X START-Y END-X END-Y
					&AUX (ALUF (SHEET-ERASE-ALUF SHEET)) MID-Y)
  "Erase on SHEET from START-X, START-Y to END-X, END-Y.
All positions are relative to SHEET's margins.
Does nothing if start is after end on the same line,
but if on different lines, assumes screen wrap-around"
  (SETQ START-X (MIN (+ START-X (SHEET-INSIDE-LEFT SHEET)) (SHEET-INSIDE-RIGHT SHEET))
	START-Y (MIN (+ START-Y (SHEET-INSIDE-TOP SHEET)) (SHEET-INSIDE-BOTTOM SHEET))
	END-X (MIN (+ END-X (SHEET-INSIDE-LEFT SHEET)) (SHEET-INSIDE-RIGHT SHEET))
	END-Y (MIN (+ END-Y (SHEET-INSIDE-TOP SHEET)) (SHEET-INSIDE-BOTTOM SHEET)))
  (PREPARE-SHEET (SHEET)
    (COND ((= START-Y END-Y)
	   (COND ((< START-X END-X)
		  (%DRAW-RECTANGLE (- END-X START-X)
				   (MIN (- (SHEET-INSIDE-BOTTOM SHEET) START-Y)
					(SHEET-LINE-HEIGHT SHEET))
				   START-X START-Y ALUF SHEET))))
	  (T (%DRAW-RECTANGLE (- (SHEET-INSIDE-RIGHT SHEET) START-X) 
			      (MIN (- (SHEET-INSIDE-BOTTOM SHEET) START-Y)
				   (SHEET-LINE-HEIGHT SHEET))
			      START-X START-Y ALUF SHEET)
	     (SETQ MID-Y (+ START-Y (SHEET-LINE-HEIGHT SHEET)))
	     (%DRAW-RECTANGLE END-X (MIN (- (SHEET-INSIDE-BOTTOM SHEET) END-Y)
					 (SHEET-LINE-HEIGHT SHEET))
			      (SHEET-INSIDE-LEFT SHEET) END-Y ALUF SHEET)
	     (IF (< START-Y END-Y)
		 (AND (< MID-Y END-Y)
		      (%DRAW-RECTANGLE (SHEET-INSIDE-WIDTH SHEET) (- END-Y MID-Y)
				       (SHEET-INSIDE-LEFT SHEET) MID-Y ALUF SHEET))
		 (%DRAW-RECTANGLE (SHEET-INSIDE-WIDTH SHEET)
				  (- (SHEET-INSIDE-BOTTOM SHEET) MID-Y)
				  (SHEET-INSIDE-LEFT SHEET) MID-Y ALUF SHEET)
		 (%DRAW-RECTANGLE (SHEET-INSIDE-WIDTH SHEET)
				  (- END-Y (SHEET-INSIDE-TOP SHEET))
				  (SHEET-INSIDE-LEFT SHEET) (SHEET-INSIDE-TOP SHEET)
				  ALUF SHEET))))))

(DEFMETHOD (SHEET :CLEAR-SCREEN) ()
  (SHEET-CLEAR SELF))

(DEFMETHOD (SHEET :CLEAR-WINDOW) ()
  (SHEET-CLEAR SELF))

(DEFUN SHEET-CLEAR (SHEET &OPTIONAL (MARGINS-P NIL))
  "Erase all of SHEET.  If MARGINS-P, erase its margins too."
  (PREPARE-SHEET (SHEET)
    (SHEET-HOME SHEET)				;Handles any exceptions
    (IF MARGINS-P
	(%DRAW-RECTANGLE (SHEET-WIDTH SHEET) (SHEET-HEIGHT SHEET)
			 0 0
			 (SHEET-ERASE-ALUF SHEET) SHEET)
	(%DRAW-RECTANGLE (SHEET-INSIDE-WIDTH SHEET) (SHEET-INSIDE-HEIGHT SHEET)
			 (SHEET-INSIDE-LEFT SHEET) (SHEET-INSIDE-TOP SHEET)
			 (SHEET-ERASE-ALUF SHEET) SHEET))
    (SCREEN-MANAGE-FLUSH-KNOWLEDGE SHEET)))

(DEFMETHOD (SHEET :CLEAR-REST-OF-WINDOW) ()
  (SHEET-CLEAR-EOF SELF))

(DEFMETHOD (SHEET :CLEAR-EOF) ()
  (SHEET-CLEAR-EOF SELF))

(DEFUN SHEET-CLEAR-EOF (SHEET &AUX HT TEM)
  "Clear from SHEET's cursor to right margin, and all area below."
  (PREPARE-SHEET (SHEET)
    (OR (ZEROP (SHEET-EXCEPTIONS SHEET))
	(SHEET-HANDLE-EXCEPTIONS SHEET))
    (SHEET-CLEAR-EOL SHEET)
    (AND (PLUSP (SETQ HT (- (SHEET-INSIDE-BOTTOM SHEET)
			    (SETQ TEM (+ (SHEET-CURSOR-Y SHEET) (SHEET-LINE-HEIGHT SHEET))))))
	 (%DRAW-RECTANGLE (SHEET-INSIDE-WIDTH SHEET) HT
			  (SHEET-INSIDE-LEFT SHEET) TEM
			  (SHEET-ERASE-ALUF SHEET) SHEET))))

(DEFMETHOD (SHEET :INSERT-LINE) (&OPTIONAL (LINE-COUNT 1) (UNIT ':CHARACTER))
  (SHEET-INSERT-LINE SELF LINE-COUNT UNIT))

(DEFUN SHEET-INSERT-LINE (SHEET &OPTIONAL (LINE-COUNT 1) (UNIT ':CHARACTER))
  "Make room for some line before the line the cursor is currently on.
The data on this line and below is moved downward on the screen,
and that near the bottom of SHEET is discarded.
LINE-COUNT is how many lines to insert; default 1.
UNIT is :CHARACTER (the default) or :PIXEL, and says what unit
LINE-COUNT is expressed in.  :CHARACTER means it is multiplied
by the window's line-height."
  (PREPARE-SHEET (SHEET)
    (LET ((ARRAY (SHEET-SCREEN-ARRAY SHEET))
	  (WIDTH (SHEET-INSIDE-WIDTH SHEET))
	  (LINE-HEIGHT (SHEET-LINE-HEIGHT SHEET))
	  HEIGHT
	  DELTA-HEIGHT)
      (SETQ HEIGHT (IF (EQ UNIT ':CHARACTER) (* LINE-COUNT LINE-HEIGHT) LINE-COUNT))
      ;; Compute minus height of block to BLT
      (SETQ DELTA-HEIGHT
	    (- HEIGHT (- (* LINE-HEIGHT (SHEET-NUMBER-OF-INSIDE-LINES SHEET))
			 (- (SHEET-CURSOR-Y SHEET) (SHEET-INSIDE-TOP SHEET)))))
      (OR ( DELTA-HEIGHT 0)			;If some bits to move, move them
	  (BITBLT ALU-SETA
		  WIDTH DELTA-HEIGHT
		  ARRAY (SHEET-INSIDE-LEFT SHEET) (SHEET-CURSOR-Y SHEET)
		  ARRAY (SHEET-INSIDE-LEFT SHEET) (+ (SHEET-CURSOR-Y SHEET) HEIGHT)))
      (%DRAW-RECTANGLE WIDTH HEIGHT
		       (SHEET-INSIDE-LEFT SHEET) (SHEET-CURSOR-Y SHEET)
		       (SHEET-ERASE-ALUF SHEET) SHEET))))

(DEFMETHOD (SHEET :DELETE-LINE) (&OPTIONAL (LINE-COUNT 1) (UNIT ':CHARACTER))
  (SHEET-DELETE-LINE SELF LINE-COUNT UNIT))

(DEFUN SHEET-DELETE-LINE (SHEET &OPTIONAL (LINE-COUNT 1) (UNIT ':CHARACTER))
  "Discard one or more lines starting at the cursor vpos, moving data below up.
Blank lines appear at the bottom of SHEET.
LINE-COUNT is how many lines to delete; default 1.
UNIT is :CHARACTER (the default) or :PIXEL, and says what unit
LINE-COUNT is expressed in.  :CHARACTER means it is multiplied
by the window's line-height."
  (PREPARE-SHEET (SHEET)
    (LET ((ARRAY (SHEET-SCREEN-ARRAY SHEET))
	  (WIDTH (SHEET-INSIDE-WIDTH SHEET))
	  (LINE-HEIGHT (SHEET-LINE-HEIGHT SHEET))
	  HEIGHT
	  DELTA-HEIGHT)
      (SETQ HEIGHT (IF (EQ UNIT ':CHARACTER) (* LINE-COUNT LINE-HEIGHT) LINE-COUNT))
      (AND (PLUSP (SETQ DELTA-HEIGHT
			(- (+ (- (SHEET-CURSOR-Y SHEET) (SHEET-INSIDE-TOP SHEET)) HEIGHT)
			   (* LINE-HEIGHT (SHEET-NUMBER-OF-INSIDE-LINES SHEET)))))
	   (FERROR NIL "Illegal line-count ~S for ~S" LINE-COUNT SHEET))
      (BITBLT ALU-SETA WIDTH (- DELTA-HEIGHT)
	      ARRAY (SHEET-INSIDE-LEFT SHEET) (+ (SHEET-CURSOR-Y SHEET) HEIGHT)
	      ARRAY (SHEET-INSIDE-LEFT SHEET) (SHEET-CURSOR-Y SHEET))
      (%DRAW-RECTANGLE WIDTH HEIGHT
		       (SHEET-INSIDE-LEFT SHEET) (- (SHEET-CURSOR-Y SHEET) DELTA-HEIGHT)
		       (SHEET-ERASE-ALUF SHEET) SHEET))))

(DEFMETHOD (SHEET :INSERT-CHAR) (&OPTIONAL (-WIDTH- 1) (UNIT ':CHARACTER))
  (SHEET-INSERT-CHAR SELF -WIDTH- UNIT))

(DEFUN SHEET-INSERT-CHAR (SHEET &OPTIONAL (WIDTH 1) (UNIT ':CHARACTER))
  "Make room for characters at SHEET's cursor, moving rest of line right.
The last part of the line is discarded.  The cursorpos does not change.
If UNIT is :CHARACTER, WIDTH is a number of characters.
This is accurate only for fixed-width fonts.
Alternatively, WIDTH may be a number of pixels
if UNIT is :PIXEL."
  (PREPARE-SHEET (SHEET)
    (LET ((ARRAY (SHEET-SCREEN-ARRAY SHEET))
	  (LINE-HEIGHT (SHEET-LINE-HEIGHT SHEET))
	  (WIDTH (IF (EQ UNIT ':PIXEL) WIDTH
		     (* WIDTH (SHEET-CHAR-WIDTH SHEET)))))
      (BITBLT ALU-SETA
	      (- WIDTH (- (SHEET-INSIDE-RIGHT SHEET) (SHEET-CURSOR-X SHEET)))
	      LINE-HEIGHT
	      ARRAY (SHEET-CURSOR-X SHEET) (SHEET-CURSOR-Y SHEET)
	      ARRAY (+ (SHEET-CURSOR-X SHEET) WIDTH) (SHEET-CURSOR-Y SHEET))
      (%DRAW-RECTANGLE WIDTH LINE-HEIGHT
		       (SHEET-CURSOR-X SHEET) (SHEET-CURSOR-Y SHEET)
		       (SHEET-ERASE-ALUF SHEET) SHEET))))

(DEFMETHOD (SHEET :DELETE-CHAR) (&OPTIONAL (-WIDTH- 1) (UNIT ':CHARACTER))
  (SHEET-DELETE-CHAR SELF -WIDTH- UNIT))

(DEFUN SHEET-DELETE-CHAR (SHEET &OPTIONAL (WIDTH 1) (UNIT ':CHARACTER))
  "Discard characters after SHEET's cursor, moving rest of line left.
Blank space is created near the right margin.
The cursor position does not change.
If UNIT is :CHARACTER, WIDTH is a number of characters.
This is accurate only for fixed-width fonts.
Alternatively, WIDTH may be a number of pixels
if UNIT is :PIXEL."
  (PREPARE-SHEET (SHEET)
    (LET ((ARRAY (SHEET-SCREEN-ARRAY SHEET))
	  (LINE-HEIGHT (SHEET-LINE-HEIGHT SHEET))
	  (WIDTH (IF (EQ UNIT ':PIXEL) WIDTH
		     (* WIDTH (SHEET-CHAR-WIDTH SHEET)))))
      (BITBLT ALU-SETA
	      (- (SHEET-INSIDE-RIGHT SHEET) (SHEET-CURSOR-X SHEET) WIDTH)
	      LINE-HEIGHT
	      ARRAY (+ (SHEET-CURSOR-X SHEET) WIDTH) (SHEET-CURSOR-Y SHEET)
	      ARRAY (SHEET-CURSOR-X SHEET) (SHEET-CURSOR-Y SHEET))
      (%DRAW-RECTANGLE WIDTH LINE-HEIGHT
		       (- (SHEET-INSIDE-RIGHT SHEET) WIDTH)
		       (SHEET-CURSOR-Y SHEET)
		       (SHEET-ERASE-ALUF SHEET) SHEET))))

(DEFMETHOD (SHEET :INSERT-STRING) (STRING &OPTIONAL (START 0) END (TYPE-TOO T))
  (SHEET-INSERT-STRING SELF STRING START END TYPE-TOO))

(DEFUN SHEET-INSERT-STRING (SHEET STRING &OPTIONAL (START 0) END (TYPE-TOO T) &AUX LEN)
  "Make room for STRING after SHEET's cursor, moving rest of line right.
The last part of the line is discarded.  The cursorpos does not change.
If TYPE-TOO is non-NIL, STRING is output into the space
and the cursor is left after it."
  (SETQ LEN (IF (NUMBERP STRING)
		(SHEET-CHARACTER-WIDTH SHEET STRING (SHEET-CURRENT-FONT SHEET))
		(SHEET-STRING-LENGTH SHEET STRING START END)))
  (SHEET-INSERT-CHAR SHEET LEN ':PIXEL)
  (AND TYPE-TOO (SHEET-STRING-OUT SHEET STRING START END)))

(DEFMETHOD (SHEET :DELETE-STRING) (STRING &OPTIONAL (START 0) END)
  (SHEET-DELETE-STRING SELF STRING START END))

(DEFUN SHEET-DELETE-STRING (SHEET STRING &OPTIONAL (START 0) END &AUX LEN)
  "Delete enough space for STRING, after SHEET's cursor.
The following part of the line moves left, creating blank space at the end.
The cursor position does not change."
  (SETQ LEN (IF (NUMBERP STRING)
		(SHEET-CHARACTER-WIDTH SHEET STRING (SHEET-CURRENT-FONT SHEET))
		(SHEET-STRING-LENGTH SHEET STRING START END)))
  (SHEET-DELETE-CHAR SHEET LEN ':PIXEL))

(DEFMETHOD (SHEET :DISPLAY-LOZENGED-STRING) (STRING)
  (SHEET-DISPLAY-LOZENGED-STRING SELF STRING))

(DEFUN SHEET-DISPLAY-LOZENGED-STRING (SHEET STRING)
  "Display STRING on SHEET inside a lozenge.
This is how special characters with no graphic or formatting meaning are output."
  (SETQ STRING (STRING STRING))
  (LET ((WIDTH (LOZENGED-STRING-WIDTH STRING)))
    ;; Make sure there is enough room on the line, if not CRLF and
    ;; hope the sheet isn't too narrow.  Relies on the fact that handling
    ;; of all exceptions leaves you no further to the right than you were
    ;; (usually at the left margin).
    (PREPARE-SHEET (SHEET)
      (OR (ZEROP (SHEET-EXCEPTIONS SHEET))
	  (SHEET-HANDLE-EXCEPTIONS SHEET))
      (COND ((> (+ (SHEET-CURSOR-X SHEET) WIDTH)
		(IF (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG SHEET))
		    (SHEET-INSIDE-RIGHT SHEET)
		    (- (SHEET-INSIDE-RIGHT SHEET) (SHEET-CHAR-WIDTH SHEET))))
	     (FUNCALL SHEET ':END-OF-LINE-EXCEPTION)))
      (SETF (SHEET-CURSOR-X SHEET)
	    (SHEET-DISPLAY-LOZENGED-STRING-INTERNAL SHEET STRING
			(SHEET-CURSOR-X SHEET) (1+ (SHEET-CURSOR-Y SHEET))
			(SHEET-INSIDE-RIGHT SHEET) (SHEET-CHAR-ALUF SHEET))))))

(DEFUN LOZENGED-STRING-WIDTH (STRING)
  (+ 9. (* 6 (STRING-LENGTH STRING))))

(DEFUN SHEET-DISPLAY-LOZENGED-STRING-INTERNAL (SHEET STRING X0 Y0 XLIM ALUF)
  (LET ((WIDTH (LOZENGED-STRING-WIDTH STRING)))
    ;; Put the string then the box around it
    (LET ((X1 (1- (MIN (+ X0 WIDTH) XLIM)))
	  (Y1 (+ Y0 8)))
      (SHEET-STRING-OUT-EXPLICIT-1 SHEET STRING (+ X0 4) (+ Y0 2) NIL
				   X1
				   (FUNCALL (SHEET-GET-SCREEN SHEET)
					    ':PARSE-FONT-DESCRIPTOR FONTS:5X5)
				   ALUF)
      (%DRAW-RECTANGLE (- WIDTH 8) 1 (+ X0 4) Y0 ALUF SHEET)
      (%DRAW-RECTANGLE (- WIDTH 8) 1 (+ X0 4) Y1 ALUF SHEET)
      (%DRAW-LINE X0 (+ Y0 4) (+ X0 3) (1+ Y0) ALUF T SHEET)
      (%DRAW-LINE (1+ X0) (+ Y0 5) (+ X0 3) (1- Y1) ALUF T SHEET)
      (%DRAW-LINE X1 (+ Y0 4) (- X1 3) (1+ Y0) ALUF T SHEET)
      (%DRAW-LINE (1- X1) (+ Y0 5) (- X1 3) (1- Y1) ALUF T SHEET)
      (1+ X1))))

(DEFMETHOD (SHEET :TYO) (CH &OPTIONAL FONT)
  (SHEET-TYO SELF CH FONT))

(DEFUN SHEET-TYO (SHEET CHAR &OPTIONAL FONT &AUX BASE-ADJ)
  "Output printing or formatting character CHAR on SHEET in FONT.
FONT defaults to the current font of SHEET.
Weird characters are printed in lozenges."
  (CHECK-ARG CHAR (AND (OR (TYPEP CHAR ':CHARACTER) (FIXP CHAR))
		       ( CHAR 0) (< CHAR 400))
	     "a character")
  (IF ( CHAR 200)
      (COND ((AND (= CHAR #\CR) (ZEROP (SHEET-CR-NOT-NEWLINE-FLAG SHEET)))
             (SHEET-CRLF SHEET))
            ((= CHAR #\TAB)
             (SHEET-TAB-1 SHEET))
            ((AND (= CHAR #\BS) (ZEROP (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG SHEET)))
             (SHEET-BACKSPACE-1 SHEET))
            (T
	     (SHEET-DISPLAY-LOZENGED-STRING SHEET
		(STRING (OR (CAR (RASSOC CHAR SI:XR-SPECIAL-CHARACTER-NAMES))
			    (FORMAT NIL "~O" CHAR))))))
      (PREPARE-SHEET (SHEET)
        (OR (ZEROP (SHEET-EXCEPTIONS SHEET))
	    (SHEET-HANDLE-EXCEPTIONS SHEET))
	(IF FONT
	    (PROGN
	      (COERCE-FONT FONT SHEET)
	      (SETQ BASE-ADJ (- (SHEET-BASELINE SHEET) (FONT-BASELINE FONT))))
	    (SETQ FONT (SHEET-CURRENT-FONT SHEET)
		  BASE-ADJ (SHEET-BASELINE-ADJ SHEET)))
        (LET* ((CHAR-WIDTHS (FONT-CHAR-WIDTH-TABLE FONT))
	       (FIT (FONT-INDEXING-TABLE FONT))
	       (WIDTH)
	       (KERN 0)
	       (KERN-TABLE)
	       (XPOS (SHEET-CURSOR-X SHEET))
	       (RIGHT-LIM (SHEET-INSIDE-RIGHT SHEET)))
	  (OR (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG SHEET))
	      (SETQ RIGHT-LIM (- RIGHT-LIM (SHEET-CHAR-WIDTH SHEET))))
	  (SETQ WIDTH (IF CHAR-WIDTHS
			  (AREF CHAR-WIDTHS CHAR)
			  (FONT-CHAR-WIDTH FONT)))
	  (COND ((> (+ XPOS WIDTH) RIGHT-LIM)
		 (FUNCALL SHEET ':END-OF-LINE-EXCEPTION)
		 (SHEET-TYO SHEET CHAR FONT))
		(T
		 (AND (SETQ KERN-TABLE (FONT-LEFT-KERN-TABLE FONT))
		      (SETQ KERN (AREF KERN-TABLE CHAR)))
		 (COND ((NULL FIT)
			(%DRAW-CHAR FONT CHAR (- XPOS KERN)
				    (+ (SHEET-CURSOR-Y SHEET) BASE-ADJ)
				    (SHEET-CHAR-ALUF SHEET)
				    SHEET))
		       ;; Wide character, draw several columns
		       (T
			(DRAW-CHAR FONT CHAR (- XPOS KERN)
				   (+ (SHEET-CURSOR-Y SHEET) BASE-ADJ)
				   (SHEET-CHAR-ALUF SHEET)
				   SHEET)))
		 (SETF (SHEET-CURSOR-X SHEET) (+ XPOS WIDTH)))))))
  CHAR)

(DEFMETHOD (SHEET :BACKWARD-CHAR) (&OPTIONAL CHAR)
  (SHEET-BACKSPACE-1 SELF CHAR))

(DEFUN SHEET-BACKSPACE-1 (SHEET &OPTIONAL CHAR)
  (PREPARE-SHEET (SHEET)
    (OR (ZEROP (SHEET-EXCEPTIONS SHEET))
	(SHEET-HANDLE-EXCEPTIONS SHEET))
    (SHEET-INCREMENT-BITPOS SHEET
			    (- (IF CHAR (SHEET-CHARACTER-WIDTH SHEET CHAR
							       (SHEET-CURRENT-FONT SHEET))
					(SHEET-CHAR-WIDTH SHEET)))
			    0)))

(DEFUN SHEET-TAB-1 (SHEET)
  (PREPARE-SHEET (SHEET)
     (OR (ZEROP (SHEET-EXCEPTIONS SHEET)) (SHEET-HANDLE-EXCEPTIONS SHEET))
     (LET ((TAB-WIDTH (SHEET-TAB-WIDTH SHEET)))
       (SHEET-INCREMENT-BITPOS SHEET (- TAB-WIDTH (\ (- (SHEET-CURSOR-X SHEET)
							(SHEET-INSIDE-LEFT SHEET))
						     TAB-WIDTH))
			       0))))

(DEFMETHOD (SHEET :FORWARD-CHAR) (&OPTIONAL CHAR)
  (SHEET-SPACE SELF CHAR))

(DEFUN SHEET-SPACE (SHEET &OPTIONAL CHAR)
  "Move SHEET's cursor forward one character position.
Will move to a new line if necessary.
If CHAR is specified, that character's width is the distance to move."
  (PREPARE-SHEET (SHEET)
    (OR (ZEROP (SHEET-EXCEPTIONS SHEET))
	(SHEET-HANDLE-EXCEPTIONS SHEET))
    (SHEET-INCREMENT-BITPOS SHEET
			    (IF CHAR (SHEET-CHARACTER-WIDTH SHEET CHAR
							    (SHEET-CURRENT-FONT SHEET))
				     (SHEET-CHAR-WIDTH SHEET))
			    0)))

(DEFMETHOD (SHEET :STRING-OUT) (STRING &OPTIONAL (START 0) END)
  (SHEET-STRING-OUT SELF STRING START END))

(DEFUN SHEET-STRING-OUT (SHEET STRING &OPTIONAL (START 0) (END NIL))
  "Output STRING or portion on SHEET."
  (PREPARE-SHEET (SHEET)
    (AND (SYMBOLP STRING)		;Convert symbols to strings for output
	 (SETQ STRING (GET-PNAME STRING)))
    (PROG ((I START)
	   (N (OR END (ARRAY-ACTIVE-LENGTH STRING)))
	   (FONT (SHEET-CURRENT-FONT SHEET))
	   XPOS YPOS XLIM ALUF WIDTH CH FWT LKT)
       TOP
	  (AND ( I N) (RETURN NIL))		        ;No exception if done anyway
	  (AND (NULL (FONT-INDEXING-TABLE FONT))
	       (GO EZ))					;Handle easy case fast
       HD (SHEET-TYO SHEET (LDB %%CH-CHAR (AREF STRING I)))
	  (AND (< (SETQ I (1+ I)) N)
	       (GO TOP))
	  (RETURN NIL)

       EZ (OR (ZEROP (SHEET-EXCEPTIONS SHEET))		;End of page, MORE
	      (SHEET-HANDLE-EXCEPTIONS SHEET))
	  (SETQ XPOS (SHEET-CURSOR-X SHEET)
		YPOS (+ (SHEET-CURSOR-Y SHEET) (SHEET-BASELINE-ADJ SHEET))
	        ALUF (SHEET-CHAR-ALUF SHEET)
		WIDTH (FONT-CHAR-WIDTH FONT)
		XLIM (SHEET-INSIDE-RIGHT SHEET))
	  (OR (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG SHEET))
	      (SETQ XLIM (- XLIM (SHEET-CHAR-WIDTH SHEET))))
	  (AND (OR (FONT-CHAR-WIDTH-TABLE FONT) (FONT-LEFT-KERN-TABLE FONT))
	       (GO VW))					;Variable-width is a little slower
       EZ1						;This is the fast loop
	  (SETQ CH (LDB %%CH-CHAR (AREF STRING I)))
	  (COND ((< CH 200)				;Printing char
		 (COND ((> (+ XPOS WIDTH) XLIM)		;Room for it before right margin?
			(SETF (SHEET-CURSOR-X SHEET) XPOS)
			(FUNCALL SHEET ':END-OF-LINE-EXCEPTION)
			(GO TOP)))
		 (%DRAW-CHAR FONT CH XPOS YPOS ALUF SHEET)
		 (SETQ XPOS (+ XPOS WIDTH))
		 (AND (< (SETQ I (1+ I)) N)
		      (GO EZ1))
		 (SETF (SHEET-CURSOR-X SHEET) XPOS)
		 (RETURN NIL))
		(T					;Format effector
		 (SETF (SHEET-CURSOR-X SHEET) XPOS)
		 (GO HD)))

       VW  (SETQ FWT (FONT-CHAR-WIDTH-TABLE FONT)	;This is the medium speed loop 
		 LKT (FONT-LEFT-KERN-TABLE FONT))
       VW1 (SETQ CH (LDB %%CH-CHAR (AREF STRING I)))
	   (COND ((< CH 200)				;Printing char
		  (AND FWT (SETQ WIDTH (AREF FWT CH)))
		  (COND ((> (+ WIDTH XPOS) XLIM)	;Room before margin?
			 (SETF (SHEET-CURSOR-X SHEET) XPOS)
			 (FUNCALL SHEET ':END-OF-LINE-EXCEPTION)
			 (GO TOP)))
		  (%DRAW-CHAR FONT CH (IF LKT (- XPOS (AREF LKT CH)) XPOS) YPOS ALUF SHEET)
		  (SETQ XPOS (+ XPOS WIDTH))
		  (AND (< (SETQ I (1+ I)) N)
		       (GO VW1))
		  (SETF (SHEET-CURSOR-X SHEET) XPOS)
		  (RETURN NIL))
		 (T					;Format effector
		  (SETF (SHEET-CURSOR-X SHEET) XPOS)
		  (GO HD))))))

(DEFMETHOD (SHEET :FAT-STRING-OUT) (STRING &OPTIONAL (START 0) END)
  (SHEET-FAT-STRING-OUT SELF STRING START END))

(DEFUN SHEET-FAT-STRING-OUT (SHEET STRING &OPTIONAL (START 0) END)
  (DO ((INDEX START)
       (STOP (OR END (STRING-LENGTH STRING)))
       (XPOS))
      (( INDEX STOP))
    (SETF (VALUES INDEX XPOS)
	  (SHEET-LINE-OUT SHEET STRING INDEX END))
    (SETF (SHEET-CURSOR-X SHEET) XPOS)
    (WHEN (> INDEX STOP)
      (SHEET-INCREMENT-BITPOS SELF 0 0)
      (RETURN NIL))
    (SHEET-CRLF SHEET)))

;;; Editor's line redisplay primitive, output STRING from START to END,
;;; first setting position to (SET-XPOS,SET-YPOS) and doing a clear-eol
;;; DWIDTH is a special hack for DIS-LINE redisplay of italic fonts, it means
;;; draw an extra character starting one character back, since the clear-eol
;;; will have erased part of the last character where it sticks out past its width.
;;; (If this can really happen, it's going to mean trouble with the margins, too!)
;;; This function never does more than one line; it stops rather than wrapping around.
;;; If you put a carriage return in the string, above may not be true.
;;; Where this leaves the sheet's actual cursorpos is undefined (somewhere on the line)

;;; This is NOT related to the :LINE-OUT operation!
(DEFUN SHEET-LINE-OUT (SHEET STRING &OPTIONAL (START 0) (END NIL) SET-XPOS SET-YPOS DWIDTH)
  (DECLARE (RETURN-LIST I XPOS));Returns index of next character to do and where cursor got to
 				;Except the first value can be incremented, to show that
				;the line was completed (as if it counted the carriage return)
  (PREPARE-SHEET (SHEET)
    (PROG ((I START)
	   (N (OR END (ARRAY-ACTIVE-LENGTH STRING)))
	   (RIGHT-LIMIT (SHEET-INSIDE-RIGHT SHEET))
	   (MARGIN-FLAG (NOT (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG SHEET))))
	   XPOS YPOS OYPOS ALUF WIDTH FWT LKT CH FONT FONTX TEM BASE-ADJ)
      (AND MARGIN-FLAG (SETQ RIGHT-LIMIT (- RIGHT-LIMIT (SHEET-CHAR-WIDTH SHEET))))
      (COND (SET-XPOS
	     (SETF (SHEET-CURSOR-X SHEET)
		   (SETQ SET-XPOS (MIN (+ SET-XPOS (SHEET-INSIDE-LEFT SHEET))
				       (SHEET-INSIDE-RIGHT SHEET))))))
      (COND (SET-YPOS
	     (AND (SHEET-MORE-VPOS SHEET)
		  (SETF (SHEET-MORE-VPOS SHEET) (SHEET-DEDUCE-MORE-VPOS SHEET)))
	     (SETF (SHEET-CURSOR-Y SHEET)
		   (SETQ SET-YPOS (MIN (+ SET-YPOS (SHEET-INSIDE-TOP SHEET))
				       (SHEET-INSIDE-BOTTOM SHEET))))
	     (SETF (SHEET-EXCEPTIONS SHEET) 0)
	     (AND (> (+ SET-YPOS (SHEET-LINE-HEIGHT SHEET)) (SHEET-INSIDE-BOTTOM SHEET))
		  (SETF (SHEET-END-PAGE-FLAG SHEET) 1))
	     (SETQ OYPOS SET-YPOS))
	    (T (SETQ OYPOS (SHEET-CURSOR-Y SHEET))))

      (OR (ZEROP (SHEET-EXCEPTIONS SHEET)) (SHEET-HANDLE-EXCEPTIONS SHEET))

      ;; If we set the cursor then do a clear to end of line
      (AND (OR SET-XPOS SET-YPOS)
	   (%DRAW-RECTANGLE (- (SHEET-INSIDE-RIGHT SHEET)
			       (SETQ SET-XPOS (OR SET-XPOS (SHEET-CURSOR-X SHEET))))
			    (SHEET-LINE-HEIGHT SHEET)
			    SET-XPOS OYPOS
			    (SHEET-ERASE-ALUF SHEET) SHEET))
      ;; If special case of italic line, move back and decrement starting index
      (COND (DWIDTH
	     (SETF (SHEET-CURSOR-X SHEET) (- SET-XPOS DWIDTH))
	     (SETQ I (1- I))))

  HD  (AND ( I N)
	   (RETURN (1+ I) (- (SHEET-CURSOR-X SHEET) (SHEET-INSIDE-LEFT SHEET))))
      (SETQ CH (AREF STRING I))
      (OR (EQ (SETQ TEM (LDB %%CH-FONT CH)) FONTX)	;Changing to a new font
	  (LET ((FONT-MAP (SHEET-FONT-MAP SHEET)))
	    (SETQ FONTX TEM)
	    (SETQ FONT (AREF FONT-MAP (IF ( FONTX (ARRAY-ACTIVE-LENGTH FONT-MAP))
					  (SETQ FONTX 0)
					FONTX))
		  BASE-ADJ (- (SHEET-BASELINE SHEET) (FONT-BASELINE FONT)))))
  HD1 (SETQ WIDTH (SHEET-CHARACTER-WIDTH SHEET (SETQ CH (LDB %%CH-CHAR CH)) FONT))
      (COND ((> (+ (SHEET-CURSOR-X SHEET) WIDTH) RIGHT-LIMIT)	;This char won't fit
	     (AND MARGIN-FLAG (SEND SHEET ':TYO-RIGHT-MARGIN-CHARACTER
				    (SHEET-CURSOR-X SHEET) OYPOS #/!))
	     (RETURN (IF (ZEROP (SHEET-TRUNCATE-LINE-OUT-FLAG SHEET)) I (1+ N))
		     (- (SHEET-CURSOR-X SHEET) (SHEET-INSIDE-LEFT SHEET)))))
      (COND ((AND (< CH 200)
		  (NULL (FONT-INDEXING-TABLE FONT)))	;Let SHEET-TYO do big fonts
	     (AND (NULL (FONT-CHAR-WIDTH-TABLE FONT))
		  (NULL (FONT-LEFT-KERN-TABLE FONT))
		  (GO EZ))				;Handle easy fixed-width case fast
	     (GO VW)))					;Variable-width is a little slower
      (SHEET-TYO SHEET CH FONT)
      (SETQ I (1+ I))
      (GO HD)
  
      ;;This loop is for simple fonts that don't need full hair of SHEET-TYO
  EZ  (SETQ XPOS (SHEET-CURSOR-X SHEET)
	    ALUF (SHEET-CHAR-ALUF SHEET))
  EZ0 (SETQ WIDTH (FONT-CHAR-WIDTH FONT)
	    YPOS (+ (SHEET-CURSOR-Y SHEET) BASE-ADJ))
  EZ1 (OR (< CH 200) (GO EZX))				;Format effector, call full TYO
      (COND ((> (+ XPOS WIDTH) RIGHT-LIMIT)		;Form continuation line
	     (AND MARGIN-FLAG (SEND SHEET ':TYO-RIGHT-MARGIN-CHARACTER XPOS YPOS #/!))
	     (RETURN (IF (ZEROP (SHEET-TRUNCATE-LINE-OUT-FLAG SHEET)) I (1+ N))
		     (- XPOS (SHEET-INSIDE-LEFT SHEET)))))
      (%DRAW-CHAR FONT CH XPOS YPOS ALUF SHEET)
      (SETQ XPOS (+ XPOS WIDTH))
      ;;Get next character, if any left
      (COND (( (SETQ I (1+ I)) N)
	     (SETF (SHEET-CURSOR-X SHEET) XPOS)		;Necessary?
	     (RETURN (1+ I) (- XPOS (SHEET-INSIDE-LEFT SHEET)))))
      (SETQ CH (AREF STRING I)
	    TEM (LDB %%CH-FONT CH)
	    CH (LDB %%CH-CHAR CH))
      (AND (EQ TEM FONTX)
	   (GO EZ1))
      (SETQ FONT (AREF (SHEET-FONT-MAP SHEET)
		       (SETQ FONTX (IF ( TEM (ARRAY-ACTIVE-LENGTH (SHEET-FONT-MAP SHEET)))
				       0
				     TEM)))	;Changing to a new font
	    BASE-ADJ (- (SHEET-BASELINE SHEET) (FONT-BASELINE FONT)))
      (AND (NULL (FONT-LEFT-KERN-TABLE FONT))
	   (NULL (FONT-INDEXING-TABLE FONT))
	   (NULL (FONT-CHAR-WIDTH-TABLE FONT))
	   (GO EZ0))					;Handle easy case fast
  EZX (SETF (SHEET-CURSOR-X SHEET) XPOS)
      (GO HD1)						;Go type out char and enter HD loop

      ;;This loop is for variable-width fonts
  VW  (SETQ XPOS (SHEET-CURSOR-X SHEET)
	    ALUF (SHEET-CHAR-ALUF SHEET)
	    FWT (FONT-CHAR-WIDTH-TABLE FONT)
	    LKT (FONT-LEFT-KERN-TABLE FONT)
	    YPOS (+ (SHEET-CURSOR-Y SHEET) BASE-ADJ))
  VW1 (OR (< CH 200) (GO EZX))				;Format effector, call full TYO
      (AND FWT (SETQ WIDTH (AREF FWT CH)))
      (COND ((> (+ WIDTH XPOS) RIGHT-LIMIT)		;Won't fit in line
	     (AND MARGIN-FLAG (SEND SHEET ':TYO-RIGHT-MARGIN-CHARACTER XPOS YPOS #/!))
	     (RETURN (IF (ZEROP (SHEET-TRUNCATE-LINE-OUT-FLAG SHEET)) I (1+ N))
		     (- XPOS (SHEET-INSIDE-LEFT SHEET)))))
      (%DRAW-CHAR FONT CH (IF LKT (- XPOS (AREF LKT CH)) XPOS) YPOS ALUF SHEET)
      (SETQ XPOS (+ XPOS WIDTH))
      ;;Get next character, if any left
      (COND (( (SETQ I (1+ I)) N)
	     (SETF (SHEET-CURSOR-X SHEET) XPOS)		;Necessary?
	     (RETURN (1+ I) (- XPOS (SHEET-INSIDE-LEFT SHEET)))))
      (SETQ CH (AREF STRING I)
	    TEM (LDB %%CH-FONT CH)
	    CH (LDB %%CH-CHAR CH))
      (AND (EQ TEM FONTX) (GO VW1))
      (SETF (SHEET-CURSOR-X SHEET) XPOS)
      (GO HD)
      )))

(DEFMETHOD (SHEET :COMPUTE-MOTION) (STRING &OPTIONAL (START 0) END X Y &REST ARGS)
  (LEXPR-FUNCALL 'SHEET-COMPUTE-MOTION SELF X Y STRING START END ARGS))

(DEFCONST PRINTING-CHARACTER-TRANSLATE-TABLE
	  (MAKE-ARRAY 200 ':INITIAL-VALUE 1))
  
;; Change to T to fix the bug
;; that we stop after a character that goes across STOP-X
;; though we ought to stop before it.
;; Should not turn on the fix until the callers are changed to match.
;; If indeed the change really should be made.
(DEFCONST COMPUTE-MOTION-ROUND-DOWN NIL)

(DEFUN SHEET-COMPUTE-MOTION (SHEET X Y STRING
			     &OPTIONAL (START 0) (END NIL) (CR-AT-END-P NIL)
				       (STOP-X 0) (STOP-Y NIL) BOTTOM-LIMIT RIGHT-LIMIT
				       FONT
				       (LINE-HT (IF FONT (FONT-CHAR-HEIGHT FONT)
						  (SHEET-LINE-HEIGHT SHEET)))
				       (TAB-WIDTH
					 (IF FONT (* (FONT-CHAR-WIDTH FONT)
						     (SHEET-TAB-NCHARS SHEET))
					   (SHEET-TAB-WIDTH SHEET))))
  "Compute the motion that would be caused by outputing a string.
This is used by the editor and by TV:STREAM-MIXIN.
In computing the motion, it will chose the font in one of two ways:
 If given an ART-FAT-STRING array (16 bit string) like the editor uses,
  it will take the font from the %%CH-FONT field (high 8 bits) of the
  character, and look in SHEET's font-map.
 If given an ART-STRING array (8 bit string), it will take the font from
  FONT, or the SHEET-CURRENT-FONT of the sheet.
SHEET is used to supply information such as the font map,
 and for defaulting such things as BOTTOM-LIMIT, RIGHT-LIMIT
 and LINE-HT.
STRING, with START and END, specifies what characters to process.
CR-AT-END-P if non-NIL says /"output/" a Return after
 STRING or the portion of STRING, and count that
 in the cursor motion.
STOP-X and STOP-Y specify a cursor position at which to stop.
 Processing stops when both coordinates are  the stop points.
 The stop points default to the bottom left corner of SHEET.
 Specify a very large value for STOP-Y if you do not
 want processing to stop before the end of STRING.
BOTTOM-LIMIT and RIGHT-LIMIT are a cursor position
 at which to wrap around; these default to
 the inside-size of SHEET.
FONT specifies the font to use, if STRING is not a fat string.
LINE-HT is the line height to use for Return characters,
 defaulting to SHEET's line height.
TAB-WIDTH is the width to use for Tab characters,
 defaulting to SHEET's SHEET-TAB-WIDTH.

Processing stops either because the string or portion has
been processed or because the stopping-point has been reached.

Returns 4 values:
FINAL-X, FINAL-Y are the cursor position
 at which processing stopped.
FINAL-STRING-INDEX is the index
 in the string at which processing stopped (could be the length
 of the string, if the stop point was passed then), T if stopped
 due to reaching the stop point after the additional Return,
 or NIL if stopped due to finishing.
MAXIMUM-X was the largest X-position ever encountered during processing."

; *** The interface to this crock should be redesigned.  Also note that the
; *** exact treatment of STOP-X and STOP-Y does not agree with SHEET-STRING-LENGTH.
; *** This is what turning on COMPUTE-MOTION-ROUND-DOWN is going to fix.
  (DECLARE (RETURN-LIST FINAL-X FINAL-Y FINAL-STRING-INDEX MAXIMUM-X))
  (IF FONT
      (COERCE-FONT FONT SHEET)
    (SETQ FONT (SHEET-CURRENT-FONT SHEET)))
  (PROG (CWA CW CH FONTX TEM I N NN II MARGIN-FLAG MAXIMUM-X OLD-X)
    (OR (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG SHEET)) (SETQ MARGIN-FLAG T))
    (AND (NULL X) (SETQ X (- (SHEET-CURSOR-X SHEET) (SHEET-INSIDE-LEFT SHEET))))
    (AND (NULL Y) (SETQ Y (- (SHEET-CURSOR-Y SHEET) (SHEET-INSIDE-TOP SHEET))))
    (AND (NULL STOP-Y)
	 (SETQ STOP-Y (1+ (SHEET-INSIDE-HEIGHT SHEET))))
		    ;   ^-- THIS 1+ IS SO CAN USE  RATHER THAN >
    (OR RIGHT-LIMIT (SETQ RIGHT-LIMIT (SHEET-INSIDE-WIDTH SHEET)))
    (AND MARGIN-FLAG (SETQ RIGHT-LIMIT (- RIGHT-LIMIT (SHEET-CHAR-WIDTH SHEET))))
    (AND (NULL BOTTOM-LIMIT)
	 (SETQ BOTTOM-LIMIT (- (SHEET-INSIDE-HEIGHT SHEET) LINE-HT)))
    (SETQ MAXIMUM-X X
	  I START
 	  N (OR END (ARRAY-ACTIVE-LENGTH STRING))
	  CW (FONT-CHAR-WIDTH FONT))
    ;; At this point, decide whether we can use the fast version.
    (COND
      ;; If FONTX is non-NIL, then we have a string with font changes.
      ((NEQ 8 (CDR (ASSQ (ARRAY-TYPE STRING) ARRAY-BITS-PER-ELEMENT)))
       (SETQ FONTX T))
      ;; The current font is variable width.
      ((SETQ CWA (FONT-CHAR-WIDTH-TABLE FONT)))
      ;; No font changes and the current font is fixed width.  We can use the fast version.
      (T (GO FAST)))
    ;;This is the slow version.
SLOW
    (SETQ MAXIMUM-X (MAX X MAXIMUM-X))
    (COND ((AND ( Y STOP-Y) ( X STOP-X))	;Reached sticking-point
	   (RETURN X Y I MAXIMUM-X))
	  ((NOT (< I N))			;If string exhausted
	   (COND (CR-AT-END-P
		  (SETQ X 0 Y (+ Y LINE-HT))	;CRLF if told to
		  (AND (> Y BOTTOM-LIMIT) (SETQ Y 0))))
	   (RETURN X Y (AND ( X STOP-X) ( Y STOP-Y)) MAXIMUM-X)))
    ;; Move quickly over the remaining characters until we reach
    ;; an x-position at which something must be done.
    (UNLESS (EQ FONTX T)
      (LET (WIDTH-INCR
	    (LIMIT (MIN RIGHT-LIMIT (IF ( Y STOP-Y) STOP-X RIGHT-LIMIT))))
	(SETQ WIDTH-INCR
	      (%STRING-WIDTH (OR CWA
				 PRINTING-CHARACTER-TRANSLATE-TABLE)
			     (IF FONTX (DPB FONTX %%CH-FONT 0) 0)
			     STRING I N
			     (IF CWA (- LIMIT X) (FLOOR (- LIMIT X) CW))))
	(UNLESS CWA
	  (SETQ WIDTH-INCR (* WIDTH-INCR CW)))
	(SETQ I (%POP))
	;; increment positions.
	(SETQ X (+ WIDTH-INCR X))
	;; At end of string, loop back, to exit.
	(IF (= I N) (GO SLOW))
	;; Otherwise we stopped due to funny char or font change or reaching the X limit.
	))
    (SETQ MAXIMUM-X (MAX X MAXIMUM-X))
    (COND ((AND ( Y STOP-Y) ( X STOP-X))	;If reached sticking-point, done.
	   (RETURN X Y I MAXIMUM-X)))
    (SETQ CH (LDB %%CH-CHAR (SETQ TEM (AREF STRING I))))
    (COND ((AND FONTX (NEQ (SETQ TEM (LDB %%CH-FONT TEM)) FONTX)) ;Changing fonts
	   (SETQ FONTX TEM
		 FONT (LET ((FONT-MAP (SHEET-FONT-MAP SHEET)))
			(AREF FONT-MAP (IF ( FONTX (ARRAY-ACTIVE-LENGTH FONT-MAP))
					   0 FONTX)))
		 CWA (FONT-CHAR-WIDTH-TABLE FONT)
		 CW (FONT-CHAR-WIDTH FONT))))
    (SETQ OLD-X X)
    ;; Try to do this one char.
    (COND ((= CH #\CR)
	   (SETQ X 0 Y (+ Y LINE-HT))
	   (AND (> Y BOTTOM-LIMIT) (SETQ Y 0)))
	  ((< CH 200)				;Printing character
	   (SETQ X (+ (COND (CWA (AREF CWA CH)) (T CW)) X))) ;do char width
	  ((= CH #\TAB)				;Tab (have to do here since x-dependent)
	   (SETQ TEM TAB-WIDTH)
	   (SETQ X (* (TRUNCATE (+ X TEM) TEM) TEM)))
	  (T					;Format effector
	   (SETQ X (MAX (+ X (SHEET-CHARACTER-WIDTH SHEET CH FONT)) 0))))
    ;; If this char went past the stop-point, pretend we stopped before it.
    (WHEN (AND COMPUTE-MOTION-ROUND-DOWN
	       (> X STOP-X) ( Y STOP-Y))
      (RETURN OLD-X Y I MAXIMUM-X))
    ;; If this char went past the right margin, do a CR, then redo this char
    (COND ((> X RIGHT-LIMIT)
	   (SETQ X 0 Y (+ Y LINE-HT))
	   (AND (> Y BOTTOM-LIMIT) (SETQ Y 0)))
	  (T (SETQ I (1+ I))))
    (GO SLOW)

    ;;Here is the fast loop.  The basic idea is to scan as fast as possible
    ;;over printing characters, with all checking outside the loop.
FAST 
    (SETQ MAXIMUM-X (MAX X MAXIMUM-X))
    ;;First, decide the most characters we want to scan over in a whack
    (SETQ NN
	  (MIN (+ (TRUNCATE (- (COND (( Y STOP-Y)	;Stop-point is in this line
				      STOP-X)
				     (T RIGHT-LIMIT))	;Stop for this line is margin
			       X)
			    CW)
		  I)
	       N))				;NN is limiting value of I
    ;Now, scan over printing characters.
    (AND ( (SETQ II I) NN)			;Save initial I, and check for null loop
	 (GO SCX))
SCN (%STRING-WIDTH PRINTING-CHARACTER-TRANSLATE-TABLE
		   0 STRING II NN NIL)
    (SETQ I (%POP))
;    (SETQ TEM 200)				;This is really a ridiculous bum
;SCN (AND (< (AREF STRING I) TEM)		;If this is a printing character
;	 (< (SETQ I (1+ I)) NN)			; and we haven't reached stop point
;	 (GO SCN))				; then continue to loop (9 instructions)
    (SETQ X (+ (* (- I II) CW) X))		;Account for the motion of those chars
SCX (SETQ NN X)
    (SETQ MAXIMUM-X (MAX X MAXIMUM-X))
    (COND ((AND ( Y STOP-Y) ( X STOP-X))	;If reached sticking-point, done.
	   (RETURN X Y I MAXIMUM-X))
	  ((NOT (< I N))			;If string exhausted
	   (COND (CR-AT-END-P			;Do return X off end of line
		  (SETQ X 0 Y (+ Y LINE-HT))	;crlf if told to
		  (AND (> Y BOTTOM-LIMIT) (SETQ Y 0))))
	   (RETURN X Y (AND ( X STOP-X) ( Y STOP-Y)) MAXIMUM-X)))
    (SETQ OLD-X X)
    ;; Try to do this one char.
    (COND ((= (SETQ CH (AREF STRING I)) #\CR)
	   (SETQ X 0 Y (+ Y LINE-HT))
	   (AND (> Y BOTTOM-LIMIT) (SETQ Y 0)))
	  ((< CH 200)				;Printing character
	   (SETQ X (+ CW X)))
	  ((= CH #\TAB)				;Tab (have to do here since x-dependent)
	   (SETQ TEM TAB-WIDTH)
	   (SETQ X (* (TRUNCATE (+ X TEM) TEM) TEM)))
	  (T					;Format effector
	   (SETQ X (MAX (+ X (SHEET-CHARACTER-WIDTH SHEET CH FONT)) 0))))
    ;; If this char went past the stop-point, pretend we stopped before it.
    (WHEN (AND COMPUTE-MOTION-ROUND-DOWN
	       (> X STOP-X) ( Y STOP-Y))
      (RETURN OLD-X Y I MAXIMUM-X))
    ;; If this char went past the right margin, do a CR and then redo this char.
    (COND ((> X RIGHT-LIMIT)
	   (SETQ X 0 Y (+ Y LINE-HT))
	   (AND (> Y BOTTOM-LIMIT) (SETQ Y 0)))
	  (T (SETQ I (1+ I))))
    (GO FAST)
))

(DEFMETHOD (SHEET :CHARACTER-WIDTH) (CHAR &OPTIONAL (FONT CURRENT-FONT))
  (SHEET-CHARACTER-WIDTH SELF CHAR
			 (IF (TYPEP FONT 'FONT)
			     FONT
			   (FUNCALL (SHEET-GET-SCREEN SELF)
				    ':PARSE-FONT-DESCRIPTOR FONT))))

(DEFUN SHEET-CHARACTER-WIDTH (SHEET CH FONT &AUX TEM)
  "Returns the width of a character, in raster units.
For backspace, it can return a negative number.
For tab, the number returned depends on the current cursor position.
For return, the result is zero.
CH can be NIL; then you get the font's character-width."
  (COERCE-FONT FONT SHEET)
  (COND ((NULL CH) (FONT-CHAR-WIDTH FONT))
	((< CH 200)				;Ordinary printing character
	 (COND ((SETQ TEM (FONT-CHAR-WIDTH-TABLE FONT)) (AREF TEM CH))
	       (T (FONT-CHAR-WIDTH FONT))))
	((= CH #\CR) 0)				        ;Return
	((= CH #\TAB)				        ;Tab
	 (SETQ TEM (SHEET-TAB-WIDTH SHEET))
	 (- (* (TRUNCATE (+ (SHEET-CURSOR-X SHEET) TEM) TEM) TEM)
	    (SHEET-CURSOR-X SHEET)))
	((AND (= CH #\BS) (ZEROP (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG SHEET)))
	 (MINUS (SHEET-CHAR-WIDTH SHEET)))		;Backspace
	(T						;Misc lozenge character
	 (LET ((TEM (CAR (RASSOC CH SI:XR-SPECIAL-CHARACTER-NAMES))))
	   (LOZENGED-STRING-WIDTH (OR TEM "777"))))))

(DEFMETHOD (SHEET :STRING-LENGTH) (&REST ARGS)
  (LEXPR-FUNCALL 'SHEET-STRING-LENGTH SELF ARGS))

(DEFUN SHEET-STRING-LENGTH (SHEET STRING &OPTIONAL (START 0) (END NIL) (STOP-X NIL)
						   FONT (START-X 0)
						   (TAB-WIDTH
						     (IF FONT (* (FONT-CHAR-WIDTH FONT)
								 (SHEET-TAB-NCHARS SHEET))
						       (SHEET-TAB-WIDTH SHEET)))
						   &AUX (MAX-X START-X))
  "Return the length in X-position of STRING or a portion.
START and END specify the portion (default is all).
START-X is an X-position to begin computation at.
STOP-X is an X-position at which to stop processing and return.
 FINAL-INDEX will indicate where in the string this was reached.
FONT is the font to use (default is SHEET's current font);
 but if STRING is an ART-FAT-STRING, each character's font
 is looked up in SHEET's font-map.
TAB-WIDTH is the width to use for tab characters,
 defaulting to SHEET's SHEET-TAB-WIDTH.

The cursor position does not wrap around during processing;
arbitrarily large values can be returned.
Use TV:SHEET-COMPUTE-MOTION if you want wrap-around.

Three values are returned:
FINAL-X is the X-position when processing stopped
 (due to end of string or portion, or reaching STOP-X).
FINAL-INDEX is the index in the string at which processing stopped.
MAXIMUM-X is the largest X-position reached during processing.
 This can be larger than FINAL-X if the string contains
 Backspaces or Returns."
  (DECLARE (RETURN-LIST FINAL-X FINAL-INDEX MAXIMUM-X))
  (IF FONT
      (COERCE-FONT FONT SHEET)
    (SETQ FONT (SHEET-CURRENT-FONT SHEET)))
  (PROG (CWA CW CH FONTX TEM I N NN II STRINGP (X START-X))
    (SETQ I START
	  N (OR END (ARRAY-ACTIVE-LENGTH STRING))
	  CW (FONT-CHAR-WIDTH FONT))
    ;At this point, decide whether we can use the fast version
SLOW
    (AND (SETQ STRINGP (= (%P-MASK-FIELD-OFFSET %%ARRAY-TYPE-FIELD STRING 0)
			  ART-STRING))			;i.e. no font changes
	 (NULL (SETQ CWA (FONT-CHAR-WIDTH-TABLE FONT)))	;and fixed width
	 (GO FAST))
SLOW0
    (OR (< I N) (RETURN X I MAX-X))			;If string exhausted
    ;; Move quickly over 20 characters, or all the remaining characters,
    ;; if that does not go past STOP-X.
    (WHEN (OR STRINGP FONTX)
      (LET ((WIDTH-INCR
	      (%STRING-WIDTH (OR CWA
				 PRINTING-CHARACTER-TRANSLATE-TABLE)
			     (IF FONTX (DPB FONTX %%CH-FONT 0) 0)
			     STRING I N
			     (AND STOP-X
				  (IF CWA
				      (- STOP-X X)
				    (FLOOR (- STOP-X X) CW))))))
	(UNLESS CWA
	  (SETQ WIDTH-INCR (* WIDTH-INCR CW)))
	(SETQ I (%POP))
	(SETQ X (+ WIDTH-INCR X))
	(SETQ MAX-X (MAX X MAX-X))
	;; Loop back if reached end of string.
	(IF (= I N) (GO SLOW0))
	;; Otherwise we stopped due to funny char or font change or reaching STOP-X.
	))
    (SETQ CH (LDB %%CH-CHAR (SETQ TEM (AREF STRING I))))
    (COND ((AND (NOT STRINGP)				;Changing fonts
		(NEQ (SETQ TEM (LDB %%CH-FONT TEM)) FONTX))
	   (SETQ FONTX TEM
		 FONT (AREF (SHEET-FONT-MAP SHEET) FONTX)
		 CWA (FONT-CHAR-WIDTH-TABLE FONT)
		 CW (FONT-CHAR-WIDTH FONT))))
    (COND ((< CH 200)					;Printing character
	   (SETQ NN (IF CWA (AREF CWA CH) CW)))
	  ((= CH #\TAB)
	   (SETQ TEM TAB-WIDTH)
	   (SETQ NN (- (* (TRUNCATE (+ X TEM) TEM) TEM) X)))
	  ((AND (= CH #\BS) (ZEROP (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG SHEET)))
	   (SETQ NN (- (MAX 0 (- X (SHEET-CHAR-WIDTH SHEET))) X)))
	  ((= CH #\CR)
	   (SETQ NN 0 X 0))
	  (T					;Lozenged character
	   (SETQ NN (SHEET-CHARACTER-WIDTH SHEET CH FONT))))
    (SETQ X (+ X NN))
    (IF (> X MAX-X) (SETQ MAX-X X))
    (AND STOP-X (> X STOP-X)			;If char doesn't fit, stop before it
	 (RETURN (- X NN) I MAX-X))
    (SETQ I (1+ I))
    (GO SLOW)

    ;Here is the fast loop.  The basic idea is to scan as fast as possible
    ;over printing characters, with all checking outside the loop.
FAST 
    ;First, decide the most characters we want to scan over in a whack
    (SETQ NN (COND ((NULL STOP-X) N)		;NN is limiting value of I
                   ((MIN (+ (TRUNCATE (- STOP-X X) CW)
                            I)
                         N))))
    ;Now, scan over printing characters.
    (AND ( (SETQ II I) NN)			;Save initial I, and check for null loop
	 (GO SLOW0))
SCN (%STRING-WIDTH PRINTING-CHARACTER-TRANSLATE-TABLE
		   0 STRING II NN NIL)
    (SETQ I (%POP))
;    (SETQ TEM 200)				;This is really a ridiculous bum
;SCN (AND (< (AREF STRING I) TEM)		;If this is a printing character
;	 (< (SETQ I (1+ I)) NN)			; and we haven't reached stop point
;	 (GO SCN))				; then continue to loop (9 instructions)
    (SETQ X (+ (* (- I II) CW) X))		;Account for the motion of those chars
    (IF (> X MAX-X) (SETQ MAX-X X))
    (GO SLOW0)					;Either string exhausted, non-printing,
						; or reached stop-x
))

(DEFMETHOD (SHEET :STRING-OUT-EXPLICIT)
	   (STRING START-X START-Y X-LIMIT Y-LIMIT FONT ALU
	    &OPTIONAL (START 0) END MULTI-LINE-LINE-HEIGHT)
  (SHEET-STRING-OUT-EXPLICIT-1 SELF STRING START-X START-Y X-LIMIT Y-LIMIT FONT ALU
			       START END MULTI-LINE-LINE-HEIGHT))

(COMPILER:MAKE-OBSOLETE SHEET-STRING-OUT-EXPLICIT
			"use the :STRING-OUT-EXPLICIT operation with rearranged args")
(DEFUN SHEET-STRING-OUT-EXPLICIT (SHEET STRING START-X Y XLIM FONT ALU
				  &OPTIONAL (START 0) (END NIL)
				  MULTI-LINE-LINE-HEIGHT YLIM)
  (SHEET-STRING-OUT-EXPLICIT-1 SHEET STRING START-X Y XLIM YLIM
			       FONT ALU START END MULTI-LINE-LINE-HEIGHT))

(DEFUN SHEET-STRING-OUT-EXPLICIT-1 (SHEET STRING START-X Y XLIM YLIM FONT ALU
				    &OPTIONAL (START 0) (END NIL)
				    MULTI-LINE-LINE-HEIGHT
				    &AUX FIT FWT LKT
				    (X START-X))
  "Output STRING on SHEET without using SHEET's cursor, font, etc.
Output starts at cursor position START-X, Y but SHEET's cursor is not moved.
Output stops if x-position XLIM or y-position YLIM is reached.
Font FONT is used, and alu-function ALU.
START and END specify a portion of STRING to be used.
MULTI-LINE-LINE-HEIGHT is how far to move down for Return characters;
 Return also moves back to x-position START-X.
 NIL means output <Return> with a lozenge.
All position arguments are relative to SHEET's outside edges."
  (DECLARE (RETURN-LIST FINAL-X FINAL-INDEX FINAL-Y))
  (COERCE-FONT FONT SHEET)
  (SETQ FIT (FONT-INDEXING-TABLE FONT)
	FWT (FONT-CHAR-WIDTH-TABLE FONT)
	LKT (FONT-LEFT-KERN-TABLE FONT))
  (OR XLIM (SETQ XLIM (SHEET-WIDTH SHEET)))
  (PREPARE-SHEET (SHEET)
    (DO ((I START (1+ I))
	 (N (OR END (ARRAY-ACTIVE-LENGTH STRING)))
	 (WIDTH (FONT-CHAR-WIDTH FONT))
	 (CH))
	(( I N) (VALUES X Y I))
      (SETQ CH (AREF STRING I))
      (COND ((AND MULTI-LINE-LINE-HEIGHT (= CH #\RETURN))
	     (SETQ X START-X Y (+ Y MULTI-LINE-LINE-HEIGHT))
	     (IF (AND YLIM (> (+ Y MULTI-LINE-LINE-HEIGHT) YLIM))
		 (RETURN X Y I)))
	    (( CH 200)
	     (LET* ((STRING (STRING (OR (CAR (RASSOC CH SI:XR-SPECIAL-CHARACTER-NAMES))
					(FORMAT NIL "~3O" CH))))
		    (NX (+ X (LOZENGED-STRING-WIDTH STRING))))
	       (IF (> NX XLIM) (RETURN X Y I))
	       (SHEET-DISPLAY-LOZENGED-STRING-INTERNAL SHEET STRING
						       X (1+ Y) XLIM ALU)
	       (SETQ X NX)))
	    (T (IF FWT (SETQ WIDTH (AREF FWT CH)))
	       (IF (> (+ X WIDTH) XLIM) (RETURN X Y I))
	       (DRAW-CHAR FONT CH
			  (IF LKT (- X (AREF LKT CH)) X)
			  Y ALU SHEET)
	       (SETQ X (+ X WIDTH)))))))

;like %DRAW-CHAR but works on wide characters just as on narrow ones.
(DEFUN DRAW-CHAR (FONT CH X Y ALU SHEET)
  "Draw character CH in FONT at X, Y in SHEET using alu-function ALU.
X and Y are relative to SHEET's outside edges."
  (COERCE-FONT FONT SHEET)
  (LET ((FIT (FONT-INDEXING-TABLE FONT)))
    (IF FIT
	(DO ((CH (AREF FIT CH) (1+ CH))
	     (LIM (AREF FIT (1+ CH)))
	     (BPP (IF (ARRAYP SHEET) (ARRAY-BITS-PER-PIXEL SHEET)
		    (SHEET-BITS-PER-PIXEL SHEET)))
	     (X X (+ X (TRUNCATE (FONT-RASTER-WIDTH FONT) BPP))))
	    (( CH LIM))
	  (%DRAW-CHAR FONT CH X Y ALU SHEET))
      (%DRAW-CHAR FONT CH X Y ALU SHEET))))

(DEFMETHOD (SHEET :DISPLAY-CENTERED-STRING-EXPLICIT) (&REST ARGS)
  (LEXPR-FUNCALL 'SHEET-DISPLAY-CENTERED-STRING-EXPLICIT SELF ARGS))

(COMPILER:MAKE-OBSOLETE SHEET-DISPLAY-CENTERED-STRING-EXPLICIT
			"use the :STRING-OUT-CENTERED-EXPLICIT operation with rearranged args")
(DEFUN SHEET-DISPLAY-CENTERED-STRING-EXPLICIT
       (SHEET STRING &OPTIONAL
	(LEFT (TV:SHEET-INSIDE-LEFT SHEET)) Y-POS
	(RIGHT (SHEET-INSIDE-RIGHT SHEET))
	(FONT (SHEET-CURRENT-FONT SHEET)) 
	(ALU (SHEET-CHAR-ALUF SHEET))
	(START 0) END
	(MULTI-LINE-LINE-HEIGHT (SHEET-LINE-HEIGHT SHEET))
	Y-LIMIT)
  (SHEET-STRING-OUT-CENTERED-EXPLICIT SELF STRING LEFT Y-POS RIGHT Y-LIMIT
				      FONT ALU START END MULTI-LINE-LINE-HEIGHT))

(DEFMETHOD (SHEET :STRING-OUT-CENTERED-EXPLICIT)
	   (STRING &OPTIONAL (LEFT (SHEET-INSIDE-LEFT)) Y-POS
	    (RIGHT (SHEET-INSIDE-RIGHT)) Y-LIMIT
	    (FONT CURRENT-FONT) 
	    (ALU CHAR-ALUF)
	    (START 0) END
	    (MULTI-LINE-LINE-HEIGHT LINE-HEIGHT))
  (SHEET-STRING-OUT-CENTERED-EXPLICIT SELF STRING LEFT Y-POS RIGHT Y-LIMIT
				      FONT ALU START END MULTI-LINE-LINE-HEIGHT))

(DEFUN SHEET-STRING-OUT-CENTERED-EXPLICIT
       (SHEET STRING
	&OPTIONAL (LEFT (TV:SHEET-INSIDE-LEFT SHEET)) Y-POS
	(RIGHT (SHEET-INSIDE-RIGHT SHEET)) YLIM
	(FONT (SHEET-CURRENT-FONT SHEET))
	(ALU (SHEET-CHAR-ALUF SHEET))
	(START 0) END
	(MULTI-LINE-LINE-HEIGHT (SHEET-LINE-HEIGHT SHEET))
	&AUX WID SWID)
  "Output STRING or portion on SHEET centered between LEFT and RIGHT.
LEFT and RIGHT are relative to SHEET's outside edge.
The string is truncated on the right if it is too wide.
Y-POS specifies the vertical position of the top of the output,
relative to SHEET's top margin.
FONT and ALU function are used, defaulting to SHEET's font and char-aluf.
START and END specify a portion of STRING to output; default is all.
MULTI-LINE-LINE-HEIGHT is the distance for Return to move down;
 then each line is centered individually.
 It can be NIL meaning output Return as <Return>.
 Default is sheet's line-height.

SHEET's cursor is not used or moved."
  (IF FONT
      (COERCE-FONT FONT SHEET)
    (SETQ FONT (SHEET-CURRENT-FONT SHEET)))
  (OR ALU (SETQ ALU ALU-IOR))
  (SETQ WID (- RIGHT LEFT)
	STRING (STRING STRING))
  (OR END (SETQ END (STRING-LENGTH STRING)))
  (DO ((BEG START)) ((>= BEG END))
    (LET ((STOP (OR (STRING-SEARCH-CHAR #\RETURN STRING BEG END) END)))
      (MULTIPLE-VALUE (NIL NIL NIL SWID)  ;Compute how wide the string is, and whether to truncate
	(SHEET-COMPUTE-MOTION SHEET 0 0 STRING BEG STOP NIL
			      1.0S10 1.0S10 1.0S10 1.0S10 FONT))
      (SHEET-STRING-OUT-EXPLICIT-1 SHEET STRING
				   (+ LEFT (MAX (TRUNCATE (- WID SWID) 2) 0))
				   Y-POS
				   RIGHT NIL FONT ALU BEG STOP)
      (IF (OR (NULL MULTI-LINE-LINE-HEIGHT)
	      (>= (+ Y-POS MULTI-LINE-LINE-HEIGHT) YLIM))
	  (RETURN))
      (INCF Y-POS MULTI-LINE-LINE-HEIGHT)
      (SETQ BEG (1+ STOP)))))

(DEFMETHOD (SHEET :STRING-OUT-CENTERED) (&REST ARGS)
  (LEXPR-FUNCALL 'SHEET-DISPLAY-CENTERED-STRING SELF ARGS))

(DEFMETHOD (SHEET :DISPLAY-CENTERED-STRING) (&REST ARGS)
  (LEXPR-FUNCALL 'SHEET-DISPLAY-CENTERED-STRING SELF ARGS))

;;; This function displays a string centered between two X coordinates, truncated if necessary
;;; The arguments are relative to the margins, as usual.
(DEFUN SHEET-DISPLAY-CENTERED-STRING (SHEET STRING
				      &OPTIONAL (LEFT 0) (RIGHT (SHEET-INSIDE-WIDTH SHEET))
				                (Y-POS (- (SHEET-CURSOR-Y SHEET)
							  (SHEET-INSIDE-TOP SHEET)))
				      &AUX WID SWID SLEN)
  "Output STRING on SHEET centered between LEFT and RIGHT.
LEFT and RIGHT are relative to SHEET's margin.
Y-POS specifies the vertical position of the top of the output,
relative to SHEET's top margin.  The output may be multiple lines.
SHEET's current font, alu function and line height are used.
SHEET's cursor is left at the end of the string."
  (SETQ WID (- RIGHT LEFT)
	STRING (STRING STRING))
  (MULTIPLE-VALUE (SWID SLEN)  ;Compute how wide the string is, and whether to truncate
     (SHEET-STRING-LENGTH SHEET STRING 0 NIL WID))
  ;; SHEET-SET-CURSORPOS takes arguments in a different coordinate system
  (SHEET-SET-CURSORPOS SHEET (+ LEFT (MAX (TRUNCATE (- WID SWID) 2) 0)) Y-POS)
  (SHEET-STRING-OUT SHEET STRING 0 SLEN))

(DEFMETHOD (SHEET :STRING-OUT-X-Y-CENTERED-EXPLICIT) (&REST ARGS)
  (LEXPR-FUNCALL 'SHEET-DISPLAY-X-Y-CENTERED-STRING SELF ARGS))

(DEFMETHOD (SHEET :DISPLAY-X-Y-CENTERED-STRING) (&REST ARGS)
  (LEXPR-FUNCALL 'SHEET-DISPLAY-X-Y-CENTERED-STRING SELF ARGS))

(DEFUN SHEET-DISPLAY-X-Y-CENTERED-STRING (SHEET STRING
					  &OPTIONAL
					  (LEFT (SHEET-INSIDE-LEFT SHEET))
					  (TOP (SHEET-INSIDE-TOP SHEET))
					  (RIGHT (SHEET-INSIDE-RIGHT SHEET))
					  (BOTTOM (SHEET-INSIDE-BOTTOM SHEET))
					  (FNT (SHEET-CURRENT-FONT SHEET))
					  (ALU (SHEET-CHAR-ALUF SHEET))
					  (START 0) END
					  (MULTI-LINE-LINE-HEIGHT (SHEET-LINE-HEIGHT SHEET)))
  "Display STRING on SHEET centered in both X and Y, in font FNT.
It is centered horizontally between LEFT and RIGHT,
vertically between TOP and BOTTOM.
All four coordinates are relative to SHEET's outside edges.
SHEET's cursor is not used or moved."
  (LET ((WID (- RIGHT LEFT)))
    (MULTIPLE-VALUE-BIND (NIL SHEI SLEN SWID)
	(SHEET-COMPUTE-MOTION SHEET LEFT TOP STRING START END T
			      0 (+ top (sheet-inside-height sheet))
			      30000000 NIL FNT MULTI-LINE-LINE-HEIGHT)
;	(SHEET-STRING-LENGTH SHEET STRING START END WID FNT)
      (UNLESS (NUMBERP SLEN) (SETQ SLEN NIL))
      (SHEET-STRING-OUT-EXPLICIT-1 SHEET STRING
				   (+ LEFT (MAX (TRUNCATE (- WID SWID) 2) 0))
				   (MAX (- (TRUNCATE (+ TOP BOTTOM) 2)
					   (TRUNCATE SHEI 2))
					TOP)
				   RIGHT BOTTOM
				   FNT ALU START SLEN MULTI-LINE-LINE-HEIGHT))))

(setq sheis nil mids nil stops nil lefts nil tops nil sheets nil)

;;; Most screens can be seen by the "user"
(DEFMETHOD (SCREEN :USER-VISIBLE) () T)

;;; A mixin that causes inferiors to be scaled when the size of the window changes
;;; and propagates changes in the default font.
;;; TIME-STAMP is (as for any sheet), the time-stamp for comparison with this sheet's superior
;;; CURRENT-TIME-STAMP is the stamp which propagates down into our inferiors.  If
;;; an inferior's TIME-STAMP is EQ to our CURRENT-TIME-STAMP, then the inferior is
;;; up to date.  Otherwise we compare the two stamps and resolve the differences.
;;; This comparison happens to the active inferiors when our stamp changes and
;;; to any newly-activated inferior.
;;; This mixin is the only thing which knows the format of time stamps (other than
;;; that they are compared with EQ).  A time stamp is a list which represents
;;; the state of a window that has this mixin:
;;;	(serial-number our-inside-width our-inside-height default-font)
;;; serial-number is incremented every time a new time stamp is generated, and is
;;; only there for human beings looking at the stamps.
;;; Other elements may be added as needed.
(DEFFLAVOR SCALE-INFERIORS-MIXIN (CURRENT-TIME-STAMP) ()
  (:REQUIRED-FLAVORS SHEET)
  (:GETTABLE-INSTANCE-VARIABLES CURRENT-TIME-STAMP))

(DEFMETHOD (SCALE-INFERIORS-MIXIN :AFTER :INIT) (IGNORE)
  (SETQ CURRENT-TIME-STAMP
	(LIST 0 (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT)
	      (LOOP FOR ELT IN (SCREEN-FONT-ALIST (SHEET-GET-SCREEN SELF))
		    APPEND (LIST (CAR ELT) (FONT-EVALUATE (CDR ELT)))))))

(DEFMETHOD (SCALE-INFERIORS-MIXIN :INFERIOR-TIME-STAMP) (INF)
  INF						;Inferiors all have same time stamp
  CURRENT-TIME-STAMP)

(DECLARE-FLAVOR-INSTANCE-VARIABLES (SCALE-INFERIORS-MIXIN)
(DEFUN SCALE-INFERIORS-MIXIN-UPDATE-INFERIOR (INFERIOR)
  (LET ((INF-TIME-STAMP (SHEET-TIME-STAMP INFERIOR)))
    (COND ((NEQ INF-TIME-STAMP CURRENT-TIME-STAMP)
	   (LET ((OLD-FONT (FOURTH (SHEET-TIME-STAMP INFERIOR)))
		 (NEW-FONT (FOURTH CURRENT-TIME-STAMP)))
	     (OR (EQUAL OLD-FONT NEW-FONT)
		 (FUNCALL INFERIOR ':CHANGE-OF-DEFAULT-FONT NIL NIL)))
	   (SCALE-INFERIORS-MIXIN-SCALE-INFERIOR INFERIOR NIL INF-TIME-STAMP))))))

(DECLARE-FLAVOR-INSTANCE-VARIABLES (SCALE-INFERIORS-MIXIN)
(DEFUN SCALE-INFERIORS-MIXIN-SCALE-INFERIOR (INFERIOR EXPOSE
				&OPTIONAL (INF-TIME-STAMP (SHEET-TIME-STAMP INFERIOR)))
  (OR (EQ CURRENT-TIME-STAMP INF-TIME-STAMP)
      ;; Hasn't had edges set in the current time slice, so set them
      (LET* ((SIZE-LAST-TIME (CDR INF-TIME-STAMP))
	     (NEW-LEFT (TRUNCATE (* (SHEET-X-OFFSET INFERIOR)
				    (SHEET-INSIDE-WIDTH))
				 (FIRST SIZE-LAST-TIME)))
	     (NEW-TOP (TRUNCATE (* (SHEET-Y-OFFSET INFERIOR)
				   (SHEET-INSIDE-HEIGHT))
				(SECOND SIZE-LAST-TIME)))
	     (NEW-WIDTH (TRUNCATE (* (SHEET-WIDTH INFERIOR)
				     (SHEET-INSIDE-WIDTH))
				  (FIRST SIZE-LAST-TIME)))
	     (NEW-HEIGHT (TRUNCATE (* (SHEET-HEIGHT INFERIOR)
				      (SHEET-INSIDE-HEIGHT))
				   (SECOND SIZE-LAST-TIME))))
	(COND ((AND (= (SHEET-X-OFFSET INFERIOR) NEW-LEFT)
		    (= (SHEET-Y-OFFSET INFERIOR) NEW-TOP)
		    (= (SHEET-WIDTH INFERIOR) NEW-WIDTH)
		    (= (SHEET-HEIGHT INFERIOR) NEW-HEIGHT))
	       (SETQ NEW-LEFT NIL))
	      ((NOT (FUNCALL INFERIOR ':SET-EDGES NEW-LEFT NEW-TOP
			     (+ NEW-LEFT NEW-WIDTH) (+ NEW-TOP NEW-HEIGHT) ':VERIFY))
	       ;; Won't go, try not to change size
	       (SETQ NEW-WIDTH (SHEET-WIDTH INFERIOR)
		     NEW-HEIGHT (SHEET-HEIGHT INFERIOR))
	       (AND (> (+ NEW-WIDTH NEW-LEFT) (SHEET-INSIDE-RIGHT))
		    (SETQ NEW-LEFT (- (SHEET-INSIDE-RIGHT) NEW-WIDTH)))
	       (AND (> (+ NEW-HEIGHT NEW-TOP) (SHEET-INSIDE-BOTTOM))
		    (SETQ NEW-TOP (- (SHEET-INSIDE-BOTTOM) NEW-HEIGHT)))
	       (OR (FUNCALL INFERIOR ':SET-EDGES NEW-LEFT NEW-TOP
			    (+ NEW-LEFT NEW-WIDTH) (+ NEW-TOP NEW-HEIGHT) ':VERIFY)
		   ;; Won't go, don't change size at all
		   (SETQ NEW-LEFT NIL))))
	(COND (NEW-LEFT
	       (FUNCALL INFERIOR ':SET-EDGES
			NEW-LEFT NEW-TOP (+ NEW-LEFT NEW-WIDTH) (+ NEW-TOP NEW-HEIGHT))
	       (AND EXPOSE (FUNCALL INFERIOR ':EXPOSE)))
	      (T (FUNCALL INFERIOR ':UPDATE-TIME-STAMP)))))))

(DEFMETHOD (SCALE-INFERIORS-MIXIN :BEFORE :INFERIOR-ACTIVATE) (INFERIOR)
  ;Catch up with any changes that happened while we were inactive
  (SCALE-INFERIORS-MIXIN-UPDATE-INFERIOR INFERIOR)
  INFERIOR)

(DEFWRAPPER (SCALE-INFERIORS-MIXIN :CHANGE-OF-SIZE-OR-MARGINS) (IGNORE . BODY)
  `(DELAYING-SCREEN-MANAGEMENT
     (LET ((OLD-EXP-INFS (REVERSE EXPOSED-INFERIORS)))
       (DOLIST (I EXPOSED-INFERIORS)
	 (FUNCALL I ':DEEXPOSE))
       ,@BODY
       (SETQ CURRENT-TIME-STAMP
	     (LIST (1+ (CAR CURRENT-TIME-STAMP))
		   (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT)
		   (fourth current-time-stamp)))
       (DOLIST (I OLD-EXP-INFS)
	 (SCALE-INFERIORS-MIXIN-SCALE-INFERIOR I T))
       (DOLIST (I INFERIORS)
	 (OR (MEMQ I EXPOSED-INFERIORS)
	     (SCALE-INFERIORS-MIXIN-SCALE-INFERIOR I NIL))))))

(DEFMETHOD (SCALE-INFERIORS-MIXIN :BEFORE :CHANGE-OF-DEFAULT-FONT) (IGNORE IGNORE)
  (SETQ CURRENT-TIME-STAMP
	(LIST (1+ (CAR CURRENT-TIME-STAMP))
	      (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT)
	      (LOOP FOR ELT IN (SCREEN-FONT-ALIST (SHEET-GET-SCREEN SELF))
		    APPEND (LIST (CAR ELT) (FONT-EVALUATE (CDR ELT)))))))

(DEFVAR KILL-RECURSION NIL
  "Non-NIL if killing the inferiors of another window being killed.")

;; Kill the processes only after any :after :kill daemons have run.
(DEFWRAPPER (SHEET :KILL) (IGNORE . BODY)
  `(LET ((PROCESSES (UNLESS KILL-RECURSION (SEND SELF ':PROCESSES)))
	 (KILL-RECURSION T))
     ,@BODY
     (KILL-PROCESSES PROCESSES)))

(DEFMETHOD (SHEET :KILL) ()
  (SEND SELF ':DEACTIVATE)
  (MAPC 'FUNCALL (COPYLIST INFERIORS)
	(CIRCULAR-LIST ':KILL)))

(DEFUN KILL-PROCESSES (PROCESSES)
  (DOLIST (P PROCESSES)
    (UNLESS (EQ P CURRENT-PROCESS)
      (SEND P ':KILL)))
  (IF (MEMQ CURRENT-PROCESS PROCESSES)
      (SEND CURRENT-PROCESS ':KILL)))

;; Uses :APPEND method combination and returns a list of processes to be killed.
(DEFMETHOD (SHEET :PROCESSES) ()
  (MAPCAN 'FUNCALL (COPYLIST INFERIORS)
	  (CIRCULAR-LIST ':PROCESSES)))

(DEFFLAVOR STANDARD-SCREEN () (SCALE-INFERIORS-MIXIN SCREEN))

;;; Before making our first screen, compile any methods it requires
;;; Also do Sheet now, since it actually does get instantiated, e.g. for the who-line
(COMPILE-FLAVOR-METHODS SHEET SCREEN STANDARD-SCREEN)

;;; This height may get hacked by the who-line making code if the wholine ends up
;;; at the bottom of the main screen (which it usually does!)
(DEFVAR MAIN-SCREEN-WIDTH
  (SELECT PROCESSOR-TYPE-CODE
      (SI:CADR-TYPE-CODE 768.)
      (SI:LAMBDA-TYPE-CODE #o1440)))  ;LAMBDA TV IS 32. BITS WIDER.

(DEFVAR MAIN-SCREEN-HEIGHT
  (SELECT PROCESSOR-TYPE-CODE
      (SI:CADR-TYPE-CODE 963.)     ;was 896. for CPT
      (SI:LAMBDA-TYPE-CODE (- #o2000 8))))

(DEFCONST MAIN-SCREEN-BUFFER-ADDRESS IO-SPACE-VIRTUAL-ADDRESS)
(DEFCONST MAIN-SCREEN-CONTROL-ADDRESS 377760)
(DEFCONST MAIN-SCREEN-BUFFER-LENGTH 100000)

;;;Set things up
(DEFUN INITIALIZE ()
  (SHEET-CLEAR-LOCKS)
  (WHO-LINE-SETUP)
  ;; Set up screen and sheet for the main monitor (CPT typically)
  (OR MAIN-SCREEN
      (SETQ MAIN-SCREEN
	    (DEFINE-SCREEN 'STANDARD-SCREEN "Main Screen"
	      :BUFFER MAIN-SCREEN-BUFFER-ADDRESS
	      :CONTROL-ADDRESS MAIN-SCREEN-CONTROL-ADDRESS
	      :PROPERTY-LIST '(:VIDEO :BLACK-AND-WHITE :CONTROLLER :SIMPLE)
	      :HEIGHT (- MAIN-SCREEN-HEIGHT (SHEET-HEIGHT WHO-LINE-SCREEN))
	      :WIDTH MAIN-SCREEN-WIDTH
	      :LOCATIONS-PER-LINE 32.)))
  (SETQ MOUSE-SHEET MAIN-SCREEN)
  (SETQ DEFAULT-SCREEN MAIN-SCREEN
	INHIBIT-SCREEN-MANAGEMENT NIL
	SCREEN-MANAGER-TOP-LEVEL T
	SCREEN-MANAGER-QUEUE NIL))

(DEFUN DEFINE-SCREEN (FLAVOR NAME &REST ARGS)
  (LET ((SCREEN (LEXPR-FUNCALL #'MAKE-WINDOW FLAVOR ':NAME NAME ARGS)))
    (PUSH SCREEN ALL-THE-SCREENS)
    (FUNCALL SCREEN ':EXPOSE)
    SCREEN))

(DEFVAR MAIN-SCREEN-AND-WHO-LINE NIL)
(DEFUN MAIN-SCREEN-AND-WHO-LINE ()
  (IF MAIN-SCREEN-AND-WHO-LINE
      (SI:CHANGE-INDIRECT-ARRAY MAIN-SCREEN-AND-WHO-LINE (SHEET-ARRAY-TYPE MAIN-SCREEN)
				(IF ARRAY-INDEX-ORDER
				    (LIST MAIN-SCREEN-HEIGHT MAIN-SCREEN-WIDTH)
				  (LIST MAIN-SCREEN-WIDTH MAIN-SCREEN-HEIGHT))
				(SCREEN-BUFFER MAIN-SCREEN) NIL)
    (SETQ MAIN-SCREEN-AND-WHO-LINE
	  (MAKE-PIXEL-ARRAY MAIN-SCREEN-WIDTH MAIN-SCREEN-HEIGHT
			    ':TYPE (SHEET-ARRAY-TYPE MAIN-SCREEN)
			    ':DISPLACED-TO (SCREEN-BUFFER MAIN-SCREEN))))
  MAIN-SCREEN-AND-WHO-LINE)

(DEFVAR INITIAL-LISP-LISTENER)

;This function is called from an initialization in COMETH
(DEFUN WINDOW-INITIALIZE (&AUX FIRST-TIME)
  (INITIALIZE)
  (DOLIST (S ALL-THE-SCREENS)
    (FUNCALL S ':EXPOSE))
  (SETQ KBD-TYI-HOOK NIL PROCESS-IS-IN-ERROR NIL)
  (OR (EQ WHO-LINE-PROCESS SI:INITIAL-PROCESS)	;So it stays latched here during loading
      (SETQ WHO-LINE-PROCESS NIL))
  (OR INITIAL-LISP-LISTENER	;Set to NIL in LTOP
      (SETQ INITIAL-LISP-LISTENER (MAKE-WINDOW 'LISP-LISTENER ':PROCESS SI:INITIAL-PROCESS)
	    FIRST-TIME T))
  (FUNCALL INITIAL-LISP-LISTENER ':SELECT)
  (WHEN FIRST-TIME (SETQ TERMINAL-IO INITIAL-LISP-LISTENER))
  (OR (MEMQ 'TV:BLINKER-CLOCK SI:CLOCK-FUNCTION-LIST)
      (PUSH 'TV:BLINKER-CLOCK SI:CLOCK-FUNCTION-LIST)))

(DEFVAR SYNC-RAM-CONTENTS :UNBOUND
  "Data to load into the TV board's sync memory.")

(DEFUN SET-TV-SPEED (&OPTIONAL ARG (WASTED-LINES 0) &AUX VALUE N-LINES)
  "Set the TV refresh rate.  ARG is the number of scan lines to display.
On the CADR, it can also be the refresh frequency (default is 60.5).
WASTED-LINES is a number of lines at the bottom of the screen that should not be used
for output, and should be left zero, though they will be displayed on the monitor.
This is useful if your monitor is adjusted so that some of it cannot be seen."
  (UNLESS ARG
    (SETQ ARG (IF (= PROCESSOR-TYPE-CODE CADR-TYPE-CODE) 60.5 1024.)))
  ;; Try not to burn up the monitor
  (IF (= PROCESSOR-TYPE-CODE CADR-TYPE-CODE)
      (CHECK-ARG ARG (OR ( 54. ARG 76.) (< 763. ARG 1087.))
	     "a number between 55. and 75., or one between 764. and 1086.")
    (CHECK-ARG ARG (< 100. ARG 1025.)
	       "a number between 101. and 1024."))
  ;; If arg is frequency, compute number of lines from it.
  (IF (< 100. ARG)
      (SETQ N-LINES ARG)
    (SETQ N-LINES (- (FIX (// 1E6 (* 16. ARG))) 70.)))
  ;; Here each horizontal line is 32. sync clocks, or 16.0 microseconds with a 64 MHz clock.
  ;; The number of lines per frame is 70. overhead lines plus enough display lines
  ;; to give the desired rate.
  (DELAYING-SCREEN-MANAGEMENT
   (WITH-MOUSE-USURPED
    (LOCK-SHEET (MAIN-SCREEN)
     (LOCK-SHEET (WHO-LINE-SCREEN)
       (WITHOUT-INTERRUPTS
	 (LET ((MS MOUSE-SHEET) (SW SELECTED-WINDOW))
	   (AND (SHEET-ME-OR-MY-KID-P MS MAIN-SCREEN)
		(SETQ MOUSE-SHEET NIL))
	   (FUNCALL WHO-LINE-SCREEN ':DEEXPOSE)
	   (FUNCALL MAIN-SCREEN ':DEEXPOSE)
	   (WHEN (= PROCESSOR-TYPE-CODE CADR-TYPE-CODE)
	     (SI:SETUP-CPT
	       (SETQ SYNC-RAM-CONTENTS	;save for possible use at LISP-REINITIALIZE.
		(APPEND '(1.  (1 33) (5 13) 12 12 (11. 12 12) 212 113)	;VERT SYNC, CLEAR TVMA
		       '(53. (1 33) (5 13) 12 12 (11. 12 12) 212 13)	;VERT RETRACE
		       '(8.  (1 31)  (5 11) 11 10 (11. 0 0) 200 21)	;8 LINES OF MARGIN
		       (DO ((L NIL (APPEND L `(,DN (1 31) (5 11) 11 50 (11. 0 40) 200 21)))
			    (N N-LINES (- N DN))
			    (DN))
			   ((ZEROP N) L)
			 (SETQ DN (MIN 255. N)))
		       '(7. (1 31) (5 11) 11 10 (11. 0 0) 200 21)
		       '(1. (1 31) (5 11) 11 10 (11. 0 0) 300 23)))
	       (SCREEN-CONTROL-ADDRESS MAIN-SCREEN)
	       T))
	   ;; Move the who-line, and change the dimensions of main screen
	   (SETQ MAIN-SCREEN-HEIGHT (- N-LINES WASTED-LINES))
	   (FUNCALL WHO-LINE-SCREEN ':CHANGE-OF-SIZE-OR-MARGINS
		    ':TOP (- MAIN-SCREEN-HEIGHT (SHEET-HEIGHT WHO-LINE-SCREEN)))
	   (FUNCALL MAIN-SCREEN ':CHANGE-OF-SIZE-OR-MARGINS
		    ':HEIGHT (- MAIN-SCREEN-HEIGHT (SHEET-HEIGHT WHO-LINE-SCREEN)))
	   (SETQ %DISK-RUN-LIGHT
		 (+ (- (* MAIN-SCREEN-HEIGHT (SHEET-LOCATIONS-PER-LINE MAIN-SCREEN)) 15)
		    MAIN-SCREEN-BUFFER-ADDRESS))
	   (SETQ WHO-LINE-RUN-LIGHT-LOC (+ 2 (LOGAND %DISK-RUN-LIGHT 777777)))
	   (FUNCALL WHO-LINE-SCREEN ':EXPOSE)
	   (FUNCALL MAIN-SCREEN ':EXPOSE)
	   (AND SW (FUNCALL SW ':SELECT))
	   (SETQ MOUSE-SHEET MS)
	   ;; Zero out the words at screen bottom that we are not using.
	   (WHEN (= PROCESSOR-TYPE-CODE LAMBDA-TYPE-CODE)
	     (INCF WASTED-LINES (- 1024. N-LINES)))
	   (LET ((WASTED-WORDS (* WASTED-LINES (SHEET-LOCATIONS-PER-LINE MAIN-SCREEN)))
		 (PTR1 (%MAKE-POINTER-OFFSET DTP-FIX (SCREEN-BUFFER MAIN-SCREEN)
					     (* (- N-LINES WASTED-LINES)
						(SHEET-LOCATIONS-PER-LINE MAIN-SCREEN)))))
	     (DOTIMES (I WASTED-WORDS)
	       (%P-DPB 0 %%Q-LOW-HALF (%MAKE-POINTER-OFFSET DTP-FIX PTR1 I))
	       (%P-DPB 0 %%Q-HIGH-HALF (%MAKE-POINTER-OFFSET DTP-FIX PTR1 I))))
	   (SETQ VALUE (- N-LINES WASTED-LINES))))))))
  (DOLIST (RESOURCE-NAME WINDOW-RESOURCE-NAMES)
    (SI:MAP-RESOURCE 
      #'(LAMBDA (WINDOW &REST IGNORE)
	  (OR (TYPEP WINDOW ':INSTANCE) (FERROR NIL "LOSSAGE"))
	  (IF (TYPEP WINDOW 'TV:BASIC-MENU)
	      (LET ((GEO (SEND WINDOW ':GEOMETRY)))
		(DO ((L GEO (CDR L))) ((NULL L))
		  (SETF (CAR L) NIL)))
	    (LET* ((SUPERIOR (SEND WINDOW ':SUPERIOR))
		   (BOTTOM (SEND WINDOW ':HEIGHT))
		   (SUPHEIGHT (OR (SEND SUPERIOR ':SEND-IF-HANDLES ':INSIDE-HEIGHT)
				  (SEND SUPERIOR ':HEIGHT))))
	      (IF (> BOTTOM SUPHEIGHT)
		  (SEND WINDOW ':SET-SIZE (SEND WINDOW ':WIDTH) SUPHEIGHT)))))
      RESOURCE-NAME))
  VALUE)

(DEFF SET-TV-HEIGHT 'SET-TV-SPEED)

(DEFUN SET-WHO-LINE-LINES (N-LINES)
  "Reconfigure the screen so that the who line has N-LINES lines."
  (WITH-MOUSE-USURPED
   (LOCK-SHEET (MAIN-SCREEN)
    (LOCK-SHEET (WHO-LINE-SCREEN)
      (WITHOUT-INTERRUPTS
	(LET ((MS MOUSE-SHEET) (SW SELECTED-WINDOW))
	  (AND (SHEET-ME-OR-MY-KID-P MS MAIN-SCREEN)
	       (SETQ MOUSE-SHEET NIL))
	  (FUNCALL WHO-LINE-SCREEN ':DEEXPOSE)
	  (FUNCALL MAIN-SCREEN ':DEEXPOSE)
;	  (FUNCALL WHO-LINE-SCREEN ':SET-VSP (IF (= N-LINES 1) 0 2))
	  (FUNCALL WHO-LINE-SCREEN ':CHANGE-OF-SIZE-OR-MARGINS
		   ':BOTTOM MAIN-SCREEN-HEIGHT 
		   ':TOP (- MAIN-SCREEN-HEIGHT
			    (* N-LINES (SHEET-LINE-HEIGHT WHO-LINE-SCREEN))))
	  (FUNCALL MAIN-SCREEN ':CHANGE-OF-SIZE-OR-MARGINS
		   ':HEIGHT (- MAIN-SCREEN-HEIGHT (SHEET-HEIGHT WHO-LINE-SCREEN)))
	  (FUNCALL WHO-LINE-SCREEN ':EXPOSE)
	  (FUNCALL MAIN-SCREEN ':EXPOSE)
	  (AND SW (FUNCALL SW ':SELECT))
	  (SETQ MOUSE-SHEET MS)))))))

;;; Scan line table hacking

(defconst scan-line-table-begin #16r6000)
(defconst scan-line-table-length (// #16r1000 4))

(defun read-scan-line-table (adr)
  (%nubus-read #xf8 (+ (* adr 4) scan-line-table-begin)))

(defun write-scan-line-table (adr data)
  (%nubus-write #xf8 (+ (* adr 4) scan-line-table-begin) data))

(defun load-scan-line-table (words-per-line)
  (do ((line-number 0 (1+ line-number))
       (bit-map-pointer 0 (+ bit-map-pointer (* 2 words-per-line))))
      ((>= line-number scan-line-table-length) ())
    (write-scan-line-table line-number bit-map-pointer)))

(defun set-up-scan-line-table ()
  (load-scan-line-table (sheet-locations-per-line main-screen))
  (setq %disk-run-light
	(+ (* (1- main-screen-height) (sheet-locations-per-line main-screen))
	   14
	   (lsh 77 18.)))
  (setq who-line-run-light-loc (+ 2 (logand %disk-run-light 777777))))

(add-initialization "Load scan line table" '(set-up-scan-line-table))

;;;

(defvar *words-per-line*)

(defun set-screen-width (new-width-in-words)
  (setq *words-per-line* new-width-in-words)
  (delaying-screen-management
    (with-mouse-usurped
      (lock-sheet (main-screen)
	(lock-sheet (who-line-screen)
	  (without-interrupts
	    (let ((ms mouse-sheet) (sw selected-window))
	      (and (sheet-me-or-my-kid-p ms main-screen)
		   (setq mouse-sheet nil))
	      (funcall who-line-screen ':deexpose)
	      (funcall main-screen ':deexpose)

	      (setf (sheet-locations-per-line main-screen) *words-per-line*)
	      (setf (sheet-locations-per-line who-line-screen) *words-per-line*)

	      ;fix cold-load-stream
	      (let ((new-array
		      (make-array (list (* 32. *words-per-line*) 1777)
				  ':type 'art-1b
				  ; 10. is BUFFER instance variable
				  ':displaced-to (%p-contents-offset si:cold-load-stream 10.))))
		(%p-store-contents-offset
		  new-array si:cold-load-stream 1) ;ARRAY
		(%p-store-contents-offset
		  *words-per-line* si:cold-load-stream 2)	;LOCATIONS-PER-LINE
		(%p-store-contents-offset 1777 si:cold-load-stream 3) ;HEIGHT
		)

	      (load-scan-line-table *words-per-line*)

	      (map-over-all-windows-of-sheet
		#'(lambda (window) 
		    (send window ':eval-inside-yourself '(fix-window-width *words-per-line*)))
		main-screen)

	      (let ((array (send who-line-screen ':old-screen-array)))
		(redirect-array array
				(array-type array)
				(* *words-per-line* 32.)
				(pixel-array-height array)
				(%p-contents-offset array
					     (+ (array-rank array)
						(%p-ldb-offset %%array-long-length-flag array 0)))
				nil))

	      (map-over-all-windows-of-sheet
		#'(lambda (window)
		    (cond ((neq window who-line-screen)
			   (send window ':eval-inside-yourself '(fix-window-width *words-per-line*)))))
		who-line-screen)
	      
	      (send who-line-screen ':change-of-size-or-margins
		    ':top (- main-screen-height (sheet-height who-line-screen)))
	      (setq %disk-run-light
		    (+ (* (1- main-screen-height) (sheet-locations-per-line main-screen))
		       11.
		       (lsh 77 18.)))
	      (setq who-line-run-light-loc (+ 2 (logand %disk-run-light 777777)))
	      (funcall who-line-screen ':expose)
	      (funcall main-screen ':expose)
	      (and sw (funcall sw ':select))
	      (mouse-set-sheet ms)
	      )))))))

(defun fix-window-width (words-per-line)
  (setq locations-per-line words-per-line)
  (if (and (variable-boundp screen-array) screen-array)
      (fix-array self screen-array words-per-line))
  (if (and (variable-boundp old-screen-array) old-screen-array)
      (fix-array self old-screen-array words-per-line))
  (if (and (variable-boundp bit-array) bit-array)
      (fix-array self bit-array words-per-line)))

(defun fix-array (window array words-per-line)
  (cond ((array-displaced-p array)
	 (redirect-array array
			 (array-type array)
			 (* words-per-line 32.)
			 (pixel-array-height array)
			 ;used to be just array
			 (%p-contents-offset array
					     (+ (array-rank array)
						(%p-ldb-offset %%array-long-length-flag array 0)))
			 (let ((offset (+ (send window ':x-offset)
					  (* (send window ':y-offset) (* words-per-line 32.)))))
			   (if (zerop offset) 
			       (if (= (%P-LDB-OFFSET si:%%ARRAY-INDEX-LENGTH-IF-SHORT ARRAY 0) 2)
				   nil
				 0)
			     offset))))
	(t
	 (grow-bit-array array (* words-per-line 32.) (pixel-array-height array)))))

;;; Mapping over windows, allowing for devious concealment of Zmacs subwindows.

(defvar *mapped-windows*)

(defun map-over-all-windows-of-sheet (func sheet)
  (setq *mapped-windows* nil)
  (map-over-all-windows-of-sheet-1 func sheet)
  (dolist (resource-name window-resource-names)
    (si:map-resource #'(lambda (window ignore ignore)
			 (cond ((and (eq (send window ':status) ':deactivated)
				     (eq sheet (sheet-get-screen window)))
				(map-over-all-windows-of-sheet-1 func window))))
		     resource-name)))

(defun map-over-all-windows-of-sheet-1 (func sheet)
  (cond ((null (memq sheet *mapped-windows*))
	 (push sheet *mapped-windows*)
	 (funcall func sheet)
	 (cond ((and (not (typep sheet 'zwei:zwei-mini-buffer))
		     (send sheet ':send-if-handles ':typeout-window))
		(map-over-all-windows-of-sheet-1 func (send sheet ':typeout-window))))
	 (cond ((and (typep sheet 'zwei:mode-line-window)
		     (send sheet ':mini-buffer-window))
		(map-over-all-windows-of-sheet-1 func (send sheet ':mini-buffer-window))))
	 (dolist (x (send sheet ':inferiors))
	   (map-over-all-windows-of-sheet-1 func x)))))

;;;

(DEFUN lambda-set-height (&OPTIONAL (n-lines 1024.) &AUX VALUE)
  "Set the TV refresh rate.  The default is 60.5.  Returns the number of display lines.
WASTED-LINES is a number of lines at the bottom of the screen that should not be used.
This is useful if your monitor is adjusted so that some of it cannot be seen."
  ;; Try not to burn up the monitor
  (CHECK-ARG n-lines (AND (> n-lines 100.) (<= n-lines 1024.))
	     "a number between 100. and 1024.")
  (DELAYING-SCREEN-MANAGEMENT
    (WITH-MOUSE-USURPED
      (LOCK-SHEET (MAIN-SCREEN)
	(LOCK-SHEET (WHO-LINE-SCREEN)
	  (WITHOUT-INTERRUPTS
	    (LET ((MS MOUSE-SHEET) (SW SELECTED-WINDOW))
	      (AND (SHEET-ME-OR-MY-KID-P MS MAIN-SCREEN)
		   (SETQ MOUSE-SHEET NIL))
	      (FUNCALL WHO-LINE-SCREEN ':DEEXPOSE)
	      (FUNCALL MAIN-SCREEN ':DEEXPOSE)
	      ;; Move the who-line, and change the dimensions of main screen
	      (SETQ MAIN-SCREEN-HEIGHT N-LINES)
	      (FUNCALL WHO-LINE-SCREEN ':CHANGE-OF-SIZE-OR-MARGINS
		       ':TOP (- MAIN-SCREEN-HEIGHT (SHEET-HEIGHT WHO-LINE-SCREEN)))
	      (FUNCALL MAIN-SCREEN ':CHANGE-OF-SIZE-OR-MARGINS
		       ':HEIGHT (- MAIN-SCREEN-HEIGHT (SHEET-HEIGHT WHO-LINE-SCREEN)))
	      (let ((line-address (* (1- main-screen-height) (sheet-locations-per-line main-screen))))
		(setq %disk-run-light (+ (+ line-address 11.) (lsh 77 18.)))
		(setq who-line-run-light-loc (+ 2 (logand %disk-run-light 777777))))
	      (FUNCALL WHO-LINE-SCREEN ':EXPOSE)
	      (FUNCALL MAIN-SCREEN ':EXPOSE)
	      (AND SW (FUNCALL SW ':SELECT))
	      (SETQ MOUSE-SHEET MS)
	      (LET ((WASTED-WORDS (* (- 1024. n-lines) (SHEET-LOCATIONS-PER-LINE MAIN-SCREEN)))
		    (LAST-USED-WORD (* (+ (SHEET-HEIGHT WHO-LINE-SCREEN)
					  (SHEET-HEIGHT MAIN-SCREEN))
				       (SHEET-LOCATIONS-PER-LINE MAIN-SCREEN))))
		(DOTIMES (I WASTED-WORDS)
		  (%P-STORE-TAG-AND-POINTER
		    (%MAKE-POINTER-OFFSET DTP-FIX
					  (SCREEN-BUFFER MAIN-SCREEN) (+ LAST-USED-WORD I))
		    0 0)))
	      (SETQ VALUE N-LINES)))))))
  (DOLIST (RESOURCE-NAME WINDOW-RESOURCE-NAMES)
    (SI:MAP-RESOURCE 
      #'(LAMBDA (WINDOW &REST IGNORE)
	  (OR (TYPEP WINDOW ':INSTANCE) (FERROR NIL "LOSSAGE"))
	  (IF (typep window 'tv:basic-menu)
	      (LET ((GEO (SEND WINDOW ':GEOMETRY)))
		(DO ((L GEO (CDR L))) ((NULL L))
		  (SETF (CAR L) NIL)))
	    (LET* ((SUPERIOR (SEND WINDOW ':SUPERIOR))
		   (BOTTOM (SEND WINDOW ':HEIGHT))
		   (SUPHEIGHT (OR (SEND SUPERIOR ':SEND-IF-HANDLES ':INSIDE-HEIGHT)
				  (SEND SUPERIOR ':HEIGHT))))
	      (IF (> BOTTOM SUPHEIGHT)
		  (SEND WINDOW ':SET-SIZE (SEND WINDOW ':WIDTH) SUPHEIGHT)))))
      RESOURCE-NAME))
  VALUE)

;;; The high-level changes for the landscape.

(defun landscape ()
  "Configure all existing (primary) screens and windows for landscape monitor."
  (lambda-set-height 798.)
  (with-mouse-usurped
   (lock-sheet (main-screen)
    (lock-sheet (who-line-screen)
      (without-interrupts
	(let ((ms mouse-sheet) (sw selected-window))
	  (when (sheet-me-or-my-kid-p ms main-screen) (setq mouse-sheet nil))
	  (send who-line-screen :deexpose)
	  (send main-screen :deexpose)
	  (setq mouse-sheet ms)

	  (send who-line-screen :change-of-size-or-margins :width 1024.)
	  (send main-screen :change-of-size-or-margins :width 1024.)

	  (configure-who-line-for-landscape)

	  (mouse-set-sheet main-screen)
	  (send main-screen :expose)
	  (send who-line-screen :expose)
	  (when sw (send sw :select))))))))

(defun portrait ()
  "Configure all existing (primary) screens and windows for portrait monitor."
  (lambda-set-height 1016.)
  (with-mouse-usurped
   (lock-sheet (main-screen)
    (lock-sheet (who-line-screen)
      (without-interrupts
	(let ((ms mouse-sheet) (sw selected-window))
	  (when (sheet-me-or-my-kid-p ms main-screen) (setq mouse-sheet nil))
	  (send who-line-screen :deexpose)
	  (send main-screen :deexpose)
	  (setq mouse-sheet ms)

	  (send who-line-screen :change-of-size-or-margins :width 800.)
	  (send main-screen :change-of-size-or-margins :width 800.)

	  (configure-who-line-for-portrait)

	  (mouse-set-sheet main-screen)
	  (send main-screen :expose)
	  (send who-line-screen :expose)
	  (when sw (send sw :select))))))))

(defun configure-who-line-for-landscape ()
  (send who-line-run-state-sheet :change-of-size-or-margins
	:left 328. :right 520.)
  (send who-line-file-state-sheet :change-of-size-or-margins
	:left 520. :right 1024.)
  (send who-line-documentation-window :change-of-size-or-margins
	:width 1024.))

(defun configure-who-line-for-portrait ()
  (send who-line-run-state-sheet :change-of-size-or-margins
	:left 328. :right 480.)
  (send who-line-file-state-sheet :change-of-size-or-margins
	:left 480. :right 800.)
  (send who-line-documentation-window :change-of-size-or-margins
	:width 800.))

;;;

(DEFUN SET-DEFAULT-FONT (FONT-DESCRIPTOR)
  "Make FONT-DESCRIPTOR be the default font.
All windows that were set up to /"use the default font/"
will presently be using FONT-DESCRIPTOR.
FONT-DESCRIPTOR should be a font descriptor, such as the name of a font."
  (SET-STANDARD-FONT ':DEFAULT FONT-DESCRIPTOR))

(DEFUN SET-STANDARD-FONT (PURPOSE FONT-DESCRIPTOR)
  "Make FONT-DESCRIPTOR be the standard font for purpose PURPOSE.
All windows that were set up to /"use the font for PURPOSE/"
will presently be using FONT-DESCRIPTOR.
FONT-DESCRIPTOR should be a font descriptor, such as the name of a font."
  (DOLIST (SCREEN ALL-THE-SCREENS)
    (SET-SCREEN-STANDARD-FONT SCREEN PURPOSE FONT-DESCRIPTOR)))

(DEFUN SET-SCREEN-STANDARD-FONT (SCREEN PURPOSE FONT-DESCRIPTOR)
  "Make FONT-DESCRIPTOR be the standard font for purpose PURPOSE on SCREEN.
All windows on SCREEN that were set up to /"use the font for PURPOSE/"
will presently be using FONT-DESCRIPTOR."
  ;; Make absolutely sure we really have a font,
  ;; since if we don't this will wedge everything.
  (LET ((FONT (FUNCALL SCREEN ':PARSE-FONT-DESCRIPTOR FONT-DESCRIPTOR))
	FONT-NAME)
    (DO () ((TYPEP FONT 'FONT))
      (SETQ FONT (FONT-EVALUATE (CERROR T NIL ':WRONG-TYPE-ARG "~S is not a font name" FONT-DESCRIPTOR))))
    (SETQ FONT-NAME (FONT-NAME FONT))
    (LET* ((STANDARD-NAME (FUNCALL SCREEN ':FONT-NAME-FOR PURPOSE T))
	   (OLD-FONT (SYMEVAL STANDARD-NAME)))
      ;; If the screen has no entry for PURPOSE on its font alist,
      ;; :FONT-NAME-FOR returns T because we supplied that as the default.
      ;; We do that so we can avoid clobbering the font names on the
      ;; DEFAULT-FONT-ALIST.
      (COND ((NEQ STANDARD-NAME T)
	     (SET STANDARD-NAME FONT-NAME)
	     (IF (EQ PURPOSE ':DEFAULT)
		 (FUNCALL SCREEN ':CHANGE-OF-DEFAULT-FONT
			  (FONT-EVALUATE OLD-FONT) (FONT-EVALUATE FONT-NAME))
	       (FUNCALL SCREEN ':CHANGE-OF-DEFAULT-FONT NIL NIL)))))))

