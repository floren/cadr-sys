;-*- Mode:LISP; Package:Compiler; Base:8 -*-

;	** (c) Copyright 1980 Massachusetts Institute of Technology **

(DECLARE (SETQ OPEN-CODE-MAP-SWITCH T))

(DEFVAR FASD-TABLE-CURRENT-INDEX NIL "Allocating index for runtime fasl table")
(DEFVAR FASD-HASH-TABLE NIL "FASD time hash table")
(DEFVAR FASD-EVAL-HASH-TABLE NIL "FASD time hash table for self ref pointers")
(DEFVAR FASD-TYO-BUFFER-ARRAY
	(MAKE-ARRAY 512. ':TYPE 'ART-16B ':LEADER-LENGTH 1))

(DECLARE (SPECIAL 
		;FASD-TABLE
		; SI:FASL-TABLE
		   MACROLIST 
	        ;FASD-TABLE-IGNORE
		  FASL-TABLE-AREA FASD-TEMPORARY-AREA FASD-WHACK-THRESHOLD
		  FASD-STREAM FASD-SYMBOL-LIST
		  FASD-ALREADY-DUMPED-SYMBOL-LIST FASD-NEW-SYMBOL-FUNCTION
		  FASD-SYMBOL))

(DEFVAR FASD-TEMPORARY-AREA
	(MAKE-AREA ':NAME 'FASD-TEMPORARY-AREA
		   ':REGION-SIZE 200000
		   ':GC ':TEMPORARY
		   ':REPRESENTATION ':LIST))

(DEFVAR FASD-PACKAGE)	;The package in which the fasl file will presumably be loaded

;If this is the car of a list, the cdr is a form to be evaluated at load time
;The "#," reader macro uses this
(DEFVAR EVAL-AT-LOAD-TIME-MARKER (COPYSYMBOL 'EVAL-AT-LOAD-TIME-MARKER NIL))

(PUTPROP EVAL-AT-LOAD-TIME-MARKER '(EXECUTION-CONTEXT-EVAL-WARNING) 'OPTIMIZERS)
(DEFUN EXECUTION-CONTEXT-EVAL-WARNING (FORM)
  (WARN 'LOAD-TIME-EVAL ':IMPOSSIBLE "Load-time eval (#,~S) not inside quoted structure"
	 (CDR FORM))
  (EVAL (CDR FORM)))

;If this uninterned symbol is seen as the car of a list, and the cadr of the
;list is a named-lambda, it will be compiled.
(DEFVAR FUNCTIONAL-CONSTANT-MARKER (COPYSYMBOL 'FUNCTIONAL-CONSTANT-MARKER NIL))

;Make it the same as FUNCTION for when the interpreter or compiler sees it.
;Do NOT make it a displacing macro!
(FSET FUNCTIONAL-CONSTANT-MARKER
      '(MACRO LAMBDA (X) (CONS 'FUNCTION (CDR X))))

;This is an a-list of special markers that may exist in the car of a cons
;and the function to fasdump such conses.  A typical thing for such a
;a function to do is to call FASD-EVAL1 on some suitable form.
(DEFVAR FASD-MARKERS-ALIST
	(LIST (CONS EVAL-AT-LOAD-TIME-MARKER 'FASD-EVAL-AT-LOAD-TIME)
	      (CONS FUNCTIONAL-CONSTANT-MARKER 'FASD-FUNCTIONAL-CONSTANT)))

;This is an a-list of area numbers and functions to fasdump conses in that
;area.  The function is treated just as for fasd-markers.
(DEFVAR FASD-MAGIC-AREAS-ALIST NIL)

(DECLARE (SPECIAL %FASL-GROUP-CHECK 
   %FASL-GROUP-FLAG %FASL-GROUP-LENGTH 
   FASL-GROUP-LENGTH-SHIFT %FASL-GROUP-TYPE 
   FASL-OP-ERR FASL-OP-INDEX FASL-OP-SYMBOL FASL-OP-LIST 
   FASL-OP-TEMP-LIST FASL-OP-FIXED FASL-OP-FLOAT 
   FASL-OP-ARRAY FASL-OP-EVAL FASL-OP-MOVE 
   FASL-OP-FRAME FASL-OP-ARRAY-PUSH FASL-OP-STOREIN-SYMBOL-VALUE 
   FASL-OP-STOREIN-FUNCTION-CELL FASL-OP-STOREIN-PROPERTY-CELL 
   FASL-OP-STOREIN-ARRAY-LEADER
   FASL-OP-FETCH-SYMBOL-VALUE FASL-OP-FETCH-FUNCTION-CELL 
   FASL-OP-FETCH-PROPERTY-CELL FASL-OP-APPLY FASL-OP-END-OF-WHACK 
   FASL-OP-END-OF-FILE FASL-OP-SOAK FASL-OP-FUNCTION-HEADER FASL-OP-FUNCTION-END 
   FASL-OP-QUOTE-POINTER FASL-OP-S-V-CELL 
   FASL-OP-FUNCELL FASL-OP-CONST-PAGE FASL-OP-SET-PARAMETER 
   FASL-OP-INITIALIZE-ARRAY 
   FASL-OP-STRING FASL-OP-EVAL1 FASL-OP-FILE-PROPERTY-LIST
   FASL-OP-RATIONAL
   FASL-NIL FASL-EVALED-VALUE FASL-TEM1 FASL-TEM2 FASL-TEM3 
   FASL-SYMBOL-HEAD-AREA 
   FASL-SYMBOL-STRING-AREA FASL-OBARRAY-POINTER FASL-ARRAY-AREA 
   FASL-FRAME-AREA FASL-LIST-AREA FASL-TEMP-LIST-AREA 
   FASL-TABLE-WORKING-OFFSET ))

(DEFUN FASD-NIBBLE (NUMBER)
  (IF (NULL (ARRAY-PUSH FASD-TYO-BUFFER-ARRAY NUMBER))
      (PROGN
	(FASD-CLEAR-NIBBLE-BUFFER)
	(ARRAY-PUSH FASD-TYO-BUFFER-ARRAY NUMBER))))

(DEFUN FASD-CLEAR-NIBBLE-BUFFER ()
  (FUNCALL FASD-STREAM ':STRING-OUT FASD-TYO-BUFFER-ARRAY)
  (STORE-ARRAY-LEADER 0 FASD-TYO-BUFFER-ARRAY 0))


(COMMENT OUTPUT THE THINGS THAT DIVIDE A FASL FILE INTO ITS MAJOR SUBPARTS)

;OUTPUT SIXBIT /QFASL/ TO START A FASL FILE.
;ALSO CLEARS OUT THE TEMP AREA
(DEFUN FASD-START-FILE NIL
    (FASD-NIBBLE 143150)
    (FASD-NIBBLE 71660))

(DEFUN FASD-START-GROUP (FLAG LENGTH TYPE)
  (PROG ((OUT-LEN (LSH (COND ((>= LENGTH 377) 377)
			     (T LENGTH))
		       (MINUS FASL-GROUP-LENGTH-SHIFT))))
	(FASD-NIBBLE (+ %FASL-GROUP-CHECK 
			(+ (COND (FLAG %FASL-GROUP-FLAG) (T 0))
			   (+ OUT-LEN
			      TYPE))))
	(AND (>= LENGTH 377)
	     (FASD-NIBBLE LENGTH))))

(DEFUN FASD-FUNCTION-HEADER (FCTN-NAME)
  (PROG ()
	(FASD-START-GROUP NIL 0 FASL-OP-FUNCTION-HEADER)
	(FASD-CONSTANT FCTN-NAME)
	(FASD-CONSTANT '0)))

(DEFUN FASD-FUNCTION-END NIL 
  (PROG ()
	(FASD-START-GROUP NIL 0 FASL-OP-FUNCTION-END)))

(DEFUN FASD-END-WHACK NIL 
  (FASD-START-GROUP NIL 0 FASL-OP-END-OF-WHACK)
  ;; Reset fasd table, but not temporary areas
  (CLRHASH FASD-HASH-TABLE)
  (CLRHASH-EQUAL FASD-EVAL-HASH-TABLE)
  (SETQ FASD-HASH-TABLE (FOLLOW-STRUCTURE-FORWARDING FASD-HASH-TABLE))
  (SETQ FASD-EVAL-HASH-TABLE (FOLLOW-STRUCTURE-FORWARDING FASD-EVAL-HASH-TABLE))

  (SETQ FASD-TABLE-CURRENT-INDEX FASL-TABLE-WORKING-OFFSET)
  )

(DEFUN FASD-END-FILE NIL
  (PROG ()
	(FASD-START-GROUP NIL 0 FASL-OP-END-OF-FILE)
	(FASD-CLEAR-NIBBLE-BUFFER)
	(RESET-TEMPORARY-AREA FASD-TEMPORARY-AREA)	;DISPOSE OF STORAGE
	(RESET-TEMPORARY-AREA FASL-TABLE-AREA)))

(COMMENT GIVEN A SEXP DUMP A GROUP TO CONS UP THAT SEXP AND RETURN IT)

;;  This is the main function of FASD.  It takes a Lisp object and
;;     dumps it.  The second (optional) arg is a FASL-OP to use
;;     on any lists in the structure.  It returns the IDX of the object.

(DEFUN FASD-CONSTANT (S-EXP &OPTIONAL (LIST-OP FASL-OP-LIST))
 (PROG (TEM)
    (AND FASD-NEW-SYMBOL-FUNCTION			;For FASD-SYMBOLS-PROPERTIES,
	 (SYMBOLP S-EXP)				;make sure we examine all symbols in
	 (FUNCALL FASD-NEW-SYMBOL-FUNCTION S-EXP))	;the data that we dump.
    (COND ((SETQ TEM (FASD-TABLE-LOOKUP S-EXP))		;If this object already dumped,
	   (COND ((>= TEM (LSH 1 16.))
		  (FASD-START-GROUP NIL 2 FASL-OP-LARGE-INDEX)
		  (FASD-NIBBLE (LDB 2010 TEM))
		  (FASD-NIBBLE (LDB 0020 TEM)))
		 (T
		  (FASD-START-GROUP NIL 1 FASL-OP-INDEX)	;Just reference it in
		  (FASD-NIBBLE TEM)))				;the FASL TABLE.
	   (RETURN TEM))
	  ((FIXP S-EXP)
	   (FASD-FIXED S-EXP))
	  ((TYPEP S-EXP ':CHARACTER)
	   (FASD-CHARACTER S-EXP))
	  ((SMALL-FLOATP S-EXP)
	   (FASD-SMALL-FLOAT S-EXP))
	  ((FLOATP S-EXP)
	   (FASD-FLOAT S-EXP))
	  ((SYMBOLP S-EXP)
	   (FASD-SYMBOL S-EXP))
	  ((STRINGP S-EXP)
	   (RETURN (FASD-STRING S-EXP)))
	  ((ARRAYP S-EXP)
	   (RETURN (FASD-ARRAY S-EXP)))
	  ((= (SETQ TEM (%DATA-TYPE S-EXP)) DTP-FEF-POINTER)
	   (FASD-FEF S-EXP))
	  ((CONSP S-EXP)
	   (RETURN (FASD-LIST S-EXP LIST-OP)))
	  ((= TEM DTP-INSTANCE)
	   (FASD-EVAL-CONSTRUCT-CONSTANT
	     (OR (FUNCALL S-EXP ':SEND-IF-HANDLES ':FASD-FORM)
		 `(APPLY 'MAKE-INSTANCE
			 '(,(TYPEP S-EXP)
			   . ,(FUNCALL S-EXP ':RECONSTRUCTION-INIT-PLIST))))))
	  ((RATIONALP S-EXP)
	   (RETURN (FASD-RATIONAL S-EXP)))
	  ((COMPLEXP S-EXP)
	   (RETURN (FASD-COMPLEX S-EXP)))
	  (T (FERROR NIL "~S is a ~S, which is not a valid data-type for FASD-CONSTANT"
		     S-EXP (TYPEP S-EXP))))
    (RETURN (FASD-TABLE-ADD S-EXP))))

(DEFUN FASD-LIST (S-EXP LIST-OP)
  ;Determine the size of the list, and check for special markers
  (DO ((L S-EXP (CDR L))
       (N-CONSES 0 (1+ N-CONSES))
       (MARK) (DOTTED))
      ((OR (ATOM L)
	   (SETQ MARK (ASSQ (CAR L) FASD-MARKERS-ALIST))
	   (AND FASD-MAGIC-AREAS-ALIST
		(SETQ MARK (ASSQ (%AREA-NUMBER L) FASD-MAGIC-AREAS-ALIST))))
       ;Now dump that many conses and the tail if non-null
       (COND ((ZEROP N-CONSES) (FUNCALL (CDR MARK) S-EXP))
	     (T (SETQ DOTTED (NOT (NULL L)))
		(FASD-START-GROUP DOTTED 1 LIST-OP)
		(FASD-NIBBLE (IF DOTTED (1+ N-CONSES) N-CONSES))
		(DO ((L1 S-EXP (CDR L1)))
		    ((EQ L1 L))
		  (FASD-CONSTANT (CAR L1) LIST-OP))
		(COND ((NOT DOTTED))
		      ((NOT MARK) (FASD-CONSTANT L))
		      (T (FUNCALL (CDR MARK) L)))
		;FASL-OP-LIST-COMPONENT speeds things up by not bloating the fasl
		;table with conses out of the middle of lists.
		(IF (= LIST-OP FASL-OP-LIST-COMPONENT)
		    FASL-EVALED-VALUE
		    (FASD-TABLE-ADD S-EXP)))))))

(DEFUN FASD-EVAL-AT-LOAD-TIME (CONS)
  (LET ((FORM (CDR CONS)))
    (IF (AND (CONSP FORM)
	     (EQ (CAR FORM) 'SI:FLAVOR-VAR-SELF-REF-INDEX))
	(FASD-EVAL-MEMOIZED FORM T)
      (FASD-EVAL1 FORM))))

(DEFUN FASD-FUNCTIONAL-CONSTANT (CONS)
  (COND ((AND (CONSP (CADR CONS))
	      (FUNCTIONP (CADR CONS) T))
	 (IF (VARIABLE-BOUNDP COMPILER-QUEUE)
	     (FERROR NIL "Compiler is not recursive--you will lose somehow"))
	 (QC-TRANSLATE-FUNCTION (IF (ATOM (CADADR CONS)) (CADADR CONS)
				    (CAR (CADADR CONS)))
				(CADR CONS)
				'MACRO-COMPILE
				'QFASL-NO-FDEFINE))
	(T (FASD-CONSTANT (CONS 'FUNCTION (CDR CONS))))))

(DEFUN FASD-SYMBOL (SYM &AUX (STARTED-FLAG NIL))
  (MULTIPLE-VALUE-BIND (PKG-OR-STRING SHARP-FLAG)
      (SI:PKG-PRINTING-PREFIX SYM FASD-PACKAGE)
    (WHEN PKG-OR-STRING
      ;; Here if need a prefix of any kind.
      (SETQ STARTED-FLAG T)
      (FASD-START-GROUP SHARP-FLAG 1 FASL-OP-PACKAGE-SYMBOL)
      ;; This nibble is 402 if should ignore local nicknames, else 2.
      (FASD-NIBBLE
	(IF (AND (NOT (STRINGP PKG-OR-STRING))
		 (ASSOC (PACKAGE-PREFIX-PRINT-NAME PKG-OR-STRING)
			(DONT-OPTIMIZE (SI:PKG-REFNAME-ALIST PACKAGE))))
	    402 2))
      (FASD-CONSTANT (IF (STRINGP PKG-OR-STRING) PKG-OR-STRING
		       (PACKAGE-PREFIX-PRINT-NAME PKG-OR-STRING)))))
  (IF STARTED-FLAG (FASD-CONSTANT (STRING SYM)) ;If there was a prefix
      (FASD-WRITE-STRING SYM FASL-OP-SYMBOL))) ;If uninterned or no prefix needed

;; This is expected to do the FASD-TABLE-ADD itself,
;; since FASD-ARRAY has to do so.
(DEFUN FASD-STRING (STRING)
  (IF (OR (ARRAY-HAS-LEADER-P STRING)
	  (> (ARRAY-LENGTH STRING) (LSH 1 16.)))
      (FASD-ARRAY STRING)
    (FASD-WRITE-STRING STRING FASL-OP-STRING)
    (FASD-TABLE-ADD STRING)))

(DEFUN FASD-WRITE-STRING (OBJECT GROUP-TYPE &AUX (STRING (STRING OBJECT)))
  (PROG (LENGTH (I 0) C0 C1)
	(SETQ LENGTH (STRING-LENGTH STRING))
	(FASD-START-GROUP NIL (CEILING LENGTH 2) GROUP-TYPE)
	L
	(AND (>= I LENGTH) (RETURN NIL))
	(SETQ C0 (AR-1 STRING I)
	      C1 (COND ((= (1+ I) LENGTH) 200)
		       (T (AR-1 STRING (1+ I)))))
	(FASD-NIBBLE (+ (LSH C1 8) C0))
	(SETQ I (+ I 2))
	(GO L)))

(DEFUN FASD-FIXED (N)
 (PROG (NMAG NLENGTH)
	(SETQ NMAG (ABS N)
	      NLENGTH (CEILING (HAULONG NMAG) 16.))
	(FASD-START-GROUP (< N 0) NLENGTH FASL-OP-FIXED)
	(DO ((POS (* 20 (1- NLENGTH)) (- POS 20))
	     (C NLENGTH (1- C)))
	    ((ZEROP C))
	    (FASD-NIBBLE (LDB (+ (LSH POS 6) 20) NMAG)))))

(DEFUN FASD-CHARACTER (N)
 (PROG (NMAG NLENGTH)
	(SETQ NMAG (ABS N)
	      NLENGTH (CEILING (HAULONG NMAG) 16.))
	(FASD-START-GROUP (< N 0) NLENGTH FASL-OP-CHARACTER)
	(DO ((POS (* 20 (1- NLENGTH)) (- POS 20))
	     (C NLENGTH (1- C)))
	    ((ZEROP C))
	    (FASD-NIBBLE (LDB (+ (LSH POS 6) 20) NMAG)))))

;(DEFUN FASD-FIXED (N)
; (PROG ()
;	(AND (BIGP N) (FERROR NIL "FASL-OP-FIXED doesn't win for bignums yet"))
;	(FASD-START-GROUP (< N 0) 2 FASL-OP-FIXED)
;	(AND (< N 0) (SETQ N (%24-BIT-DIFFERENCE 0 N))) ;Don't use ABS, see FASL-OP-FIXED
;	(FASD-NIBBLE (LOGAND (LSH N -20) 177777))
;	(FASD-NIBBLE (LOGAND N 177777))))

(DEFUN FASD-FLOAT (N)
 (PROG ()
        (FASD-START-GROUP NIL 3 FASL-OP-FLOAT)
	(FASD-NIBBLE (%P-LDB-OFFSET 1013 N 0))
	(FASD-NIBBLE (DPB (%P-LDB-OFFSET 0010 N 0) 1010 (%P-LDB-OFFSET 2010 N 1)))
	(FASD-NIBBLE (%P-LDB-OFFSET 0020 N 1))))

(DEFUN FASD-SMALL-FLOAT (N)
 (PROG ()
    (SETQ N (%MAKE-POINTER DTP-FIX N))  ;So that LDB's will work.
    (FASD-START-GROUP T 2 FASL-OP-FLOAT)
    (FASD-NIBBLE (LDB 2010 N))
    (FASD-NIBBLE (LDB 0020 N))))

(DEFUN FASD-RATIONAL (RAT)
  (FASD-START-GROUP NIL 0 FASL-OP-RATIONAL)
  (FASD-CONSTANT (NUMERATOR RAT))
  (FASD-CONSTANT (DENOMINATOR RAT))
  (FASD-TABLE-ADD RAT))

(DEFUN FASD-COMPLEX (COMPLEX)
  (FASD-START-GROUP NIL 0 FASL-OP-COMPLEX)
  (FASD-CONSTANT (REALPART COMPLEX))
  (FASD-CONSTANT (IMAGPART COMPLEX))
  (FASD-TABLE-ADD COMPLEX))

(DEFUN FASD-FEF (FEF &AUX Q-COUNT NON-Q-COUNT)
    (SETQ Q-COUNT (%STRUCTURE-BOXED-SIZE FEF)
	  NON-Q-COUNT (- (%STRUCTURE-TOTAL-SIZE FEF) Q-COUNT))
    (FASD-START-GROUP NIL 3 FASL-OP-FRAME)
    (FASD-NIBBLE Q-COUNT)
    (FASD-NIBBLE NON-Q-COUNT)
    (FASD-NIBBLE (+ Q-COUNT (LSH NON-Q-COUNT 1)))
    (DO ((I 0 (1+ I)))
	((= I Q-COUNT))
	(FASD-FEF-Q FEF I))
    (DO ((I Q-COUNT (1+ I)))
	((= I (+ Q-COUNT NON-Q-COUNT)))
      (FASD-NIBBLE (%P-LDB-OFFSET %%Q-LOW-HALF FEF I))
      (FASD-NIBBLE (%P-LDB-OFFSET %%Q-HIGH-HALF FEF I)))
    NIL)

(DEFUN FASD-FEF-Q (FEF I &AUX DATTP PTR PTR1 OFFSET (TYPE 0))
    (SETQ DATTP (%P-LDB-OFFSET %%Q-DATA-TYPE FEF I))
    (SETQ TYPE (LSH (%P-LDB-OFFSET %%Q-CDR-CODE FEF I) 6))
    (COND ((OR (= DATTP DTP-EXTERNAL-VALUE-CELL-POINTER)
	       (= DATTP DTP-LOCATIVE))
	   (SETQ PTR1 (%P-CONTENTS-AS-LOCATIVE-OFFSET FEF I))
	   (SETQ PTR (%FIND-STRUCTURE-HEADER PTR1))
	   (SETQ OFFSET (%POINTER-DIFFERENCE PTR1 PTR))
	   (AND (> OFFSET 17)
		(FERROR NIL "~O is too great an offset into atom while fasdumping FEF ~S"
		       OFFSET (%P-CONTENTS-OFFSET FEF %FEFHI-FCTN-NAME)))
	   (FASD-CONSTANT PTR)
	   (AND (= DATTP DTP-EXTERNAL-VALUE-CELL-POINTER)
		(SETQ TYPE (+ TYPE 20)))
	   (AND (= DATTP DTP-LOCATIVE)
		(SETQ TYPE (+ TYPE 400)))
	   ;; LOW 4 BITS OF TYPE ARE OFFSET TO ADD TO POINTER TO MAKE IT POINT AT VALUE CELL, ETC.
	   (SETQ TYPE (+ TYPE OFFSET)))
          ((= DATTP DTP-HEADER)
           (FASD-CONSTANT (%P-LDB-OFFSET %%Q-POINTER FEF I)))
	  ((= DATTP DTP-SELF-REF-POINTER)
	   (INCF TYPE 1000)
	   (MULTIPLE-VALUE-BIND (SYMBOL FLAG)
	       (SI:FLAVOR-DECODE-SELF-REF-POINTER (SI:FEF-FLAVOR-NAME FEF)
						  (%P-LDB-OFFSET %%Q-POINTER FEF I))
	     (FASD-EVAL1 `(SI:FLAVOR-VAR-SELF-REF-INDEX
			    ',(IF FLAG
				  `(,(SI:FEF-FLAVOR-NAME FEF)
				    T ,SYMBOL)
				`(,(SI:FEF-FLAVOR-NAME FEF) ,SYMBOL))))))
          (T (FASD-CONSTANT (%P-CONTENTS-OFFSET FEF I))))
    (FASD-NIBBLE TYPE))

(DEFUN FASD-INTERNALP (INTERNAL MAIN &AUX TEM)
  MAIN
  (AND (SYMBOLP INTERNAL)
       (> (SETQ TEM (STRING-LENGTH INTERNAL)) 18.)
       (SETQ TEM (STRING-REVERSE-SEARCH-CHAR #/- INTERNAL TEM))
       (STRING-EQUAL INTERNAL "-INTERNAL-LAMBDA" (- TEM 16.) 0 TEM)))

;DOES ITS OWN FASD-TABLE ADDING SINCE IT HAS TO BE DONE IN THE MIDDLE
;OF THIS FUNCTION, AFTER THE FASL-OP-ARRAY BUT BEFORE THE INITIALIZATION DATA.
(DEFUN FASD-ARRAY (ARRAY &AUX DIMLIST SIZE OBJECTIVE-P FAKE-ARRAY RETVAL NSP)
    (SETQ DIMLIST (ARRAYDIMS ARRAY)
	  NSP (NAMED-STRUCTURE-P ARRAY))
    (SETQ SIZE (APPLY (FUNCTION TIMES) (CDR DIMLIST))
	  OBJECTIVE-P (NULL (CDR (ASSQ (CAR DIMLIST) ARRAY-BITS-PER-ELEMENT))))
    (COND ((NOT OBJECTIVE-P)
	   (LET ((EPQ (CDR (ASSQ (CAR DIMLIST) ARRAY-ELEMENTS-PER-Q))))
	     ;; In this case, number of halfwords
	     (SETQ SIZE (IF (PLUSP EPQ) (CEILING (* SIZE 2) EPQ) (* SIZE 2 (MINUS EPQ)))))))
    (FASD-START-GROUP NIL 0 (COND (OBJECTIVE-P FASL-OP-INITIALIZE-ARRAY)
				  (T FASL-OP-INITIALIZE-NUMERIC-ARRAY)))
    (FASD-START-GROUP NSP 0 FASL-OP-ARRAY)
    (FASD-CONSTANT (NTH (%AREA-NUMBER ARRAY) AREA-LIST))	;AREA
    (FASD-CONSTANT (CAR DIMLIST))				;TYPE-SYMBOL
    (FASD-CONSTANT (CDR DIMLIST) FASL-OP-TEMP-LIST)		;DIMENSIONS
    (FASD-CONSTANT NIL)					        ;DISPLACED-P. FOR NOW
    (FASD-CONSTANT						;LEADER
     (COND ((ARRAY-HAS-LEADER-P ARRAY)
	    (DO ((I 0 (1+ I))
		 (LIST NIL)
		 (LIM (ARRAY-LEADER-LENGTH ARRAY)))
		((>= I LIM) LIST)
	      (PUSH (ARRAY-LEADER ARRAY I) LIST)))
	   (T NIL))
     FASL-OP-TEMP-LIST)
    (FASD-CONSTANT NIL)					        ;INDEX-OFFSET FOR NOW
    (AND NSP
	 (FASD-CONSTANT T))					;NAMED-STRUCTURE-P
    ;; Now that six values have been given, the group is over.
    (SETQ RETVAL (FASD-TABLE-ADD ARRAY))
    ;; Next, continue to initialize the array.
    (FASD-CONSTANT SIZE)
    (SETQ FAKE-ARRAY
	  (MAKE-ARRAY SIZE
		      ':TYPE (COND (OBJECTIVE-P ART-Q) (T ART-16B))
		      ':DISPLACED-TO ARRAY))
    (COND (OBJECTIVE-P
	   (DO I 0 (1+ I) (>= I SIZE)
	       (IF (LOCATION-BOUNDP (AP-1-FORCE ARRAY I))
		   (FASD-CONSTANT (AREF FAKE-ARRAY I))
		 (FASD-NIBBLE (+ %FASL-GROUP-CHECK FASL-OP-NULL-ARRAY-ELEMENT)))))
	  (T
	   (DO I 0 (1+ I) (>= I SIZE)
	     (FASD-NIBBLE (AREF FAKE-ARRAY I)))))
    (RETURN-ARRAY (PROG1 FAKE-ARRAY (SETQ FAKE-ARRAY NIL)))
    RETVAL)

(COMMENT LOW LEVEL ROUTINES TO DUMP GROUPS TO DEPOSIT THINGS IN VARIOUS PLACES)

(DEFUN FASD-SET-PARAMETER (PARAM VAL)
  param val
  (FORMAT t "The function FASD-SET-PARAMETER is probably obsolete, please send a bug report if you end up calling it.")
  (break 'foo t)
  (comment 
    (PROG (C-VAL)
	  (COND ((NULL (SETQ C-VAL (ASSQ PARAM FASD-TABLE)))
		 (FERROR NIL "~S is an unknown FASL parameter" PARAM)))
	  (COND ((EQUAL VAL (CDR C-VAL))(RETURN NIL)))
	  (FASD-START-GROUP NIL 0 FASL-OP-SET-PARAMETER)
	  (FASD-CONSTANT PARAM)
	  (FASD-CONSTANT VAL)
	  )))

(DEFUN FASD-STORE-ARRAY-LEADER (VALUE ARRAY SUBSCR)
   (PROG ()
	(FASD-START-GROUP NIL 3 FASL-OP-STOREIN-ARRAY-LEADER)
	(FASD-NIBBLE ARRAY)
	(FASD-NIBBLE SUBSCR)
	(FASD-NIBBLE VALUE)	;NOTE nibbles not in same order as STORE-ARRAY-LEADER!
	(RETURN 0)))


(DEFUN FASD-STORE-FUNCTION-CELL (SYM IDX)	;IDX AN FASD-TABLE INDEX THAT HAS
   (PROG ()			;STUFF DESIRED TO STORE.
	(FASD-START-GROUP NIL 1 FASL-OP-STOREIN-FUNCTION-CELL)
	(FASD-NIBBLE IDX)
	(FASD-CONSTANT SYM)
	(RETURN 0)))

(FSET 'FASD-STOREIN-FUNCTION-CELL (FUNCTION FASD-STORE-FUNCTION-CELL))

(DEFUN FASD-STORE-VALUE-CELL (SYM IDX)
   (PROG ()
	(FASD-START-GROUP NIL 1 FASL-OP-STOREIN-SYMBOL-VALUE)
	(FASD-NIBBLE IDX)
	(FASD-CONSTANT SYM)
	(RETURN 0)))

(DEFUN FASD-STORE-PROPERTY-CELL (SYM IDX)
   (PROG ()
	(FASD-START-GROUP NIL 1 FASL-OP-STOREIN-PROPERTY-CELL)
	(FASD-NIBBLE IDX)
	(FASD-CONSTANT SYM)
	(RETURN 0)))

(DEFUN FASD-FILE-PROPERTY-LIST (PLIST)
  (FASD-ATTRIBUTES-LIST PLIST NIL))

(DEFUN FASD-ATTRIBUTES-LIST (PLIST &OPTIONAL (ADD-FASD-DATA T))
  (WHEN ADD-FASD-DATA
    (MULTIPLE-VALUE-BIND (MAJOR MINOR)
	(SI:GET-SYSTEM-VERSION "System")
      (SETQ PLIST (LIST* ':FASD-DATA
			 (LIST USER-ID
			       SI:LOCAL-PRETTY-HOST-NAME
			       (TIME:GET-UNIVERSAL-TIME)
			       MAJOR MINOR
			       '(:NEW-DESTINATIONS T))
			 PLIST))))
  (LET ((P (GET (LOCF PLIST) ':PACKAGE)))
    (AND P (SETQ FASD-PACKAGE (PKG-FIND-PACKAGE P))))
  (FASD-START-GROUP NIL 0 FASL-OP-FILE-PROPERTY-LIST)
  ;Put package prefixes on everything in the plist since it will be loaded in
  ;the wrong package.  This way the symbols in the plist will always be loaded
  ;into exactly the same package they were dumped from, while the rest of the
  ;symbols in the file will be free to follow the usual rules for intern.
  (LET ((FASD-PACKAGE NIL))
    (FASD-CONSTANT PLIST)))

;THE OLD WAY OF DOING EVAL (FASD-EVAL) UNFORTUNATELY DOES NOT NEST PROPERLY.  IE
; CAN NOT BE USED TO LOAD INTO A FEF, BECAUSE THE LOADER IS EXPECTING TO SEE
; A SINGLE NEXT-VALUE.  SO THIS IS THE WAY IT PROBABLY SHOULD HAVE BEEN DONE IN
; THE FIRST PLACE..
(DEFUN FASD-EVAL1 (SEXP &OPTIONAL TEMPORARY)
  (PROG ()
	(FASD-START-GROUP NIL 0 FASL-OP-EVAL1)
	(FASD-CONSTANT SEXP
		       (IF TEMPORARY FASL-OP-TEMP-LIST FASL-OP-LIST))
	;(RETURN (FASD-TABLE-ADD FASD-TABLE-IGNORE))
	(RETURN (FASD-TABLE-NEXT-INDEX))))

(DEFUN FASD-EVAL-CONSTRUCT-CONSTANT (SEXP)
  "Fasdump a group to eval FORM, but let our caller record it in the fasd table.
He will record the index we use under the object that FORM
is supposed to reconstruct at load time."
  (FASD-START-GROUP NIL 0 FASL-OP-EVAL1)
  (FASD-CONSTANT SEXP))

(DEFUN FASD-EVAL-MEMOIZED (FORM &OPTIONAL TEMPORARY &AUX TEM)
  (COND ((SETQ TEM (FASD-EVAL-TABLE-LOOKUP FORM))	;If this object already dumped,
	 (COND ((>= TEM (LSH 1 16.))
		(FASD-START-GROUP NIL 2 FASL-OP-LARGE-INDEX)
		(FASD-NIBBLE (LDB 2010 TEM))
		(FASD-NIBBLE (LDB 0020 TEM)))
	       (T
		(FASD-START-GROUP NIL 1 FASL-OP-INDEX)	;Just reference it in
		(FASD-NIBBLE TEM)))		;the FASL TABLE.
	 TEM)
	(T (LET ((INDEX (FASD-EVAL1 FORM TEMPORARY)))
	     (FASD-EVAL-TABLE-ADD FORM INDEX)
	     INDEX))))
 
(COMMENT ROUTINES TO MANIPULATE THE FASD TABLE)

;FASD simulates keeping a table that looks just like the one FASLOAD will keep.
;FASD uses it to refer back to atoms which have been seen before,
;so that no atom need be interned twice.

(defun fasd-table-next-index nil
  (prog1 fasd-table-current-index
	 (setq fasd-table-current-index (1+ fasd-table-current-index))))

(defun fasd-table-add (data)
  (let ((index (fasd-table-next-index)))
    (puthash data index fasd-hash-table)
    index))

(defun fasd-table-lookup (data)
  (cond ((numberp data) nil)
	(t (gethash data fasd-hash-table))))

;The EVAL hash table is used to record data constructed by evaluations at load time,
;in case we want to reuse the data instead of computing them twice.
(DEFUN FASD-EVAL-TABLE-LOOKUP (DATA)
  (GETHASH-EQUAL DATA FASD-EVAL-HASH-TABLE))

(DEFUN FASD-EVAL-TABLE-ADD (DATA INDEX)
  (PUTHASH-EQUAL DATA INDEX FASD-EVAL-HASH-TABLE))

;Set one of the parameters at the front of the FASD-TABLE, as in
;(FASD-TABLE-SET FASL-SYMBOL-STRING-AREA PN-STRING)
(DEFUN FASD-TABLE-SET (PARAM DATA)
  param data
  (FORMAT t "The function FASD-TABLE-SET is probably obsolete, please send a bug report if you end up calling it.")
  (break 'fasd-table-set t)
  (comment
    (AS-1 DATA FASD-TABLE PARAM)))

(DEFUN FASD-TABLE-LENGTH ()
  FASD-TABLE-CURRENT-INDEX)

(DEFUN FASD-INITIALIZE (&AUX SI:FASL-TABLE)
    (OR COMPILER-PROCESS-LOCK
	(FERROR NIL "FASD-INITIALIZE must be called with the compiler locked."))
    (SI:MAKE-AREA-TEMPORARY FASL-TABLE-AREA)
    (RESET-TEMPORARY-AREA FASD-TEMPORARY-AREA)
    (RESET-TEMPORARY-AREA FASL-TABLE-AREA)
    (SETQ FASD-NEW-SYMBOL-FUNCTION NIL)
    (SETQ FASD-PACKAGE PACKAGE)
    (SETQ FASD-HASH-TABLE (MAKE-HASH-TABLE ':SIZE 40000))
    (SETQ FASD-EVAL-HASH-TABLE (MAKE-EQUAL-HASH-TABLE ':SIZE 400))
    (SETQ FASD-TABLE-CURRENT-INDEX FASL-TABLE-WORKING-OFFSET)
							;LEADER FOR FILLING
    (STORE-ARRAY-LEADER 0 FASD-TYO-BUFFER-ARRAY 0)
    )

(COMMENT DUMP FORMS TO BE EVALUATED WITH HAIR FOR DEFUN AND SETQ)

;Dump a group to evaluate a given form and return its value.
;If OPTIMIZE is set, SETQ and DEFUN are handled specially,
;in a way appropriate for the top level of fasdump or qc-file.
(DEFUN FASD-FORM (FORM &OPTIONAL OPTIMIZE &AUX FUNCTION)
  "Put something to execute FORM into the QFASL file being written.
If OPTIMIZE is true, many common types of forms are handled specially,
including SETQ, DEFF, DEFUN, etc.  In particular, (DEFUN FOO)
is processed by dumping FOO's current function definition."
   (COND ((OR (MEMQ FORM '(T NIL))
	      (STRINGP FORM)
	      (NUMBERP FORM))
	  (FASD-CONSTANT FORM))
	 ((SYMBOLP FORM) (FASD-SYMEVAL FORM))
	 ((ATOM FORM) (FASD-RANDOM-FORM FORM))
	 ((NOT (SYMBOLP (CAR FORM))) (FASD-RANDOM-FORM FORM))
	 ((EQ (SETQ FUNCTION (AND (FBOUNDP (CAR FORM)) (FSYMEVAL (CAR FORM))))
	      #'QUOTE)
	  (FASD-CONSTANT (CADR FORM)))
	 ((NOT OPTIMIZE)
	  (FASD-RANDOM-FORM FORM))
	 ((EQ FUNCTION #'SETQ)
	  (FASD-SETQ FORM))
	 ((EQ FUNCTION #'DEFF)
	  (FASD-STORE-FUNCTION-CELL (CADR FORM) (FASD-FORM (CADDR FORM))))
         ((AND (EQ FUNCTION #'FSET-CAREFULLY)
               (CONSP (CADR FORM))
               (EQ (CAADR FORM) 'QUOTE))
          (FASD-STORE-FUNCTION-CELL (CADADR FORM) (FASD-FORM (CADDR FORM))))
	 ((EQ FUNCTION #'DEFUN)
	  (FASD-FUNCTION (CADR FORM)
			 (FDEFINITION (SI:UNENCAPSULATE-FUNCTION-SPEC (CADR FORM)))))
	 ;; Does this happen?  It does not, for compilation of top-level DECLAREs.
	 ;; Let's see if anyone misses it.  RELDMP has something similar.
;         ((EQ FUNCTION #'DECLARE)
;          (MAPC (FUNCTION FASD-DECLARATION) (CDR FORM)))
	 (T (FASD-RANDOM-FORM FORM))))

;(DEFUN FASD-DECLARATION (DCL)
;    (AND (MEMQ (CAR DCL) '(SPECIAL UNSPECIAL :SPECIAL :UNSPECIAL))
;         (FASD-FORM DCL)))

;DUMP SOMETHING TO EVAL SOME RANDOM FORM (WHICH IS THE ARGUMENT).
(DEFUN FASD-RANDOM-FORM (FRM)
    (FASD-EVAL1 FRM))
	
;GIVEN THE BODY OF A DEFUN, DUMP STUFF TO PERFORM IT.
(DEFUN FASD-FUNCTION (FUNCTION DEFINITION)
  (FASD-STORE-FUNCTION-CELL FUNCTION (FASD-CONSTANT DEFINITION)))

;GIVEN THE BODY OF A SETQ, DUMP STUFF TO PERFORM IT.
(DEFUN FASD-SETQ (SETQ-FORM)
  (DO ((PAIRS (CDR SETQ-FORM) (CDDR PAIRS)))
      ((NULL PAIRS))
    (CHECK-ARG PAIRS (ATOM (CAR PAIRS)) "a SETQ form")
    (FASD-STORE-VALUE-CELL (CAR PAIRS) (FASD-FORM (CADR PAIRS)))))

(DEFUN FASD-SYMEVAL (SEXP)
  (PROG ()
	(FASD-START-GROUP NIL 0 FASL-OP-FETCH-SYMBOL-VALUE)
	(FASD-CONSTANT SEXP)
	;(RETURN (FASD-TABLE-ADD FASD-TABLE-IGNORE))
	(return (fasd-table-next-index))))

(DEFUN FASD-SYMBOL-VALUE (FILENAME SYMBOL)
  "Write a QFASL file named FILENAME containing SYMBOL's value.
Loading the file will set the symbol back to the same value."
  (WITH-OPEN-FILE (FASD-STREAM (FS:MERGE-PATHNAME-DEFAULTS FILENAME FS:LOAD-PATHNAME-DEFAULTS
							   ':QFASL)
			       '(:WRITE :FIXNUM))
    (LOCKING-RESOURCES
      (FASD-INITIALIZE)
      (FASD-START-FILE)
      (FASD-ATTRIBUTES-LIST NIL)
      (FASD-FORM `(SETQ ,SYMBOL ',(SYMEVAL SYMBOL)))
      (FASD-END-WHACK)
      (FASD-END-FILE))))

(DEFUN DUMP-FORMS-TO-FILE (FILENAME FORMS-LIST &OPTIONAL ATTRIBUTE-LIST)
  "Write a QFASL file named FILENAME which, when loaded, will execute the forms in FORMS-LIST.
ATTRIBUTE-LIST is a file attribute list which controls, among other things,
what package the file is dumped and loaded in."
  (WITH-OPEN-FILE (FASD-STREAM (FS:MERGE-PATHNAME-DEFAULTS FILENAME FS:LOAD-PATHNAME-DEFAULTS
							   ':QFASL)
			       '(:WRITE :FIXNUM))
    (LET ((FASD-PACKAGE PACKAGE))
      (LOCKING-RESOURCES
	(FASD-INITIALIZE)
	(FASD-START-FILE)
	(FASD-ATTRIBUTES-LIST ATTRIBUTE-LIST)
	(DOLIST (FORM FORMS-LIST)
	  (IF ( (FASD-TABLE-LENGTH) QC-FILE-WHACK-THRESHOLD)
	      (FASD-END-WHACK))
	  (FASD-FORM FORM))
	(FASD-END-WHACK)
	(FASD-END-FILE)))))

(DEFUN FASD-FONT (FONT)
  "Write the font FONT into a QFASL file named SYS: FONTS; name-of-font QFASL."
  (FASD-SYMBOL-VALUE (FS:MAKE-PATHNAME ':HOST "SYS"
				       ':DIRECTORY "FONTS"
				       ':NAME (STRING FONT))
		     FONT))

(DEFUN FASD-FILE-SYMBOLS-PROPERTIES (FILENAME SYMBOLS PROPERTIES
                                              DUMP-VALUES-P DUMP-FUNCTIONS-P
                                              NEW-SYMBOL-FUNCTION)
  "Write a QFASL file named FILENAME containing data on SYMBOLS.
The data can include the symbols' values, function definitions, and properties.
PROPERTIES is a list of which propertis should be dumped.
DUMP-VALUES-P says whether to dump their values.
DUMP-FUNCTIONS-P says whether to dump their function definitions.
NEW-SYMBOL-FUNCTION is a function to call whenever a new symbol
not previously seen is found in a value being dumped.  The function
can cause the new symbol's data to be dumped like the specified symbols.
When the NEW-SYMBOL-FUNCTION is called, FASD-SYMBOL-LIST will be a list
of symbols waiting to be dumped, and FASD-ALREADY-DUMPED-SYMBOL-LIST a
list of those already dumped.  To make a new symbol be dumped, push it
on the former if it is not in either of those two."
  (WITH-OPEN-FILE (FASD-STREAM (FS:MERGE-PATHNAME-DEFAULTS FILENAME FS:LOAD-PATHNAME-DEFAULTS
							   ':QFASL)
			       '(:WRITE :FIXNUM))
    (LOCKING-RESOURCES
      (FASD-INITIALIZE)
      (FASD-START-FILE)
      (FASD-ATTRIBUTES-LIST NIL)
      (FASD-SYMBOLS-PROPERTIES SYMBOLS PROPERTIES DUMP-VALUES-P
			       DUMP-FUNCTIONS-P NEW-SYMBOL-FUNCTION)
      (FASD-END-WHACK)
      (FASD-END-FILE))))

;Take each symbol in SYMBOLS and do a FASD-SYMBOL-PROPERTIES on it.
;The symbols already thus dumped are put on FASD-ALREADY-DUMPED-SYMBOL-LIST.
;The NEW-SYMBOL-FUNCTION can add more symbols to FASD-SYMBOL-LIST
;to cause them to be dumped as well.
(DEFUN FASD-SYMBOLS-PROPERTIES (SYMBOLS PROPERTIES DUMP-VALUES
					DUMP-FUNCTIONS NEW-SYMBOL-FUNCTION)
    (DO ((FASD-SYMBOL-LIST SYMBOLS)
	 (FASD-ALREADY-DUMPED-SYMBOL-LIST)
	 (SYMBOL))
	((NULL FASD-SYMBOL-LIST))
	(SETQ SYMBOL (CAR FASD-SYMBOL-LIST))
	(POP FASD-SYMBOL-LIST)
	(PUSH SYMBOL FASD-ALREADY-DUMPED-SYMBOL-LIST)
	(FASD-SYMBOL-PROPERTIES SYMBOL PROPERTIES
				DUMP-VALUES DUMP-FUNCTIONS NEW-SYMBOL-FUNCTION)))

;Dump into the FASD file the properties of SYMBOL in PROPERTIES,
;and the value if DUMP-VALUES, and the function cell if DUMP-FUNCTIONS.
;NEW-SYMBOL-FUNCTION will be called on appropriate symbols in the
;structures which are dumped.
(DEFUN FASD-SYMBOL-PROPERTIES (SYMBOL PROPERTIES DUMP-VALUES
                                      DUMP-FUNCTIONS NEW-SYMBOL-FUNCTION &AUX TEM)
	(AND DUMP-VALUES
             (BOUNDP SYMBOL)
	     (FASD-STORE-VALUE-CELL SYMBOL
				    (FASD-CONSTANT-TRACING-SYMBOLS (SYMEVAL SYMBOL)
								   NEW-SYMBOL-FUNCTION)))
	(AND DUMP-FUNCTIONS
             (FBOUNDP SYMBOL)
	     (FASD-STORE-VALUE-CELL SYMBOL
				    (FASD-CONSTANT-TRACING-SYMBOLS (FSYMEVAL SYMBOL)
								   NEW-SYMBOL-FUNCTION)))
	(MAPC (FUNCTION (LAMBDA (PROP)
		  (AND (SETQ TEM (GET SYMBOL PROP))	;IF THIS ATOM HAS THIS PROPERTY,
		       (PROGN				;DUMP A DEFPROP TO BE EVALLED.
			 (FASD-START-GROUP NIL 0 FASL-OP-EVAL1)
			 (PROGN
			   (FASD-START-GROUP NIL 1 FASL-OP-LIST)
			   (FASD-NIBBLE 4)	;4 IS LENGTH OF THE DEFPROP FORM.
			   (FASD-CONSTANT 'DEFPROP)	;DON'T USE FASD-FORM, SINCE WE
			   (FASD-CONSTANT SYMBOL)	;WANT TO DETECT NEW SYMBOLS IN THE
			   (FASD-CONSTANT-TRACING-SYMBOLS TEM NEW-SYMBOL-FUNCTION)
			   (FASD-CONSTANT PROP)		;VALUE OF THE PROPERTY.
			   (FASD-TABLE-NEXT-INDEX))
			 (FASD-TABLE-NEXT-INDEX)))))
	      PROPERTIES))

(DEFUN FASD-CONSTANT-TRACING-SYMBOLS (OBJECT FASD-NEW-SYMBOL-FUNCTION)
    (FASD-CONSTANT OBJECT))

;Use this as the NEW-SYMBOL-FUNCTION, for nice results:
;All the substructures of the structures being dumped are also dumped.
(DEFUN FASD-SYMBOL-PUSH (SYMBOL)
    (OR (MEMQ SYMBOL FASD-SYMBOL-LIST)
        (MEMQ SYMBOL FASD-ALREADY-DUMPED-SYMBOL-LIST)
        (PUSH SYMBOL FASD-SYMBOL-LIST)))
