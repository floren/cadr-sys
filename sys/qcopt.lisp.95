;;; -*- Mode:LISP; Package:COMPILER; Base:8 -*-
;This file contains the source-level optimizers of the Lisp machine compiler.

;	** (c) Copyright 1980 Massachusetts Institute of Technology **

;;     "This is insane.  What we clearly want to do is not completely
;;      clear, and is rooted in NCOMPLR."   -- BSG/Dissociated Press.

;Convenient way of computing function to expand into from original function.
(DEFUN TRANSLATED-FUNCTION (FORM FUNCTION-ALIST)
  (CDR (ASSQ (CAR FORM) FUNCTION-ALIST)))

(DEFUN FOLD-CONSTANTS (FORM)
  "Replace an expression by its value...if it evaluates ok."
  (LET (VALUE ERRORFLAG)
    (SETF (VALUES VALUE ERRORFLAG)
	  (CATCH-ERROR (MULTIPLE-VALUE-LIST (EVAL FORM))))
    (COND (ERRORFLAG
	   (WARN 'CONSTANT-FOLDING ':ERROR
		 "Error during constant-folding on expression ~S" FORM)
	   FORM)
	  (T
	   (COND ((= (LENGTH VALUE) 1)
		  `',(FIRST VALUE))
		 (T (CONS 'VALUES
			  (MAPCAR #'(LAMBDA (ELT) `',ELT) VALUE)))))))) ; Get multiple-values

;;; Convert DOs into PROGs.

(ADD-OPTIMIZER DO DOEXPANDER)
(ADD-OPTIMIZER DO-NAMED DOEXPANDER)
(ADD-OPTIMIZER DO* DOEXPANDER)
(ADD-OPTIMIZER DO*-NAMED DOEXPANDER)

(DEFUN DOEXPANDER (X)
  (LET ((PROGNAME) (PROGREST) SERIAL DECLS)
    (SETQ PROGREST
      (PROG (DOSPECS ENDTEST ENDVALS TAG1 TAG3 PVARS STEPDVARS ONCE)
            (COND ((MEMQ (CAR X) '(DO-NAMED :DO-NAMED))
                   (SETQ PROGNAME (CADR X))
                   (SETQ X (CDDR X)))
		  ((MEMQ (CAR X) '(DO*-NAMED :DO*-NAMED))
		   (SETQ PROGNAME (CADR X))
		   (SETQ X (CDDR X))
		   (SETQ SERIAL T))
		  ((MEMQ (CAR X) '(DO* :DO*))
		   (SETQ X (CDR X))
		   (SETQ SERIAL T))
                  (T (SETQ X (CDR X))))			;Get rid of "DO".
            (COND ((AND (CAR X) (ATOM (CAR X)))
                   (SETQ  DOSPECS `((,(CAR X) ,(CADR X) ,(CADDR X)))
                          ENDTEST (CAR (SETQ X (CDDDR X)))
                          ENDVALS NIL))
                  (T (SETQ DOSPECS (CAR X))
                     (SETQ X (CDR X))
                     (COND ((CAR X)
                            (SETQ ENDTEST (CAAR X)
                                  ENDVALS (AND (OR (CDDAR X)
                                                   (CADAR X))
                                               (CDAR X))))
                           (T (SETQ ONCE T)))))
            (SETQ X (CDR X))
            (SETQ DOSPECS (REVERSE DOSPECS)); Do NOT use NREVERSE, or you will destroy
					    ; every macro definition in sight!! -DLW
            ;; DOVARS has new-style list of DO variable specs,
            ;; ENDTEST has the end test form,
            ;; ENDVALS has the list of forms to be evaluated when the end test succeeds,
            ;; ONCE is T if this is a DO-once as in (DO ((VAR)) () ...),
            ;; X has the body.
	    (SETF (VALUES X DECLS)
		  (EXTRACT-DECLARATIONS-RECORD-MACROS X))
            ;; Now process the variable specs.
            (DO X DOSPECS (CDR X) (NULL X)
                (COND ((ATOM (CAR X))
		       (PUSH (CAR X) PVARS))
                      ((OR (> (LENGTH (CAR X)) 3) (NOT (ATOM (CAAR X))))
		       (WARN 'BAD-BINDING-LIST ':IMPOSSIBLE
			     "Malformatted DO-variable specification ~S"
			     (CAR X)))
		      (T (PUSH `(,(CAAR X) ,(CADAR X)) PVARS)
                         (AND (CDDAR X)
                              (PUSH `(,(CAAR X) ,(CADDAR X)) STEPDVARS)))))
            (COND (ONCE
                   (AND STEPDVARS
			(WARN 'BAD-DO ':IMPLAUSIBLE
			      "A once-only DO contains variables to be stepped: ~S."
			      STEPDVARS))
                   (RETURN `(,PVARS . ,X))))
	    ;; Turn STEPDVARS into a PSETQ form to step the vars,
	    ;; or into NIL if there are no vars to be stepped.
            (SETQ STEPDVARS (APPLY 'NCONC STEPDVARS))
	    (AND STEPDVARS (SETQ STEPDVARS (CONS (IF SERIAL 'SETQ 'PSETQ) STEPDVARS)))
            (SETQ TAG3 (GENSYM))
            (SETQ TAG1 (GENSYM))
            (SETQ ENDTEST (OPTIMIZE ENDTEST NIL))
            (COND ((NULL ENDTEST)
		   (OPTIMIZE ENDTEST T)	;Get any style warnings we were supposed to get,
					;since ENDTEST won't actually be compiled.
                   (AND ENDVALS
			(WARN 'BAD-DO ':IMPOSSIBLE
			      "The end-test of a DO is NIL, but it says to evaluate ~S on exit."
			      ENDVALS))
                   (RETURN `(,PVARS ,TAG1
                             ,@X
			     ,STEPDVARS
                             (GO ,TAG1)))))
	    (SETQ ENDVALS `(RETURN-FROM ,PROGNAME (PROGN NIL . ,ENDVALS)))
	    (RETURN `(,PVARS
		      (GO ,TAG3)
		      ,TAG1
		      ,@X	;body
		      ,STEPDVARS
		      ,TAG3
		      (OR ,ENDTEST (GO ,TAG1))
		      ,ENDVALS))))
    (AND PROGNAME (SETQ PROGREST (CONS PROGNAME PROGREST)))
    (IF DECLS
	`(LOCAL-DECLARE ,DECLS
	   (,(IF SERIAL 'PROG* 'PROG) . ,PROGREST))
      (CONS (IF SERIAL 'PROG* 'PROG) PROGREST))))


(ADD-OPTIMIZER MAP MAPEXPAND)
(ADD-OPTIMIZER MAPL MAPEXPAND)
(ADD-OPTIMIZER MAPC MAPEXPAND)
(ADD-OPTIMIZER MAPCAR MAPEXPAND)
(ADD-OPTIMIZER MAPLIST MAPEXPAND)
(ADD-OPTIMIZER MAPCAN MAPEXPAND)
(ADD-OPTIMIZER MAPCON MAPEXPAND)

(DEFUN MAPEXPAND (FORM)
  (COND ((NULL (CDDR FORM)) FORM)  ;Don't bomb out if no args for the function to map.
	(T
    (LET ((FN (OPTIMIZE (CADR FORM) NIL))
	  CALL-FN
	  (TAKE-CARS (MEMQ (CAR FORM) '(MAPC MAPCAR MAPCAN :MAPC :MAPCAR :MAPCAN)))
	  TEM)
         (COND ((NOT OPEN-CODE-MAP-SWITCH) FORM)
               ;; Expand maps only if specified function is a quoted LAMBDA or a SUBST,
	       ;; or some arg is a call to CIRCULAR-LIST and we are mapping on cars.
	       ((NOT (OR (AND (NOT (ATOM FN))
			      (MEMQ (CAR FN) '(QUOTE FUNCTION))
			      (NOT (ATOM (CADR FN))))
			 (AND (NOT (ATOM FN))
			      (EQ (CAR FN) 'FUNCTION)
			      (NOT (ATOM (SETQ TEM (DECLARED-DEFINITION (CADR FN)))))
			      (MEMQ (CAR TEM) '(SUBST NAMED-SUBST MACRO)))
			 (AND TAKE-CARS
			      (SOME (CDDR FORM)
				    (FUNCTION (LAMBDA (X)
						(AND (NOT (ATOM X))
						     (NULL (CDDR X))
						     (MEMQ (CAR X)
							   '(CIRCULAR-LIST
							      :CIRCULAR-LIST)))))))))
		FORM)
	       (T (COND ((AND (NOT (ATOM FN)) (MEMQ (CAR FN) '(QUOTE FUNCTION)))
			 (SETQ CALL-FN (LIST (CADR FN))))
			(T (SETQ CALL-FN (LIST 'FUNCALL FN))))
		  ;; VARNMS gets a list of gensymmed variables to use to hold
		  ;; the tails of the lists we are mapping down.
		  (LET ((VARNMS)(DOCLAUSES) (ENDTEST) (CARS-OR-TAILS) (TEM))
		       ;; DOCLAUSES looks like ((G0001 expression (CDR G0001)) ...)
		       ;;  repeated for each variable.
		       ;; ENDTEST is (OR (NULL G0001) (NULL G0002) ...)
		       ;; CARS-OR-TAILS is what to pass to the specified function:
		       ;;  either (G0001 G0002 ...) or ((CAR G0001) (CAR G0002) ...)
		       (SETQ VARNMS (DO ((L (CDDR FORM) (CDR L)) (OUTPUT) )
					((NULL L) OUTPUT)
				      (PUSH (GENSYM) OUTPUT)))
		       (SETQ DOCLAUSES
			     (MAPCAR '(LAMBDA (V L)
				       (COND ((AND TAKE-CARS (NOT (ATOM L))
						   (MEMQ (CAR L) '(CIRCULAR-LIST :CIRCULAR-LIST))
						   (NULL (CDDR L)))
					      `(,V ,(CADR L)))
					     (T `(,V ,L (CDR ,V)))))
				     VARNMS (CDDR FORM)))
		       (SETQ ENDTEST
			     (CONS 'OR (MAPCAN '(LAMBDA (VL)
						 (AND (CDDR VL) `((NULL ,(CAR VL)))))
					       DOCLAUSES)))
		       (SETQ CARS-OR-TAILS
			     (COND (TAKE-CARS
				    (MAPCAR '(LAMBDA (DC)
					      (COND ((CDDR DC) `(CAR ,(CAR DC)))
						    (T (CAR DC))))
					    DOCLAUSES))
				   (T VARNMS)))
		       (COND ((MEMQ (CAR FORM) '(MAP MAPL MAPC :MAP :MAPL :MAPC)) ;NO RESULT
			      (SETQ TEM `(INHIBIT-STYLE-WARNINGS
                                            (DO-NAMED T ,DOCLAUSES
						   (,ENDTEST)
						   (,@CALL-FN . ,CARS-OR-TAILS))))
			      ;; Special hack for MAP or MAPC for value:
			      ;; Bind an extra local to 1st list and return that.
			      (COND (P1VALUE
                                     `(LET ((MAP-RESULT ,(PROG1 (CADAR DOCLAUSES)
								(RPLACA (CDAR DOCLAUSES)
									'MAP-RESULT))))
                                         ,TEM
                                         MAP-RESULT))
				    (T TEM)))
			     ((MEMQ (CAR FORM) '(MAPCAR MAPLIST :MAPCAR :MAPLIST))
			      ;;CONS UP RESULT
			      (LET ((MAP-RESULT (GENSYM))
				    (MAP-TEMP (GENSYM)))
				`(LET ((,MAP-RESULT))
				   (INHIBIT-STYLE-WARNINGS
				     (DO-NAMED T ((,MAP-TEMP (INHIBIT-STYLE-WARNINGS
							       (VARIABLE-LOCATION ,MAP-RESULT)))
						  . ,DOCLAUSES)
					       (,ENDTEST)
				       (RPLACD ,MAP-TEMP
					       (SETQ ,MAP-TEMP
						     (NCONS (,@CALL-FN . ,CARS-OR-TAILS))))))
				   ,MAP-RESULT)))
			     (T
			      ;; MAPCAN and MAPCON:  NCONC the result.
			      (LET ((MAP-TEM (GENSYM))
				    (MAP-RESULT (GENSYM)))
				`(INHIBIT-STYLE-WARNINGS
				   (DO-NAMED T (,@DOCLAUSES (,MAP-TEM) (,MAP-RESULT))
					     (,ENDTEST ,MAP-RESULT)
				     (SETQ ,MAP-TEM (NCONC ,MAP-TEM (,@CALL-FN . ,CARS-OR-TAILS)))
				     (OR ,MAP-RESULT (SETQ ,MAP-RESULT ,MAP-TEM))
				     (SETQ ,MAP-TEM (LAST ,MAP-TEM)))))))
			    )))))))


(ADD-OPTIMIZER SUBSET SUBSET-EXPAND)
(ADD-OPTIMIZER SUBSET-NOT SUBSET-EXPAND)

(DEFUN SUBSET-EXPAND (FORM)
  (LET ((FN (OPTIMIZE (CADR FORM) NIL))
	PREDARGS DOCLAUSES TEM)
    (COND ((NOT OPEN-CODE-MAP-SWITCH) FORM)
	  ;; Expand only if specified function is a quoted LAMBDA or a SUBST,
	  ((NOT (OR (AND (NOT (ATOM FN))
			 (MEMQ (CAR FN) '(QUOTE FUNCTION))
			 (NOT (ATOM (CADR FN))))
		    (AND (NOT (ATOM FN))
			 (EQ (CAR FN) 'FUNCTION)
			 (NOT (ATOM (SETQ TEM (DECLARED-DEFINITION (CADR FN)))))
			 (MEMQ (CAR TEM) '(SUBST NAMED-SUBST MACRO)))))
	   FORM)
	  (T (SETQ FN (CADR FN)) ;Strip off the QUOTE or FUNCTION.
	     ;; Generate N local variable names.
	     (DO ((L (CDDR FORM) (CDR L)) (I 0 (1+ I)))
		 ((NULL L))
	       (LET ((V (INTERN (FORMAT NIL "MAP-LOCAL-~D" I))))
		 (PUSH `(,V ,(CAR L) (CDR ,V)) DOCLAUSES)
		 (PUSH `(CAR ,V) PREDARGS)))	       
	     (SETQ DOCLAUSES (NREVERSE DOCLAUSES)
		   PREDARGS (NREVERSE PREDARGS))
	     `(LET (MAP-RESULT)
		(INHIBIT-STYLE-WARNINGS
		  (DO-NAMED T
		     ((MAP-TEMP (INHIBIT-STYLE-WARNINGS (VARIABLE-LOCATION MAP-RESULT)))
		      . ,DOCLAUSES)
		     ((NULL ,(CAAR DOCLAUSES)))	;Stop when first local variable runs out
		    (,(COND ((MEMQ (CAR FORM) '(SUBSET :SUBSET)) 'AND) (T 'OR))
		      (,FN . ,PREDARGS)
		      (RPLACD MAP-TEMP (SETQ MAP-TEMP (NCONS ,(CAR PREDARGS)))))))
		MAP-RESULT)))))

;Express multi-argument arithmetic functions in terms of two-argument versions.
(MAPC (FUNCTION (LAMBDA (FN) (PUTPROP FN '(ARITHEXP) 'OPTIMIZERS)))
      '(+ * - // CLI:// LOGAND LOGIOR LOGXOR MIN MAX PLUS TIMES DIFFERENCE QUOTIENT
        +$ *$ -$ //$))


(DEFPROP + *PLUS TWO-ARGUMENT-FUNCTION)
(DEFPROP +$ *PLUS TWO-ARGUMENT-FUNCTION)
(DEFPROP * *TIMES TWO-ARGUMENT-FUNCTION)
(DEFPROP *$ *TIMES TWO-ARGUMENT-FUNCTION)
(DEFPROP - *DIF TWO-ARGUMENT-FUNCTION)
(DEFPROP -$ *DIF TWO-ARGUMENT-FUNCTION)
(DEFPROP // *QUO TWO-ARGUMENT-FUNCTION)
(DEFPROP //$ *QUO TWO-ARGUMENT-FUNCTION)
(DEFPROP CLI:// %DIV TWO-ARGUMENT-FUNCTION)
(DEFPROP LOGIOR *LOGIOR TWO-ARGUMENT-FUNCTION)
(DEFPROP LOGAND *LOGAND TWO-ARGUMENT-FUNCTION)
(DEFPROP LOGXOR *LOGXOR TWO-ARGUMENT-FUNCTION)
(DEFPROP MIN *MIN TWO-ARGUMENT-FUNCTION)
(DEFPROP MAX *MAX TWO-ARGUMENT-FUNCTION)
(DEFPROP PLUS *PLUS TWO-ARGUMENT-FUNCTION)
(DEFPROP TIMES *TIMES TWO-ARGUMENT-FUNCTION)
(DEFPROP DIFFERENCE *DIF TWO-ARGUMENT-FUNCTION)
(DEFPROP QUOTIENT *QUO TWO-ARGUMENT-FUNCTION)

(DEFPROP :+ *PLUS TWO-ARGUMENT-FUNCTION)
(DEFPROP :+$ *PLUS TWO-ARGUMENT-FUNCTION)
(DEFPROP :* *TIMES TWO-ARGUMENT-FUNCTION)
(DEFPROP :*$ *TIMES TWO-ARGUMENT-FUNCTION)
(DEFPROP :- *DIF TWO-ARGUMENT-FUNCTION)
(DEFPROP :-$ *DIF TWO-ARGUMENT-FUNCTION)
(DEFPROP :// *QUO TWO-ARGUMENT-FUNCTION)
(DEFPROP ://$ *QUO TWO-ARGUMENT-FUNCTION)
(DEFPROP :LOGIOR *LOGIOR TWO-ARGUMENT-FUNCTION)
(DEFPROP :LOGAND *LOGAND TWO-ARGUMENT-FUNCTION)
(DEFPROP :LOGXOR *LOGXOR TWO-ARGUMENT-FUNCTION)
(DEFPROP :MIN *MIN TWO-ARGUMENT-FUNCTION)
(DEFPROP :MAX *MAX TWO-ARGUMENT-FUNCTION)
(DEFPROP :PLUS *PLUS TWO-ARGUMENT-FUNCTION)
(DEFPROP :TIMES *TIMES TWO-ARGUMENT-FUNCTION)
(DEFPROP :DIFFERENCE *DIF TWO-ARGUMENT-FUNCTION)
(DEFPROP :QUOTIENT *QUO TWO-ARGUMENT-FUNCTION)

(DEFUN ARITHEXP (X)
       (PROG (L OP)
	     (SETQ L (LENGTH (CDR X)))
	     (COND ((NULL (SETQ OP (GET (CAR X) 'TWO-ARGUMENT-FUNCTION)))
		    (BARF X 'BAD-OP-ARITHEXP 'BARF))
		   ((= 0 L)
		    (OR (SETQ L (ASSQ OP '((*PLUS . 0) (*DIF . 0) (*TIMES . 1) (*QUO . 1))))
			(WARN 'BAD-ARITHMETIC ':IMPLAUSIBLE
			      "~S with no arguments." X))
		    (RETURN (CDR L)))
		   ((= L 1)
		    (RETURN (COND ((MEMQ (CAR X) '(- -$ :- :-$))
				   (LIST 'MINUS (CADR X)))
                                  ((MEMQ (CAR X) '(// //$ :// ://$))
				   (LIST '*QUO '1 (CADR X)))
				  (T (CADR X)))))
		   ((= L 2) (RETURN (CONS OP (CDR X))))
		   (T (RETURN (CONS OP
				    (CONS (CONS (CAR X)
						(BUTLAST (CDR X)))
					  (LAST X))))))))

;Optimize forms such as (+ 3 2) and (+ 3 a 2).  These must be loaded after ARITHEXP
;so that they get done first (ADD-OPTIMIZER reverses the order)
(ADD-OPTIMIZER +	ARITH-OPT)
(ADD-OPTIMIZER +$	ARITH-OPT)
(ADD-OPTIMIZER *	ARITH-OPT)
(ADD-OPTIMIZER *$	ARITH-OPT)
(ADD-OPTIMIZER -	ARITH-OPT)
(ADD-OPTIMIZER -$	ARITH-OPT)
(ADD-OPTIMIZER //	ARITH-OPT)
(ADD-OPTIMIZER //$	ARITH-OPT)
(ADD-OPTIMIZER LOGIOR	ARITH-OPT)
(ADD-OPTIMIZER LOGAND	ARITH-OPT)
(ADD-OPTIMIZER LOGXOR	ARITH-OPT)
(ADD-OPTIMIZER MIN	ARITH-OPT)
(ADD-OPTIMIZER MAX	ARITH-OPT)
(ADD-OPTIMIZER PLUS	ARITH-OPT)
(ADD-OPTIMIZER TIMES	ARITH-OPT)
(ADD-OPTIMIZER DIFFERENCE ARITH-OPT)
(ADD-OPTIMIZER QUOTIENT	ARITH-OPT)

(DEFUN ARITH-OPT (FORM)
  (IF (<= (LENGTH FORM) 2) FORM			;Let ARITHEXP handle this.
    (LOOP FOR ARG IN (CDR FORM)
	  WHEN (OR (NUMBERP ARG)
		   (AND (CONSP ARG)
			(NUMBERP (SETQ ARG (OPTIMIZE ARG T)))))
	       COLLECT ARG INTO WINNERS
	  ELSE COLLECT ARG INTO LOSERS
	  FINALLY
	  (RETURN (COND ((NULL (CDR WINNERS)) FORM)	;Can't hope to optimize.
			((NULL LOSERS) (FOLD-CONSTANTS FORM))	;Easy optimization.
			;; Now we are left with at least two args which are numbers, but at
			;; least one which is not.  Frobbing with divide from here on is
			;; dangerous, eg, (// 5 a 4) must not optimize into (// 1 a).
			((MEMQ (CAR FORM) '(// //$ QUOTIENT :// ://$ :QUOTIENT)) FORM)
			;; The only special case left is DIFFERENCE, which treats
			;; its first arg differently.
			((OR (NOT (MEMQ (CAR FORM) '(- -$ DIFFERENCE :- :-$ :DIFFERENCE)))
			     (NUMBERP (CADR FORM)))
			 `(,(CAR FORM) ,(APPLY (CAR FORM) WINNERS) . ,LOSERS))
			(T `(,(CAR FORM) ,@LOSERS ,(APPLY #'+ WINNERS))))))))

;; Forms such as (SQRT 5) optimize into 2.236
(ADD-OPTIMIZER SQRT	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER EXP	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER LOG	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER SIN	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER SIND	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER COS	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER COSD	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER ATAN	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER ATAN2	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER ^	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER MINUS	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER 1+	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER 1-	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER ASH	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER LSH	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER ROT	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER DPB	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER LDB	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER DEPOSIT-BYTE	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER LOAD-BYTE	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER FLOOR	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER CEILING	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER TRUNCATE	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER ROUND	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER NOT	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER EQ	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER EQUAL	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER =	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER \	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER \\	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER ASSQ	ARITH-OPT-NON-ASSOCIATIVE)
(ADD-OPTIMIZER CDR	ARITH-OPT-NON-ASSOCIATIVE)

(DEFUN ARITH-OPT-NON-ASSOCIATIVE (FORM)
  (IF (LOOP FOR ARG IN (CDR FORM)
	    ALWAYS
	    (OR (INVARIABLE-FORM-P ARG)
		(AND (CONSP ARG) (INVARIABLE-FORM-P (OPTIMIZE ARG T)))))
      (FOLD-CONSTANTS FORM)
    FORM))

(ADD-OPTIMIZER + --1-)
(ADD-OPTIMIZER +$ --1-)
(ADD-OPTIMIZER - --1-)
(ADD-OPTIMIZER -$ --1-)

(DEFCONST --1--TRANS 
	  `((- . 1-) (-$ . 1-) (+ . 1+) (+$ . 1+)
	    (:- . 1-) (:-$ . 1-) (:+ . 1+) (:+$ . 1+)))
(DEFUN --1- (FORM)
  (COND ((AND (= (LENGTH FORM) 3)
	      (EQ (THIRD FORM) 1))
	 `(,(TRANSLATED-FUNCTION FORM --1--TRANS)
	   ,(SECOND FORM)))
	((AND (= (LENGTH FORM) 3)
	      (EQ (SECOND FORM) 1)
	      (MEMQ (FIRST FORM) '(+ +$ :+ :+$)))
	 `(1+ ,(THIRD FORM)))
	(T FORM)))

(ADD-OPTIMIZER EXPT EXPT-TO-^ ^)
(DEFUN EXPT-TO-^ (FORM)
  (CONS '^ (CDR FORM)))

(ADD-OPTIMIZER BOOLE BOOLE-EXPAND)
(DEFUN BOOLE-EXPAND (X)
  (PROG (L OP INST)
	(SETQ L (LENGTH (CDR X)))
	(SETQ OP (CADR X))
	(COND ((= L 2) (RETURN (CADDR X)))
	      ((AND (NUMBERP OP)
		    (SETQ INST (ASSQ OP '((1 . LOGAND)
				 (6 . LOGXOR) (7 . LOGIOR)))))
		(RETURN (CONS (CDR INST) (CDDR X))))
	      ((= L 3) (RETURN (CONS '*BOOLE (CDR X))))
	      (T (RETURN (LIST '*BOOLE (CADR X)
			       (CONS 'BOOLE (BUTLAST (CDR X)))
			       (CAR (LAST X))))))))

(DEFUN TRIVIAL-FORM-P (X)
  (OR (NUMBERP X)
      (SYMBOLP X)
      (AND (NOT (ATOM X))
	   (EQ (CAR X) 'QUOTE))))

(ADD-OPTIMIZER ADD1 ADD1-FIX)
(ADD-OPTIMIZER SUB1 ADD1-FIX)
(ADD-OPTIMIZER 1+$ ADD1-FIX)
(ADD-OPTIMIZER 1-$ ADD1-FIX)
(DEFCONST ADD1-FIX-TRANS '((ADD1 . 1+)  (1+$ . 1+) (SUB1 . 1-) (1-$ . 1-)
			   (:ADD1 . 1+)  (:1+$ . 1+) (:SUB1 . 1-) (:1-$ . 1-)))
(DEFUN ADD1-FIX (FORM)
  (CONS (TRANSLATED-FUNCTION FORM ADD1-FIX-TRANS)
	(CDR FORM)))

(ADD-OPTIMIZER \\ CONVERT-\\)

(DEFUN CONVERT-\\ (FORM)
  (LOOP FOR ARG-FORM IN (CDDDR FORM)
	WITH ANSWER = `(SYS:INTERNAL-\\ ,(SECOND FORM) ,(THIRD FORM))
	DO (SETQ ANSWER `(SYS:INTERNAL-\\ ,ANSWER ,ARG-FORM))
	FINALLY (RETURN ANSWER)))

(ADD-OPTIMIZER GCD GCD-OPTIMIZER \\)

(DEFUN GCD-OPTIMIZER (FORM)
  (CONS '\\ (CDR FORM)))

;; Not patched in 94.
(ADD-OPTIMIZER FLOAT FLOAT-OPTIMIZER INTERNAL-FLOAT)
(DEFUN FLOAT-OPTIMIZER (FORM)
  (COND ((NULL (CDDR FORM))  ;One arg
	 `(INTERNAL-FLOAT ,(CADR FORM)))
	((NUMBERP (CADDR FORM))  ;Second arg a number
	 (IF (SMALL-FLOATP (CADDR FORM))
	     `(SMALL-FLOAT ,(CADR FORM))
	   `(INTERNAL-FLOAT ,(CADR FORM))))
	(T FORM)))

(ADD-OPTIMIZER REMAINDER REMAINDER-OPTIMIZER \)
(DEFUN REMAINDER-OPTIMIZER (FORM)
  (CONS '\ (CDR FORM)))

;;; Expand the numerical equality/sign predicates.

;; Not patched in 94.
(ADD-OPTIMIZER = =-OPTIMIZER)
(DEFUN =-OPTIMIZER (FORM)
  (LET* ((ARGS (CDR FORM))
	 (N-ARGS (LENGTH ARGS)))
    (COND ((< N-ARGS 2)
	   (WARN 'WRONG-NUMBER-OF-ARGUMENTS ':IMPLAUSIBLE
		 "Too few arguments to ~S." (CAR FORM))
	   ''T)
	  ((= N-ARGS 2)
	   (IF (MEMBER (SECOND ARGS) '(0 '0))
	       `(ZEROP ,(FIRST ARGS))
	     `(INTERNAL-= . ,ARGS)))
	  ((EVERY (CDR ARGS) #'TRIVIAL-FORM-P)
	   (CONS 'AND (LOOP FOR ARG IN (CDR ARGS)
			    AND FOR LAST-ARG FIRST (CAR ARGS) THEN ARG
			    COLLECT (LIST 'INTERNAL-= LAST-ARG ARG))))
	  (T FORM))))

;; Not patched in 97.
(ADD-OPTIMIZER CHAR-EQUAL CHAR-EQUAL-OPTIMIZER)
(DEFUN CHAR-EQUAL-OPTIMIZER (FORM)
  (LET* ((ARGS (CDR FORM))
	 (N-ARGS (LENGTH ARGS)))
    (COND ((< N-ARGS 2)
	   ''T)
	  ((= N-ARGS 2)
	   `(INTERNAL-CHAR-EQUAL . ,ARGS))
	  ((EVERY (CDR ARGS) #'TRIVIAL-FORM-P)
	   (CONS 'AND (LOOP FOR ARG IN (CDR ARGS)
			    AND FOR LAST-ARG FIRST (CAR ARGS) THEN ARG
			    COLLECT (LIST 'INTERNAL-CHAR-EQUAL LAST-ARG ARG))))
	  (T FORM))))

(ADD-OPTIMIZER > >-OPTIMIZER)
(DEFUN >-OPTIMIZER (FORM)
  (CONS 'GREATERP (CDR FORM)))

(ADD-OPTIMIZER < <-OPTIMIZER)
(DEFUN <-OPTIMIZER (FORM)
  (CONS 'LESSP (CDR FORM)))

(ADD-OPTIMIZER GREATERP GREATERP-OPTIMIZER)
(DEFUN GREATERP-OPTIMIZER (FORM)
  (LET* ((ARGS (CDR FORM))
	 (N-ARGS (LENGTH ARGS)))
    (COND ((< N-ARGS 2)
;	   (WARN 'WRONG-NUMBER-OF-ARGUMENTS ':IMPLAUSIBLE
;		 "Too few arguments to ~S." (CAR FORM))
	   ''T)
	  ((= N-ARGS 2)
	   (IF (MEMBER (SECOND ARGS) '(0 '0))
	       `(PLUSP ,(FIRST ARGS))
	       `(INTERNAL-> . ,ARGS)))
	  ((EVERY (CDR ARGS) #'TRIVIAL-FORM-P)
	   (CONS 'AND (LOOP FOR ARG IN (CDR ARGS)
			    AND FOR LAST-ARG FIRST (CAR ARGS) THEN ARG
			    COLLECT (LIST 'INTERNAL-> LAST-ARG ARG))))
	  (T FORM))))

(ADD-OPTIMIZER LESSP LESSP-OPTIMIZER)
(DEFUN LESSP-OPTIMIZER (FORM)
  (LET* ((ARGS (CDR FORM))
	 (N-ARGS (LENGTH ARGS)))
    (COND ((< N-ARGS 2)
;	   (WARN 'WRONG-NUMBER-OF-ARGUMENTS ':IMPLAUSIBLE
;		 "Too few arguments to ~S." (CAR FORM))
	   ''T)
	  ((= N-ARGS 2)
	   (IF (MEMBER (SECOND ARGS) '(0 '0))
	       `(MINUSP ,(FIRST ARGS))
	       `(INTERNAL-< . ,ARGS)))
	  ((EVERY (CDR ARGS) #'TRIVIAL-FORM-P)
	   (CONS 'AND (LOOP FOR ARG IN (CDR ARGS)
			    AND FOR LAST-ARG FIRST (CAR ARGS) THEN ARG
			    COLLECT (LIST 'INTERNAL-< LAST-ARG ARG))))
	  (T FORM))))


(ADD-OPTIMIZER >= >=-OPTIMIZER)
(ADD-OPTIMIZER  >=-OPTIMIZER)
(DEFUN >=-OPTIMIZER (FORM)
  (LET* ((ARGS (CDR FORM))
	 (N-ARGS (LENGTH ARGS)))
    (COND ((< N-ARGS 2)
;	   (WARN 'WRONG-NUMBER-OF-ARGUMENTS ':IMPLAUSIBLE
;		 "Too few arguments to ~S." (CAR FORM))
	   ''T)
	  ((= N-ARGS 2)
	   (IF (MEMBER (SECOND ARGS) '(0 '0))
	       `(NOT (MINUSP ,(FIRST ARGS)))
	       `(NOT (INTERNAL-< . ,ARGS))))
	  ((EVERY (CDR ARGS) #'TRIVIAL-FORM-P)
	   (CONS 'AND (LOOP FOR ARG IN (CDR ARGS)
			    AND FOR LAST-ARG FIRST (CAR ARGS) THEN ARG
			    COLLECT `(NOT (INTERNAL-< ,LAST-ARG ,ARG)))))
	  (T FORM))))

(ADD-OPTIMIZER <= <=-OPTIMIZER)
(ADD-OPTIMIZER  <=-OPTIMIZER)
(DEFUN <=-OPTIMIZER (FORM)
  (LET* ((ARGS (CDR FORM))
	 (N-ARGS (LENGTH ARGS)))
    (COND ((< N-ARGS 2)
;	   (WARN 'WRONG-NUMBER-OF-ARGUMENTS ':IMPLAUSIBLE
;		 "Too few arguments to ~S." (CAR FORM))
	   ''T)
	  ((= N-ARGS 2)
	   (IF (MEMBER (SECOND ARGS) '(0 '0))
	       `(NOT (PLUSP ,(FIRST ARGS)))
	       `(NOT (INTERNAL-> . ,ARGS))))
	  ((EVERY (CDR ARGS) #'TRIVIAL-FORM-P)
	   (CONS 'AND (LOOP FOR ARG IN (CDR ARGS)
			    AND FOR LAST-ARG FIRST (CAR ARGS) THEN ARG
			    COLLECT `(NOT (INTERNAL-> ,LAST-ARG ,ARG)))))
	  (T FORM))))

;; Not patched in 94.
(ADD-OPTIMIZER  -OPTIMIZER)
(ADD-OPTIMIZER //= -OPTIMIZER)
(DEFUN -OPTIMIZER (FORM)
  (LET* ((ARGS (CDR FORM))
	 (N-ARGS (LENGTH ARGS)))
    (COND ((< N-ARGS 2)
;	   (WARN 'WRONG-NUMBER-OF-ARGUMENTS ':IMPLAUSIBLE
;		 "Too few arguments to ~S." (CAR FORM))
	   ''T)
	  ((= N-ARGS 2)
	   (IF (MEMBER (SECOND ARGS) '(0 '0))
	       `(NOT (ZEROP ,(FIRST ARGS)))
	     `(NOT (= . ,ARGS))))
	  ((AND (= N-ARGS 3)
		(EVERY ARGS #'TRIVIAL-FORM-P))
	   `(NOT (OR (= ,(CAR ARGS) ,(CADR ARGS))
		     (= ,(CAR ARGS) ,(CADDR ARGS))
		     (= ,(CADR ARGS) ,(CADDR ARGS)))))
	  (T FORM))))

(DEFUN CALL-FUNCTION (FUNCTION-EXP ARG-EXPS)
  (IF (AND (CONSP FUNCTION-EXP) (MEMQ (CAR FUNCTION-EXP) '(FUNCTION QUOTE))
	   (FUNCTIONP (CADR FUNCTION-EXP)))
      `(,(CADR FUNCTION-EXP) . ,ARG-EXPS)
    `(FUNCALL ,FUNCTION-EXP . ,ARG-EXPS)))

(ADD-OPTIMIZER NULL NULL-NOT)
(DEFUN NULL-NOT (FORM)
    `(NOT . ,(CDR FORM)))

;Optimize (FUNCALL (FUNCTION (LAMBDA ...)) ...) into ((LAMBDA ...) ...).
;Does not optimize (FUNCALL (FUNCTION FOO) ...) if FOO is not defined
;or takes quoted args (FUNCTIONP checks for that).
(ADD-OPTIMIZER FUNCALL FUNCALL-FUNCTION)
(DEFUN FUNCALL-FUNCTION (FORM)
    (LET ((FNFORM (OPTIMIZE (CADR FORM) NIL)))
	 (COND ((AND (NOT (ATOM FNFORM))
		     (MEMQ (CAR FNFORM) '(FUNCTION QUOTE))
		     (FUNCTIONP (CADR FNFORM)))
		(CONS (CADR FNFORM) (CDDR FORM)))
	       (T FORM))))

(ADD-OPTIMIZER LIST LIST-NO-ARGS)
(DEFUN LIST-NO-ARGS (FORM)
  (COND ((EQUAL FORM '(LIST))
	 'NIL)
	(T FORM)))

(ADD-OPTIMIZER CALL CALL-TO-MULTIPLE-VALUE-LIST)
(DEFUN CALL-TO-MULTIPLE-VALUE-LIST (FORM)
  (IF (NOT (AND (= (LENGTH FORM) 4)
		(MEMBER (THIRD FORM) '('(:OPTIONAL :SPREAD) '(:SPREAD :OPTIONAL)))))
      FORM
    (LET ((ARGFORM (OPTIMIZE (FOURTH FORM) NIL))
	  (FIRSTARG (OPTIMIZE (SECOND FORM) NIL)))
      (COND ((ATOM ARGFORM)
	     FORM)
	    ((AND (MEMQ (CAR ARGFORM) '(MULTIPLE-VALUE-LIST :MULTIPLE-VALUE-LIST))
		  (CONSP FIRSTARG)
		  (EQ (CAR FIRSTARG) 'FUNCTION)
		  (CONSP (CADR FIRSTARG))
		  (EQ (CAADR FIRSTARG) 'LAMBDA)
		  (NOT (MEMQ '&REST (CADADR FIRSTARG)))
		  (NOT (MEMQ '&KEY (CADADR FIRSTARG))))
	     ;;(call #'(lambda (x y z) ..) '(:spread :optional) (multiple-value-list ...))
	     ;;and the lambda does not have a rest arg.
	     ;;since we know how many args it wants, we can avoid consing the list of vals.
	     ;;This weird optimization is for the sake of code made by CATCH-CONTINUATION.
	     (LET ((NARGS (LDB %%ARG-DESC-MAX-ARGS (ARGS-INFO (CADR FIRSTARG)))))
	       (IF (= NARGS 1)
		   `(,(CADR FIRSTARG) ,(CADR ARGFORM))
		 `(PROGN (MULTIPLE-VALUE-PUSH ,NARGS ,(CADR ARGFORM))
			 (,(CADR FIRSTARG)
			  . ,(MAKE-LIST NARGS ':INITIAL-VALUE '(%POP)))))))
	    ;; The optimizations done on APPLY are not correct to do here,
	    ;; because they would cause the function to get an error
	    ;; if it does not want all the arguments.
	    (T FORM)))))

;;; Turn (MULTIPLE-VALUE-BIND (one-variable) (form) body...) into 
;;;   (LET ((one-variable form)) body...)
(ADD-OPTIMIZER MULTIPLE-VALUE-BIND OPTIMIZE-SIMPLE-MV-BIND)
(DEFUN OPTIMIZE-SIMPLE-MV-BIND (FORM)
  (IF ( (LENGTH (SECOND FORM)) 1) FORM ; Actually looking for 2 values
    `(LET ((,(CAR (SECOND FORM)) ,(THIRD FORM))) ,@(REST3 FORM))))

;Turn (FUNCALL SELF ...) into (FUNCALL-SELF ...) if within a method or a function with a
;:SELF-FLAVOR declaration.
;Leave it alone otherwise -- that would be a pessimization.
(ADD-OPTIMIZER FUNCALL OPTIMIZE-FUNCALL-SELF)
(DEFUN OPTIMIZE-FUNCALL-SELF (FORM)
  (IF (AND (NOT (NULL SELF-FLAVOR-DECLARATION))
	   (MEMQ (SECOND FORM) '(SELF :SELF)))
      (PROGN (CONS 'FUNCALL-SELF (CDDR FORM)))
    FORM))

(ADD-OPTIMIZER LEXPR-FUNCALL OPTIMIZE-LEXPR-FUNCALL-SELF)
(DEFUN OPTIMIZE-LEXPR-FUNCALL-SELF (FORM)
  (IF (AND (NOT (NULL SELF-FLAVOR-DECLARATION))
	   (MEMQ (SECOND FORM) '(SELF :SELF)))
      (CONS 'LEXPR-FUNCALL-SELF (CDDR FORM))
    FORM))

(ADD-OPTIMIZER APPLY APPLY-TO-LEXPR-FUNCALL LEXPR-FUNCALL)
(DEFUN APPLY-TO-LEXPR-FUNCALL (FORM)
  `(LEXPR-FUNCALL . ,(CDR FORM)))

(ADD-OPTIMIZER LEXPR-FUNCALL LEXPR-FUNCALL-ON-LIST)
(DEFUN LEXPR-FUNCALL-ON-LIST (FORM)
  (IF (= (LENGTH FORM) 2)
      (LET ((ARG (CADR FORM)))
	(ONCE-ONLY (ARG)
	  `(LEXPR-FUNCALL (CAR ,ARG) (CDR ,ARG))))
    (LET ((LASTARG (OPTIMIZE (CAR (LAST FORM)) NIL))
	  (FIRSTARG (OPTIMIZE (CADR FORM) NIL)))
      (COND ((ATOM LASTARG) FORM)
	    ((MEMQ (CAR LASTARG) '(LIST :LIST))
	     ;; If function to be called is quoted symbol, optimize out the "funcall"
	     ;; in case the symbol is a subst function.
	     (CALL-FUNCTION FIRSTARG (NCONC (BUTLAST (CDDR FORM)) (CDR LASTARG))))
	    ((MEMQ (CAR LASTARG) '(LIST* :LIST* CONS :CONS))
	     `(LEXPR-FUNCALL ,@(BUTLAST (CDR FORM)) . ,(CDR LASTARG)))
	    ((AND (EQ (CAR LASTARG) 'QUOTE)
		  (LISTP (CADR LASTARG)))
	     `(FUNCALL ,@(BUTLAST (CDR FORM))
		       . ,(MAPCAR (FUNCTION (LAMBDA (X) (LIST 'QUOTE X))) (CADR LASTARG))))
	    (T FORM)))))

(ADD-OPTIMIZER AND AND-OR-NO-OP)
(ADD-OPTIMIZER OR AND-OR-NO-OP)
(DEFUN AND-OR-NO-OP (FORM)
    (COND ((NULL (CDR FORM))
	   (COND ((MEMQ (CAR FORM) '(AND :AND))
		  ''T)
		 (T ''NIL)))
	  ((NULL (CDDR FORM))
	   (CADR FORM))
	  (T FORM)))

(ADD-OPTIMIZER PROGN 1-ARG-NO-OP)
(ADD-OPTIMIZER LIST* 1-ARG-NO-OP)
(DEFUN 1-ARG-NO-OP (FORM)
       (COND ((CDDR FORM) FORM)
             (T (CADR FORM))))

(ADD-OPTIMIZER PROG2 PROG2-NO-OP)
(DEFUN PROG2-NO-OP (FORM)
    (COND ((OR (CADR FORM) (CDDDR FORM)) FORM)
          (T (CADDR FORM))))

;Turn EQUAL into EQ when that is safe.
;EQUAL can never be turned into = alone because = signals an error if either
;arg is not a number, whereas EQUAL does not.  However, (EQUAL <fixnum> xxx)
;can be turned into EQ since EQ "works" for fixnums.
;Also EQUALwith one of the arguments a number turns into
;(AND (NUMBERP <form>) (= <number> <form>))
(ADD-OPTIMIZER EQUAL EQUAL-EQ-=)
(DEFUN EQUAL-EQ-= (FORM)
  (COND ((OR (POINTER-IDENTITY-P (CADR FORM))
	     (POINTER-IDENTITY-P (CADDR FORM)))
	 (CONS 'EQ (CDR FORM)))
	((AND (NUMBERP (CADR FORM)) (ATOM (CADDR FORM)))
	 (EQUAL-= (CADR FORM) (CADDR FORM)))
	((AND (NUMBERP (CADDR FORM)) (ATOM (CADR FORM)))
	 (EQUAL-= (CADDR FORM) (CADR FORM)))
	(T FORM)))

(DEFUN EQUAL-= (NUMBER ATOM)
       `(AND (NUMBERP ,ATOM) (= ,NUMBER ,ATOM)))

(DEFUN POINTER-IDENTITY-P (QUAN)
   (OR (FIXNUMP QUAN)
       (AND (NOT (ATOM QUAN))
	    (EQ (CAR QUAN) 'QUOTE)
	    (OR (FIXNUMP (CADR QUAN))
		(SYMBOLP (CADR QUAN))))))

;Turn (EQ FOO NIL) into (NOT FOO).
(ADD-OPTIMIZER EQ EQ-NIL)
(DEFUN EQ-NIL (FORM)
    (COND ((NULL (CDDR FORM)) FORM)  ;0 or 1 arg => let it get the error.
	  ((MEMBER (CADR FORM) '(NIL 'NIL))
           `(NOT ,(CADDR FORM)))
          ((MEMBER (CADDR FORM) '(NIL 'NIL))
           `(NOT ,(CADR FORM)))
          (T FORM)))

(ADD-OPTIMIZER MEMQ MEMQ-EQ)
(ADD-OPTIMIZER MEMBER MEMQ-EQ)
(DEFCONST MEMQ-EQ-TRANS '((MEMQ . EQ) (MEMBER . EQUAL) (:MEMQ . EQ) (:MEMBER . EQUAL)))
(DEFUN MEMQ-EQ (FORM)
  (IF (AND (QUOTEP (CADDR FORM))
	   (= 1 (LENGTH (CADR (CADDR FORM)))))
      `(AND (,(TRANSLATED-FUNCTION FORM MEMQ-EQ-TRANS)
	     ,(CADR FORM) ',(CAR (CADR (CADDR FORM))))
	    ,(CADDR FORM))
    FORM))

;Optimize (EQ (TYPEP ...) 'SYMBOL), etc.
(ADD-OPTIMIZER EQ EQ-TYPEP)
(DEFUN EQ-TYPEP (FORM)
  (PROG NIL     
      (AND (NOT (ATOM (CADR FORM)))
	   (NOT (ATOM (CADDR FORM)))
	   (COND ((AND (MEMQ (CAADR FORM) '(TYPEP TYPE-OF :TYPEP :TYPE-OF))
		       (NULL (CDDADR FORM))  ;Check that TYPEP has only one arg!
		       (EQ (CAADDR FORM) 'QUOTE))
		  (RETURN (EQ-TYPEP-1 (CADADR FORM) (CADR (CADDR FORM)) FORM)))
		 ((AND (EQ (CAADR FORM) 'QUOTE)
		       (MEMQ (CAADDR FORM) '(TYPEP TYPE-OF :TYPEP :TYPE-OF))
		       (NULL (CDDR (CADDR FORM))))
		  (RETURN (EQ-TYPEP-1 (CADR (CADDR FORM)) (CADADR FORM) FORM)))))
      (RETURN FORM)))

(DEFUN EQ-TYPEP-1 (FORM TYPE TOPFORM)
    (PROG (PRED)
	  (SETQ PRED (OR (CAR (RASSQ TYPE
				     '((STRINGP . STRING) (SYMBOLP . SYMBOL) (CONSP . LIST)
				       (STRINGP . :STRING) (SYMBOLP . :SYMBOL) (CONSP . :LIST))))
			 (CAR (RASSOC TYPE SI:TYPEP-ONE-ARG-ALIST))
			 (CAR (RASSOC TYPE SI:TYPE-OF-ALIST))))
	  (COND ((NULL PRED) (RETURN TOPFORM))
		((NUMBERP PRED) (RETURN `(= (%DATA-TYPE ,FORM) ,PRED)))
		((SYMBOLP PRED) (RETURN `(,PRED ,FORM)))
		(T (RETURN TOPFORM)))))

;;; Open coding of TYPEP and COERCE.  Optimizers defined in SYS: SYS; TYPES.
(ADD-OPTIMIZER TYPEP SI:TYPEP-TWO-ARGS SI:TYPEP-STRUCTURE SI:TYPEP-FLAVOR
	       SI:SUBINSTANCE-OF-CLASS-SYMBOL-P)
(ADD-OPTIMIZER COERCE SI:COERCE-OPTIMIZER
	       SI:COERCE-TO-ARRAY-OPTIMIZED SI:COERCE-TO-CHARACTER SI:COERCE-TO-LIST)

;;; modify signp to be (AND (NUMBERP <form>) (<op> <form>)) if form is an atom
;;; and therefore can't have side effects
(ADD-OPTIMIZER SIGNP SIGNP-EXPAND)
(DEFUN SIGNP-EXPAND (X)
  (LET ((OP (CADR X))
	(OPND (CADDR X)))
     (COND ((ATOM OPND)(SIGNP-OPTIMIZE OP OPND))		;IF ATOM, OPTIMIZE IT
	   (T X))))

(DEFUN SIGNP-OPTIMIZE (OPERATION OPERAND)
  (PROG (NEW-FORM NOTP)
    (SETQ NEW-FORM
	  (LIST (COND ((STRING-EQUAL OPERATION 'E) 'ZEROP)
		      ((STRING-EQUAL OPERATION 'N) (SETQ NOTP T) 'ZEROP)
		      ((STRING-EQUAL OPERATION 'L) 'MINUSP)
		      ((STRING-EQUAL OPERATION 'GE) (SETQ NOTP T) 'MINUSP)
		      ((STRING-EQUAL OPERATION 'G) 'PLUSP)
		      ((STRING-EQUAL OPERATION 'LE) (SETQ NOTP T) 'PLUSP)
		      (T
		       (WARN 'BAD-SIGNP ':IMPOSSIBLE
			     "~S is not a valid SIGNP condition." OPERATION)
		       'PROGN))
		OPERAND))
    (AND NOTP (SETQ NEW-FORM (LIST 'NOT NEW-FORM)))
   (RETURN `(AND (NUMBERP ,OPERAND) ,NEW-FORM))))

(DEFUN SIMPLE-FORM-P (FORM)
  (OR (ATOM FORM)   ; Cautious about quoted lists that might get bashed
      (AND (LISTP FORM) (EQ (FIRST FORM) 'QUOTE) (ATOM (SECOND FORM)))))
      
(DEFUN INVARIABLE-FORM-P (FORM)
  (OR (NUMBERP FORM)
      (STRINGP FORM)
      (MEMQ FORM '(T NIL))
      (AND (CONSP FORM) (EQ (CAR FORM) 'QUOTE))
      (MEMQ FORM ARRAY-TYPES)))

(ADD-OPTIMIZER MAKE-ARRAY TRY-TO-USE-SIMPLE-MAKE-ARRAY SI:SIMPLE-MAKE-ARRAY)
(DEFUN TRY-TO-USE-SIMPLE-MAKE-ARRAY (FORM)
  (PROG TOP ((LEN (LENGTH FORM))
	     (DIMENSIONS-FORM NIL)
	     (INITIAL-VALUE-FORM NIL)
	     (INITIAL-VALUE-SPECIFIED NIL)
	     (AREA-FORM NIL)
	     (TYPE-FORM ''ART-Q)
	     (LEADER-LENGTH-FORM NIL)
	     (FILL-POINTER-FORM NIL)
	     (FILL-POINTER-SPECIFIED NIL)
	     (NAMED-STRUCTURE-SYMBOL-FORM NIL)
	     (NAMED-STRUCTURE-SYMBOL-SPECIFIED NIL)
	     OUT-OF-ORDER
	     STARTFORM)
    (IF (OR (< LEN 2)
	    (NOT (EVENP LEN)))
	(RETURN FORM))
    (SETQ DIMENSIONS-FORM (SECOND FORM))
    (LOOP FOR (KEYWORD-FORM ARGUMENT-FORM) ON (REST2 FORM) BY #'CDDR
	  DO (SELECTOR KEYWORD-FORM EQUAL
	       (('':TYPE)
		(SETQ TYPE-FORM ARGUMENT-FORM)
		(OR (INVARIABLE-FORM-P TYPE-FORM)
		    (IF (SYMBOLP TYPE-FORM)
			(AND (TRIVIAL-FORM-P AREA-FORM)
			     (TRIVIAL-FORM-P LEADER-LENGTH-FORM)
			     (TRIVIAL-FORM-P INITIAL-VALUE-FORM)
			     (TRIVIAL-FORM-P FILL-POINTER-FORM)
			     (TRIVIAL-FORM-P NAMED-STRUCTURE-SYMBOL-FORM))
		      (AND (INVARIABLE-FORM-P AREA-FORM)
			   (INVARIABLE-FORM-P LEADER-LENGTH-FORM)
			   (INVARIABLE-FORM-P INITIAL-VALUE-FORM)
			   (INVARIABLE-FORM-P FILL-POINTER-FORM)
			   (INVARIABLE-FORM-P NAMED-STRUCTURE-SYMBOL-FORM)))
		    (SETQ OUT-OF-ORDER T)))
	       (('':AREA)
		(SETQ AREA-FORM ARGUMENT-FORM)
		(OR (INVARIABLE-FORM-P AREA-FORM)
		    (IF (SYMBOLP AREA-FORM)
			(AND (TRIVIAL-FORM-P LEADER-LENGTH-FORM)
			     (TRIVIAL-FORM-P INITIAL-VALUE-FORM)
			     (TRIVIAL-FORM-P FILL-POINTER-FORM)
			     (TRIVIAL-FORM-P NAMED-STRUCTURE-SYMBOL-FORM))
		      (AND (INVARIABLE-FORM-P LEADER-LENGTH-FORM)
			   (INVARIABLE-FORM-P INITIAL-VALUE-FORM)
			   (INVARIABLE-FORM-P FILL-POINTER-FORM)
			   (INVARIABLE-FORM-P NAMED-STRUCTURE-SYMBOL-FORM)))
		    (SETQ OUT-OF-ORDER T)))
	       (('':LEADER-LENGTH)
		(SETQ LEADER-LENGTH-FORM ARGUMENT-FORM)
		(OR (INVARIABLE-FORM-P LEADER-LENGTH-FORM)
		    (IF (SYMBOLP LEADER-LENGTH-FORM)
			(AND (TRIVIAL-FORM-P INITIAL-VALUE-FORM)
			     (TRIVIAL-FORM-P FILL-POINTER-FORM)
			     (TRIVIAL-FORM-P NAMED-STRUCTURE-SYMBOL-FORM))
		      (AND (INVARIABLE-FORM-P INITIAL-VALUE-FORM)
			   (INVARIABLE-FORM-P FILL-POINTER-FORM)
			   (INVARIABLE-FORM-P NAMED-STRUCTURE-SYMBOL-FORM)))
		    (SETQ OUT-OF-ORDER T)))
	       (('':INITIAL-VALUE)
		(SETQ INITIAL-VALUE-FORM ARGUMENT-FORM INITIAL-VALUE-SPECIFIED T)
		(OR (INVARIABLE-FORM-P INITIAL-VALUE-FORM)
		    (IF (SYMBOLP INITIAL-VALUE-FORM)
			(AND (TRIVIAL-FORM-P FILL-POINTER-FORM)
			     (TRIVIAL-FORM-P NAMED-STRUCTURE-SYMBOL-FORM))
		      (AND (INVARIABLE-FORM-P FILL-POINTER-FORM)
			   (INVARIABLE-FORM-P NAMED-STRUCTURE-SYMBOL-FORM)))
		    (SETQ OUT-OF-ORDER T)))
	       (('':FILL-POINTER)
		(SETQ FILL-POINTER-FORM ARGUMENT-FORM FILL-POINTER-SPECIFIED T)
		(OR (INVARIABLE-FORM-P FILL-POINTER-FORM)
		    (IF (SYMBOLP FILL-POINTER-FORM)
			(TRIVIAL-FORM-P NAMED-STRUCTURE-SYMBOL-FORM)
		      (INVARIABLE-FORM-P NAMED-STRUCTURE-SYMBOL-FORM))
		    (SETQ OUT-OF-ORDER T)))
	       (('':NAMED-STRUCTURE-SYMBOL)
		(SETQ NAMED-STRUCTURE-SYMBOL-FORM ARGUMENT-FORM
		      NAMED-STRUCTURE-SYMBOL-SPECIFIED T))
	       (OTHERWISE
		 (RETURN-FROM TOP FORM))))
    (COND (OUT-OF-ORDER
	   ;; Don't optimize if it means exchanging two subforms
	   ;; which could affect each other.
	   (RETURN FORM)))
    (IF FILL-POINTER-SPECIFIED
	(SETQ LEADER-LENGTH-FORM
	      (IF LEADER-LENGTH-FORM
		  `(MAX 1 ,LEADER-LENGTH-FORM)
		1)))
    (SETQ STARTFORM
	  (COND
	    (INITIAL-VALUE-SPECIFIED
	     `(SI:SIMPLE-MAKE-ARRAY ,DIMENSIONS-FORM ,TYPE-FORM ,AREA-FORM
				    ,LEADER-LENGTH-FORM ,INITIAL-VALUE-FORM))
	    (LEADER-LENGTH-FORM
	     `(SI:SIMPLE-MAKE-ARRAY ,DIMENSIONS-FORM ,TYPE-FORM ,AREA-FORM
				    ,LEADER-LENGTH-FORM))
	    (AREA-FORM
	     `(SI:SIMPLE-MAKE-ARRAY ,DIMENSIONS-FORM ,TYPE-FORM ,AREA-FORM))
	    (T
	     `(SI:SIMPLE-MAKE-ARRAY ,DIMENSIONS-FORM ,TYPE-FORM))))
    (RETURN
      (IF (OR FILL-POINTER-SPECIFIED NAMED-STRUCTURE-SYMBOL-SPECIFIED)
	  (LET ((ARRAY-VAR (GENSYM)))
	    `(LET ((,ARRAY-VAR ,STARTFORM))
	       ,(IF FILL-POINTER-SPECIFIED
		    `(SETF (FILL-POINTER ,ARRAY-VAR) ,FILL-POINTER-FORM))
	       ,(IF NAMED-STRUCTURE-SYMBOL-SPECIFIED
		    `(MAKE-ARRAY-INTO-NAMED-STRUCTURE
		       ,ARRAY-VAR ,NAMED-STRUCTURE-SYMBOL-FORM))
	       , ARRAY-VAR))
	STARTFORM))))

(ADD-OPTIMIZER AREF AREF-EXPANDER)
(DEFUN AREF-EXPANDER (FORM)
    (SELECTQ (LENGTH FORM)
       (3 (CONS 'AR-1 (CDR FORM)))
       (4 (CONS 'AR-2 (CDR FORM)))
       (5 (CONS 'AR-3 (CDR FORM)))
       (T FORM)))

(ADD-OPTIMIZER COMMON-LISP-AREF COMMON-LISP-AREF-EXPANDER)
(DEFUN COMMON-LISP-AREF-EXPANDER (FORM)
    (SELECTQ (LENGTH FORM)
       (3 (CONS 'COMMON-LISP-AR-1 (CDR FORM)))
       (4 (CONS 'AR-2 (CDR FORM)))
       (5 (CONS 'AR-3 (CDR FORM)))
       (T FORM)))

(ADD-OPTIMIZER ASET ASET-EXPANDER)
(DEFUN ASET-EXPANDER (FORM)
    (SELECTQ (LENGTH FORM)
        (4 (CONS 'AS-1 (CDR FORM)))
        (5 (CONS 'AS-2 (CDR FORM)))
        (6 (CONS 'AS-3 (CDR FORM)))
	(T FORM)))

(ADD-OPTIMIZER SET-AREF SET-AREF-EXPANDER)
(DEFUN SET-AREF-EXPANDER (FORM)
    (SELECTQ (LENGTH FORM)
        (4 (CONS 'SET-AR-1 (CDR FORM)))
        (5 (CONS 'SET-AR-2 (CDR FORM)))
        (6 (CONS 'SET-AR-3 (CDR FORM)))
	(T FORM)))

(ADD-OPTIMIZER ALOC ALOC-EXPANDER)
(DEFUN ALOC-EXPANDER (FORM)
    (SELECTQ (LENGTH FORM)
       (3 (CONS 'AP-1 (CDR FORM)))
       (4 (CONS 'AP-2 (CDR FORM)))
       (5 (CONS 'AP-3 (CDR FORM)))
       (T FORM)))

;;; Find simple calls to MAKE-LIST and convert them into calls to the
;;; microcoded %MAKE-LIST.  NOTE THAT THIS CHANGES ORDER OF EVALUATION!
(ADD-OPTIMIZER MAKE-LIST MAKE-LIST-%MAKE-LIST %MAKE-LIST)
(DEFUN MAKE-LIST-%MAKE-LIST (FORM)
  (*CATCH 'GIVE-UP
    (LET ((LENGTH-OF-FORM (LENGTH FORM)))
      (COND ((= LENGTH-OF-FORM 3)
	     ;; It is old-style.
	     `(%MAKE-LIST 'NIL ,(SECOND FORM) ,(THIRD FORM)))
	    (T
	     ;; It is new-style.
	     (IF (NOT (EVENP LENGTH-OF-FORM))
		 (*THROW 'GIVE-UP FORM))
	     (LET ((AREA-FORM 'NIL) (INITIAL-VALUE-FORM 'NIL))
	       (DO ((OPTIONS (CDDR FORM) (CDDR OPTIONS)))
		   ((NULL OPTIONS))
		 (LET ((KEYWORD-FORM (FIRST OPTIONS))
		       (VALUE-FORM (SECOND OPTIONS)))
		   ;; If the keyword form isn't a quoted symbol, punt.
		   (IF (OR (ATOM KEYWORD-FORM)
			   ( (LENGTH KEYWORD-FORM) 2)
			   (NEQ (FIRST KEYWORD-FORM) 'QUOTE)
			   (NOT (SYMBOLP (SECOND KEYWORD-FORM))))
		       (*THROW 'GIVE-UP FORM))
		   (SELECTQ (SECOND KEYWORD-FORM)
		     (:AREA (SETQ AREA-FORM VALUE-FORM))
		     ((:INITIAL-VALUE :INITIAL-ELEMENT)
		      (SETQ INITIAL-VALUE-FORM VALUE-FORM))
		     (OTHERWISE (*THROW 'GIVE-UP FORM)))))
	       `(%MAKE-LIST ,INITIAL-VALUE-FORM ,AREA-FORM ,(SECOND FORM))))))))

(ADD-OPTIMIZER STATUS STATUS-OPTIMIZER)
(DEFUN STATUS-OPTIMIZER (FORM)
  (LET ((STATUS-FUNCTION (CADR FORM))
	;(ITEM (CADDR FORM))
	(ITEM-P (CDDR FORM)))
    (SELECTOR STATUS-FUNCTION STRING-EQUAL
      (('FEATURE 'FEATURES) (IF ITEM-P FORM `STATUS-FEATURE-LIST))
      (('TABSIZE) `8)
      (('USERID) `USER-ID)
      (('SITE) `LOCAL-HOST-NAME)
      (('OPSYS) `':LISPM)
      (OTHERWISE (OR (MEM #'STRING-EQUAL STATUS-FUNCTION SI:STATUS-STATUS-LIST)
		     (WARN 'UNKNOWN-STATUS-FUNCTION ':IMPOSSIBLE "Unknown STATUS function ~A."
			   STATUS-FUNCTION))
		 FORM))))

;Next two are here mainly to avoid getting an error message from GETARGDESC about random FSUBR.
(ADD-OPTIMIZER COMMENT COMMENT-EXPAND)
(ADD-OPTIMIZER DECLARE COMMENT-EXPAND)
(DEFUN COMMENT-EXPAND (IGNORE) ''COMMENT)

(ADD-OPTIMIZER DEFPROP DEFPROP-EXPAND)
(DEFUN DEFPROP-EXPAND (X)
       `(PUTPROP ',(CADR X) ',(CADDR X) ',(CADDDR X)))

(ADD-OPTIMIZER GET-FROM-ALTERNATING-LIST GFAL-GET)
(DEFUN GFAL-GET (X)
  (COND ((OR (SYMBOLP (CADR X))
	     (AND (CONSP (CADR X))
		  (DO ((FORM1 (CADR X))) (NIL)
		    (AND (OR (GET (CAR FORM1) 'LOCF)
			     (GET (CAR FORM1) 'SI:SETF-EXPANDER))
			 (RETURN T))
		    (AND (EQ FORM1 (SETQ FORM1 (MACROEXPAND-1 FORM1))) (RETURN NIL)))))
	 `(GET (LOCF ,(CADR X)) . ,(CDDR X)))
	(T X)))

; Convert catches and throws
(ADD-OPTIMIZER CATCH CATCH-*CATCH)
(DEFUN CATCH-*CATCH (X)
       `(*CATCH ',(CADDR X) ,(CADR X)))

(ADD-OPTIMIZER THROW THROW-*THROW)
(DEFUN THROW-*THROW (X)
       `(*THROW ',(CADDR X) ,(CADR X)))

;;; Make *CATCH compile arguments other than the first and the last for
;;; effect rather than for value.
(ADD-OPTIMIZER *CATCH *CATCH-PROGNIFY)
(DEFUN *CATCH-PROGNIFY (FORM)
  (IF (CDDDR FORM) `(*CATCH ,(CADR FORM) (PROGN . ,(CDDR FORM)))
      FORM))

;Make PROGV work compiled.
;The resulting code will only work in CAR/CDR of NIL = NIL mode.
(ADD-OPTIMIZER PROGV PROGV-EXPAND)
(DEFUN PROGV-EXPAND (FORM)
  (LET ((VARNAMES (CADR FORM)) (VALS (CADDR FORM)) (BODY (CDDDR FORM))
	(VARS-VAR (GENSYM))
	(VALS-VAR (GENSYM)))
    `(PROG ((,VARS-VAR ,VARNAMES) (,VALS-VAR ,VALS))
	LOOP (COND (,VARS-VAR
		    (INHIBIT-STYLE-WARNINGS
		      (BIND (INHIBIT-STYLE-WARNINGS (VALUE-CELL-LOCATION (CAR ,VARS-VAR)))
			    (CAR ,VALS-VAR)))
		    (UNLESS ,VALS-VAR
		      (MAKUNBOUND (CAR ,VARS-VAR)))
		    (SETQ ,VARS-VAR (CDR ,VARS-VAR))
		    (SETQ ,VALS-VAR (CDR ,VALS-VAR))
		    (GO LOOP)))
	   (RETURN (PROGN . ,BODY)))))

;Turn PROG1 into PROG2 since that is open-coded.
;Also turn (PROG1 FOO NIL) into FOO since PBIND generates that and it makes better code
(ADD-OPTIMIZER PROG1 PROG1-PROG2)
(DEFUN PROG1-PROG2 (FORM)
  (IF (EQUAL (CDDR FORM) '(NIL))
      (CADR FORM)
      `(PROG2 NIL . ,(CDR FORM))))

(ADD-OPTIMIZER SI:PROGW PROGW-EXPAND)
(DEFUN PROGW-EXPAND (FORM)
  (DESTRUCTURING-BIND (IGNORE VARS-AND-VALS &BODY BODY) FORM
    (LET ((VARS-AND-VALS-VAR (GENSYM)))
      `(PROG ((,VARS-AND-VALS-VAR ,VARS-AND-VALS))
	  LOOP
	     (COND (,VARS-AND-VALS-VAR
		    (BIND (VALUE-CELL-LOCATION (CAAR ,VARS-AND-VALS-VAR))
			  (EVAL (CADAR ,VARS-AND-VALS-VAR)))
		    (SETQ ,VARS-AND-VALS-VAR (CDR ,VARS-AND-VALS-VAR))
		    (GO LOOP)))
	     (RETURN (PROGN . ,BODY))))))

(ADD-OPTIMIZER LET-IF LET-IF-EXPAND)
(DEFUN LET-IF-EXPAND (FORM)
  (DESTRUCTURING-BIND (IGNORE COND VARS-AND-VALS &BODY BODY) FORM
    (COND ((NULL COND) `(LET NIL . ,BODY))	;Macros generate this
	  ((EQ COND T) `(LET ,VARS-AND-VALS . ,BODY))	;and this
	  (T `(LET ()
		(COND (,COND ,(PBIND VARS-AND-VALS)))
		. ,BODY)))))

(DEFUN PBIND (VARS-AND-VALS)
  (COND (VARS-AND-VALS
	 `(BIND (VARIABLE-LOCATION ,(CAAR VARS-AND-VALS))
		(PROG1 ,(CADAR VARS-AND-VALS)
		       ,(PBIND (CDR VARS-AND-VALS)))))))

(DEFPROP CONS (CONS-NCONS CONS-LIST) OPTIMIZERS)

;Turn (CONS foo NIL) into (NCONS foo), saving one instruction.
(DEFUN CONS-NCONS (FORM)
    (COND ((MEMBER (CADDR FORM) '(NIL 'NIL))
	   `(NCONS ,(CADR FORM)))
	  (T FORM)))

;Turn (CONS X (CONS Y NIL)) into (LIST X Y).  Doesn't change (CONS X NIL), though.
;Perhaps we want a hairier criterion, for the sake of
;those times when you create a list you are going to RPLACA
;and don't want LIST to be used.
(DEFUN CONS-LIST (FORM)
    (COND ((ATOM (CADDR FORM)) FORM)
	  ((MEMQ (CAADDR FORM) '(CONS :CONS))
	   (LET ((TEM (CONS-LIST (CADDR FORM))))
		(COND ((MEMQ (CAR TEM) '(LIST :LIST))
		       `(LIST ,(CADR FORM) . ,(CDR TEM)))
		      ((MEMBER (CADDR TEM) '(NIL 'NIL))
		       `(LIST ,(CADR FORM) ,(CADR TEM)))
		      (T FORM))))
	  (T FORM)))

;The following are here to make list-type structures work more efficiently.
;It's easier to put the optimization in the compiler than in DEFSTRUCT.

(ADD-OPTIMIZER NTH NTH-OPTIMIZE)
(ADD-OPTIMIZER NTHCDR NTHCDR-OPTIMIZE)

(DEFUN NTH-OPTIMIZE (X)
  (LET ((TEM (ASSOC (CADR X) '((0 . CAR) (1 . CADR) (2 . CADDR) (3 . CADDDR)))))
       (COND (TEM `(,(CDR TEM) ,(CADDR X)))
	     (T X))))

(DEFUN NTHCDR-OPTIMIZE (X)
  (LET ((TEM (ASSOC (CADR X) '((1 . CDR) (2 . CDDR) (3 . CDDDR) (4 . CDDDDR)))))
    (COND ((EQUAL (CADR X) 0) (CADDR X))
	  (TEM `(,(CDR TEM) ,(CADDR X)))
	  (T X))))

;; Optimize (CAR (CDR X)) into (CADR X) -- LOOP generates this all the time.
;; This is really the wrong place in the compiler for this...
;; EVAL-WHEN so the #.'s below will win the first time.
(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFVAR CXRS '(CAR CDR CAAR CADR CDAR CDDR CAAAR CAADR
	       CADAR CADDR CDAAR CDADR CDDAR CDDDR
	       CAAAAR CAAADR CAADAR CAADDR CADAAR CADADR
	       CADDAR CADDDR CDAAAR CDAADR CDADAR CDADDR
	       CDDAAR CDDADR CDDDAR CDDDDR))

(DEFVAR 3CXRS (FIRSTN 14. CXRS))
)

(DEFCONST CXR-POP-TABLE
	  '#.(LOOP FOR SYM IN (CDDR CXRS) COLLECTING
		   (CONS SYM (INTERN (STRING-APPEND #/C (SUBSTRING SYM 2))))))

(DEFCONST CXR-APPEND-TABLE
	  '#.(LOOP FOR SYM IN 3CXRS
		   AS FIRST = (SUBSTRING (GET-PNAME SYM)
					 0 (1- (ARRAY-ACTIVE-LENGTH (GET-PNAME SYM))))
		   COLLECT (LIST SYM
				 (INTERN (STRING-APPEND FIRST "AR"))
				 (INTERN (STRING-APPEND FIRST "DR")))))

(LOOP FOR X IN 3CXRS DO (PUTPROP X '(3CXR-OPTIMIZE) 'OPTIMIZERS))
(DEFUN 3CXR-OPTIMIZE (FORM)
  (LET ((ARGFORM (OPTIMIZE (CADR FORM) T)))
    (COND ((AND (CONSP ARGFORM)
		(MEMQ (CAR ARGFORM) CXRS))
	   `(,(FUNCALL (IF (= (AREF (GET-PNAME (CAR ARGFORM)) 1) #/A) #'CADR #'CADDR)
		       (ASSQ (CAR FORM) CXR-APPEND-TABLE))
	     ,(LET ((X (CDR (ASSQ (CAR ARGFORM) CXR-POP-TABLE))))
		(IF X `(,X . ,(CDR ARGFORM)) (CADR ARGFORM)))))
	  (T FORM))))

;Patched into system 97.
;(DEFUN 3CXR-OPTIMIZE (FORM)
;  (LET ((ARGFORM (OPTIMIZE (CADR FORM) T)))
;    (COND ((AND (CONSP ARGFORM)
;		(MEMQ (CAR ARGFORM) CXRS))
;	   `(,(FUNCALL (IF (= (AREF (GET-PNAME (CAR ARGFORM)) 1) #/A) #'CADR #'CADDR)
;		       (ASS 'STRING-EQUAL (CAR FORM) CXR-APPEND-TABLE))
;	     ,(LET ((X (CDR (ASSQ (CAR ARGFORM) CXR-POP-TABLE))))
;		(IF X `(,X . ,(CDR ARGFORM)) (CADR ARGFORM)))))
;	  (T FORM))))

(DEFUN *LEXPR FEXPR (L)
  (DOLIST (X L)
    (COMPILATION-DEFINE X)
    (PUTPROP X '((1005 (FEF-ARG-OPT FEF-QT-EVAL)))
	     'ARGDESC)))

(DEFUN *EXPR FEXPR (L)
  (DOLIST (X L)
    (COMPILATION-DEFINE X)
    (PUTPROP X '((1005 (FEF-ARG-OPT FEF-QT-EVAL)))
	     'ARGDESC)))

(DEFUN *FEXPR FEXPR (L)
  (DOLIST (X L)
    (COMPILATION-DEFINE X)
    (PUTPROP X '((1005 (FEF-ARG-OPT FEF-QT-QT)))
	     'ARGDESC)))

(ADD-OPTIMIZER STRING-SEARCH STRING-SEARCH-STRING-SEARCH-CHAR STRING-SEARCH-CHAR)
(DEFUN STRING-SEARCH-STRING-SEARCH-CHAR (FORM)
  (LET ((KEY (SECOND FORM)) QUOTEP)
    (IF (QUOTEP KEY)
	(SETQ KEY (SECOND KEY)
	      QUOTEP T))
    (IF (OR (AND (OR (STRINGP KEY)
		     (AND QUOTEP (SYMBOLP KEY)))
		 (= (STRING-LENGTH KEY) 1))
	    (TYPEP KEY ':CHARACTER)
	    (AND (FIXP KEY) (NOT (MINUSP KEY)) (< KEY 400)))
	`(STRING-SEARCH-CHAR ,(CHARACTER KEY) . ,(CDDR FORM))
      FORM)))

;Style checkers are, unlike optimizers or macro definitions,
;run only on user-supplied input, not the results of expansions.
;Also, they are not expected to return any values.
;They do not alter the input, merely print warnings if there
;is anything ugly in it.

;Style checkers are used to implement RUN-IN-MACLISP-SWITCH
;and OBSOLETE-FUNCTION-WARNING-SWITCH.  They can also warn
;about anything else that is ugly or frowned upon, though legal.

(DEFUN OBSOLETE (FORM)
    (AND OBSOLETE-FUNCTION-WARNING-SWITCH
	 (NOT RUN-IN-MACLISP-SWITCH)
	 (WARN 'OBSOLETE ':OBSOLETE
	       "~S ~A."
	       (CAR FORM)
	       (OR (GET (CAR FORM) 'OBSOLETE)
		   "is an obsolete function"))))

(MAKE-OBSOLETE GETCHAR "use strings")
(MAKE-OBSOLETE GETCHARN "use strings")
(MAKE-OBSOLETE IMPLODE "use strings")
(MAKE-OBSOLETE MAKNAM "use strings")
(MAKE-OBSOLETE EXPLODE "use strings")
(MAKE-OBSOLETE EXPLODEC "use strings")
(MAKE-OBSOLETE EXPLODEN "use strings")
(MAKE-OBSOLETE SAMEPNAMEP "use strings")
;This can't go in PROCES because it gets loaded before this file
(MAKE-OBSOLETE PROCESS-CREATE "it has been renamed to MAKE-PROCESS")
(MAKE-OBSOLETE SI:PROCESS-RUN-TEMPORARY-FUNCTION "PROCESS-RUN-FUNCTION is identical.")
(MAKE-OBSOLETE FS:FILE-READ-PROPERTY-LIST "the new name is FS:READ-ATTRIBUTE-LIST")
(MAKE-OBSOLETE FS:FILE-PROPERTY-LIST "the new name is FS:FILE-ATTRIBUTE-LIST")
(MAKE-OBSOLETE FS:FILE-PROPERTY-BINDINGS "the new name is FS:FILE-ATTRIBUTE-BINDINGS")
(MAKE-OBSOLETE PRINT-LOADED-BAND "use PRINT-HERALD")
(MAKE-OBSOLETE WITH-RESOURCE "the new name is USING-RESOURCE")

;; I guess these have to be on SYSTEM for this to work.
(DEFPROP MAKNUM UNIMPLEMENTED STYLE-CHECKER)
(DEFPROP MUNKAM UNIMPLEMENTED STYLE-CHECKER)
(DEFPROP *REARRAY UNIMPLEMENTED STYLE-CHECKER)
(DEFPROP *FUNCTION UNIMPLEMENTED STYLE-CHECKER)
(DEFPROP SUBRCALL UNIMPLEMENTED STYLE-CHECKER)
(DEFPROP LSUBRCALL UNIMPLEMENTED STYLE-CHECKER)
(DEFPROP PNGET UNIMPLEMENTED STYLE-CHECKER)
(DEFPROP PNPUT UNIMPLEMENTED STYLE-CHECKER)
(DEFPROP FSC UNIMPLEMENTED STYLE-CHECKER)

(DEFUN UNIMPLEMENTED (FORM)
  (WARN 'UNIMPLEMENTED ':IMPLEMENTATION-LIMIT
	"The function ~S is not implemented in Zetalisp."
	(CAR FORM)))

(COMMENT
;;; These are commented out because the style checker doesn't really manage
;;; to operate only on the user's typed-in code, and
;;; calls to these with one or zero args are generated by optimizers and macros, etc.
  (DEFPROP OR NEED-TWO-ARGS STYLE-CHECKER)
  (DEFPROP AND NEED-TWO-ARGS STYLE-CHECKER)
  (DEFPROP PROGN NEED-TWO-ARGS STYLE-CHECKER))

(DEFPROP PROG1 NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP PROG2 NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP + NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP * NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP PLUS NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP TIMES NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP QUOTIENT NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP DIFFERENCE NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP NCONC NEED-TWO-ARGS STYLE-CHECKER)
(DEFPROP APPEND NEED-TWO-ARGS STYLE-CHECKER)
(DEFUN NEED-TWO-ARGS (FORM)
    (COND ((NULL (CDDR FORM))
	   (WARN 'WRONG-NUMBER-OF-ARGUMENTS ':IMPLAUSIBLE
		 "~S used with fewer than two arguments" (CAR FORM)))))

(DEFPROP SETQ NEED-AN-ARG STYLE-CHECKER)
(DEFPROP PSETQ NEED-AN-ARG STYLE-CHECKER)
;Note:  one arg will cause an error, so who needs a warning too?

(DEFPROP COND NEED-AN-ARG STYLE-CHECKER)
(DEFPROP - NEED-AN-ARG STYLE-CHECKER)
(DEFPROP // NEED-AN-ARG STYLE-CHECKER)
(DEFUN NEED-AN-ARG (FORM)
    (OR (CDR FORM)
	(WARN 'WRONG-NUMBER-OF-ARGUMENTS ':IMPLAUSIBLE
	      "~S used with no arguments" (CAR FORM))))

(DEFUN (:PROPERTY FORMAT STYLE-CHECKER) (FORM)
    (NEED-TWO-ARGS FORM)
    (IF (STRINGP (CADR FORM))
	(WARN 'BAD-ARGUMENT ':IMPLAUSIBLE
	      "FORMAT is used with ~S as its first argument,
 which should be a stream, T or NIL." (CADR FORM))))

(DEFUN (VALUE-CELL-LOCATION STYLE-CHECKER) (FORM)
  (NOT-MACLISP FORM)
  (AND (CONSP (CADR FORM))
       (EQ (CAADR FORM) 'QUOTE)
       (WARN 'VALUE-CELL-LOCATION ':OBSOLETE
	     "VALUE-CELL-LOCATION of quoted variable ~S is obsolete; use VARIABLE-LOCATION"
	     (CADR FORM))))

(DEFUN (BOUNDP STYLE-CHECKER) (FORM)
  (AND (CONSP (CADR FORM))
       (EQ (CAADR FORM) 'QUOTE)
       (NOT (SPECIALP (CADADR FORM)))
       (WARN 'BOUNDP ':OBSOLETE
	     "BOUNDP of a quoted nonspecial variable is obsolete; use VARIABLE-BOUNDP")))

;;; Style-checkers for things that don't work in Maclisp.

;These symbols don't exist in Maclisp, though they could, but they are likely losers.
(DEFPROP LISTP NOT-MACLISP STYLE-CHECKER)
(DEFPROP NLISTP NOT-MACLISP STYLE-CHECKER)
(DEFPROP NSYMBOLP NOT-MACLISP STYLE-CHECKER)

;These functions can't be added to Maclisp by a user.
(DEFPROP INTERN-LOCAL NOT-MACLISP STYLE-CHECKER)
(DEFPROP INTERN-SOFT NOT-MACLISP STYLE-CHECKER)
(DEFPROP INTERN-LOCAL-SOFT NOT-MACLISP STYLE-CHECKER)
(DEFPROP MAKE-ARRAY NOT-MACLISP STYLE-CHECKER)
(DEFPROP G-L-P NOT-MACLISP STYLE-CHECKER)
(DEFPROP ARRAY-LEADER NOT-MACLISP STYLE-CHECKER)
(DEFPROP STORE-ARRAY-LEADER NOT-MACLISP STYLE-CHECKER)
(DEFPROP MULTIPLE-VALUE NOT-MACLISP STYLE-CHECKER)
(DEFPROP MULTIPLE-VALUE-LIST NOT-MACLISP STYLE-CHECKER)
(DEFPROP DO-NAMED NOT-MACLISP STYLE-CHECKER)
(DEFPROP RETURN-FROM NOT-MACLISP STYLE-CHECKER)
(DEFPROP RETURN-LIST NOT-MACLISP STYLE-CHECKER)
(DEFPROP BIND NOT-MACLISP STYLE-CHECKER)
(DEFPROP COMPILER-LET NOT-MACLISP STYLE-CHECKER)
(DEFPROP LOCAL-DECLARE NOT-MACLISP STYLE-CHECKER)
(DEFPROP CONS-IN-AREA NOT-MACLISP STYLE-CHECKER)
(DEFPROP LIST-IN-AREA NOT-MACLISP STYLE-CHECKER)
(DEFPROP NCONS-IN-AREA NOT-MACLISP STYLE-CHECKER)
(DEFPROP VARIABLE-LOCATION NOT-MACLISP STYLE-CHECKER)
(DEFPROP VARIABLE-BOUNDP NOT-MACLISP STYLE-CHECKER)
(DEFPROP CAR-LOCATION NOT-MACLISP STYLE-CHECKER)
(DEFPROP PROPERTY-CELL-LOCATION NOT-MACLISP STYLE-CHECKER)
(DEFPROP FUNCTION-CELL-LOCATION NOT-MACLISP STYLE-CHECKER)
(DEFPROP FSET NOT-MACLISP STYLE-CHECKER)
(DEFPROP FBOUNDP NOT-MACLISP STYLE-CHECKER)
(DEFPROP FSYMEVAL NOT-MACLISP STYLE-CHECKER)
(DEFPROP CLOSURE NOT-MACLISP STYLE-CHECKER)

(DEFUN NOT-MACLISP (FORM)
    (AND RUN-IN-MACLISP-SWITCH
	 (WARN 'NOT-IN-MACLISP ':MACLISP
	       "~S is not implemented in Maclisp." (CAR FORM))))

(DEFUN (BREAK STYLE-CHECKER) (FORM)
  (IF (AND (CADR-SAFE FORM) (SYMBOLP (CADR-SAFE FORM)))
      (WARN 'BREAK-ARG ':OBSOLETE
	    "A symbol as the first argument to BREAK is an obsolete construct;
change it to a string before it stops working.")))

;Return with more than one argument won't work in Maclisp.
(DEFPROP RETURN RETURN-STYLE STYLE-CHECKER)
(DEFUN RETURN-STYLE (FORM)
    (AND RUN-IN-MACLISP-SWITCH
	 (CDDR FORM)
	 (WARN 'NOT-IN-MACLISP ':MACLISP
	       "Returning multiple values doesn't work in Maclisp")))

;Named PROGs don't work in Maclisp.  PROG variables can't be initialized.
;Also, lots of tags and things like a GO to a RETURN are ugly.
(DEFPROP PROG PROG-STYLE STYLE-CHECKER)
(DEFUN PROG-STYLE (FORM)
    (PROG (PROGNAME)
	  (AND (ATOM (CADR FORM))
	       (CADR FORM)
	       (PROGN (SETQ PROGNAME (CADR FORM))
		      (SETQ FORM (CDR FORM))))
	  (COND (RUN-IN-MACLISP-SWITCH
		 (AND PROGNAME (NEQ PROGNAME T)
		      (WARN 'NOT-IN-MACLISP ':MACLISP
			    "The PROG name ~S is used; PROG names won't work in Maclisp."
			    PROGNAME))
		 (DOLIST (VAR (CADR FORM))
		   (OR (ATOM VAR)
		       (RETURN
			 (WARN 'NOT-IN-MACLISP ':MACLISP
			       "The PROG variable ~S is initialized; this won't work in Maclisp."
			       (CAR VAR)))))))))

;; Check a LAMBDA for things that aren't allowed in Maclisp.
;; Called only if RUN-IN-MACLISP-SWITCH is set.
(DEFUN LAMBDA-STYLE (LAMBDA-EXP)
  (DO ((VARLIST (CADR LAMBDA-EXP) (CDR VARLIST)) (KWDBARF)) ((NULL VARLIST))
    (COND ((ATOM (CAR VARLIST))
	   (AND (NOT KWDBARF)
		(MEMQ (CAR VARLIST) LAMBDA-LIST-KEYWORDS)
		(SETQ KWDBARF T)
		(WARN 'NOT-IN-MACLISP ':MACLISP
		      "Lambda-list keywords such as ~S don't work in Maclisp."
		      (CAR VARLIST))))
	  (T (WARN 'NOT-IN-MACLISP ':MACLISP
		   "The lambda-variable ~S is initialized; this won't work in Maclisp."
		   (CAAR VARLIST))))))

(defun fix-synonym-special-form (form)
  (cons (function-name (fsymeval (car form))) (cdr form)))

;;; These functions are defined in ENCAPS, but loaded here
(add-optimizer si:encapsulation-let fix-synonym-special-form)
(add-optimizer si:encapsulation-list* fix-synonym-special-form)

(add-optimizer si:advise-prog fix-synonym-special-form)
(add-optimizer si:advise-setq fix-synonym-special-form)
(add-optimizer si:advise-progn fix-synonym-special-form)
(add-optimizer si:advise-multiple-value-list fix-synonym-special-form)
(add-optimizer si:advise-return-list fix-synonym-special-form)
(add-optimizer si:advise-apply fix-synonym-special-form)
(add-optimizer si:advise-let fix-synonym-special-form)
(add-optimizer si:advise-list* fix-synonym-special-form)

