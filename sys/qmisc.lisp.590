; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8 -*-
; Miscellaneous functions not worthy of being in qfctns, or not able to be in the cold load.
;	** (c) Copyright 1980 Massachusetts Institute of Technology **

(DEFVAR ROOM '(WORKING-STORAGE-AREA MACRO-COMPILED-PROGRAM)
  "Areas to mention when ROOM is called with no args.")

(DEFUN ROOM-GET-AREA-LENGTH-USED (AREA)
  (DO ((REGION (AREA-REGION-LIST AREA) (REGION-LIST-THREAD REGION))
       (N-REGIONS 0 (1+ N-REGIONS))
       (LENGTH 0 (+ LENGTH (24-BIT-UNSIGNED (REGION-LENGTH REGION))))
       (USED 0 (+ USED (24-BIT-UNSIGNED (REGION-FREE-POINTER REGION)))))
      ((MINUSP REGION)
       (RETURN LENGTH USED N-REGIONS))))

(DEFUN 24-BIT-UNSIGNED (N)
  "Convert fixnum, regarded as unsigned number, into number (maybe big) with same value.
If the argument is negative (if regarded as signed), it is expanded into a bignum."
  (IF (MINUSP N) (+ N (ASH (%LOGDPB 1 %%Q-BOXED-SIGN-BIT 0) 1)) N))

(DEFUN MAKE-24-BIT-UNSIGNED (N)
  "Convert N to a fixnum which, regarded as unsigned, has same value as N.
Thus, a number just too big to be a signed fixnum
becomes a fixnum which, if regarded as signed, would be negative."
  (COND ((= (%DATA-TYPE N) DTP-FIX) N)
	(T (LOGIOR (LDB (1- %%Q-POINTER) N)
		   (ROT (LDB (BYTE 1 (1- %%Q-POINTER)) N) -1)))))

(DEFUN ROOM-PRINT-AREA (AREA &AUX LENGTH USED N-REGIONS (PACKAGE (PKG-FIND-PACKAGE "SYSTEM")))
  (COND ((NOT (NULL (AREA-NAME AREA)))
	 (MULTIPLE-VALUE (LENGTH USED N-REGIONS) (ROOM-GET-AREA-LENGTH-USED AREA))
	 (IF (= (LDB %%REGION-SPACE-TYPE (REGION-BITS (AREA-REGION-LIST AREA)))
		%REGION-SPACE-FIXED)
	     (FORMAT T "~51,1,1,'.<~S~;(~D region~:P)~> ~O//~O used.  ~D% free.~%"
		     (AREA-NAME AREA) N-REGIONS USED LENGTH
		     (COND ((ZEROP LENGTH)
			    0)
			   ((< LENGTH 40000)
			    (TRUNCATE (* 100. (- LENGTH USED)) LENGTH))
			   (T
			    (TRUNCATE (- LENGTH USED) (TRUNCATE LENGTH 100.))) ))
	     (FORMAT T "~51,1,1,'.<~S~;(~D region~:P)~> ~DK allocated, ~DK used.~%"
		     (AREA-NAME AREA) N-REGIONS
		     (CEILING LENGTH 2000) (CEILING USED 2000)))))
  T)

;(ROOM) tells about the default areas
;(ROOM area1 area2...) tells about those areas
;(ROOM T) tells about all areas
;(ROOM NIL) prints only the header, does not do any areas
(DEFUN ROOM (&REST ARGS)
  "Print size and free space of some areas.
ARGS can be areas, or T as arg means all areas.
No args means use the areas whose names are members of the value of ROOM.
NIL as arg means print a header but mention no areas."
  (LET ((FREE-SIZE (GET-FREE-SPACE-SIZE))
	(PHYS-SIZE (SYSTEM-COMMUNICATION-AREA %SYS-COM-MEMORY-SIZE)))
    (FORMAT T "~&Physical memory: ~O (~DK), Free space: ~O (~DK)"
	      PHYS-SIZE (TRUNCATE PHYS-SIZE 2000) FREE-SIZE (TRUNCATE FREE-SIZE 2000)))
  (MULTIPLE-VALUE-BIND (N-WIRED-PAGES N-FIXED-WIRED-PAGES)
      (COUNT-WIRED-PAGES)
    (FORMAT T ", Wired pages ~D+~D (~D~[~;.25~;.5~;.75~]K)~%"
	      N-FIXED-WIRED-PAGES (- N-WIRED-PAGES N-FIXED-WIRED-PAGES)
	      (TRUNCATE N-WIRED-PAGES (TRUNCATE 2000 PAGE-SIZE))
	      (\ N-WIRED-PAGES (TRUNCATE 2000 PAGE-SIZE))))
  (COND ((NULL ARGS)
	 (SETQ ARGS ROOM))
	((EQUAL ARGS '(T))
	 (FORMAT T "Unless otherwise noted, area names are in the SYSTEM package~%")
	 (SETQ ARGS AREA-LIST)))
  (COND ((NOT (EQUAL ARGS '(NIL)))
	 (DOLIST (AREA ARGS)
	   (ROOM-PRINT-AREA (IF (SYMBOLP AREA) (SYMEVAL AREA) AREA))))))

;First value is total number of wired pages.  Second is number of fixed-wired pages.
(DEFUN COUNT-WIRED-PAGES ()
  (DO ((ADR (REGION-ORIGIN PAGE-TABLE-AREA) (+ ADR 2))
       (N (TRUNCATE (SYSTEM-COMMUNICATION-AREA %SYS-COM-PAGE-TABLE-SIZE) 2) (1- N))
       (N-WIRED 0))
      ((ZEROP N)
       (DO ((ADR (REGION-ORIGIN PHYSICAL-PAGE-DATA) (1+ ADR))
	    (N (TRUNCATE (SYSTEM-COMMUNICATION-AREA %SYS-COM-MEMORY-SIZE) PAGE-SIZE) (1- N))
	    (N-FIXED-WIRED 0))
	   ((ZEROP N)
	    (RETURN (+ N-WIRED N-FIXED-WIRED) N-FIXED-WIRED))
	 (AND (= (%P-LDB 0020 ADR) 177777)
	      ( (%P-LDB 2020 ADR) 177777)
	      (SETQ N-FIXED-WIRED (1+ N-FIXED-WIRED)))))
    (AND (NOT (ZEROP (%P-LDB %%PHT1-VALID-BIT ADR)))
	 (= (%P-LDB %%PHT1-SWAP-STATUS-CODE ADR) %PHT-SWAP-STATUS-WIRED)
	 (SETQ N-WIRED (1+ N-WIRED)))))

(DEFUN PRINT-AREAS-OF-WIRED-PAGES ()
  (DO ((ADR (REGION-ORIGIN PAGE-TABLE-AREA) (+ ADR 2))
       (N (TRUNCATE (SYSTEM-COMMUNICATION-AREA %SYS-COM-PAGE-TABLE-SIZE) 2) (1- N)))
      ((ZEROP N))
    (COND ((AND (NOT (ZEROP (%P-LDB %%PHT1-VALID-BIT ADR)))
		(= (%P-LDB %%PHT1-SWAP-STATUS-CODE ADR) %PHT-SWAP-STATUS-WIRED))
	   (FORMAT T "~S " (AREF (FUNCTION SYS:AREA-NAME)
				 (%AREA-NUMBER
				  (ASH (%P-LDB %%PHT1-VIRTUAL-PAGE-NUMBER ADR) 8))))))))


(DEFUN DESCRIBE-FEF-ADL (FEF &AUX (ADL (GET-MACRO-ARG-DESC-POINTER FEF)))
  (PROG (OPT-Q INIT-OPTION (ARGNUM 0) (LOCALNUM 0) ARGP
	 ARG-SYNTAX)
    L	(COND ((NULL ADL) (RETURN NIL)))
    	(SETQ OPT-Q (CAR ADL) ADL (CDR ADL))
	(SETQ ARG-SYNTAX (NTH (LDB %%FEF-ARG-SYNTAX OPT-Q)
			      FEF-ARG-SYNTAX))
	(SETQ ARGP (MEMQ ARG-SYNTAX
			 '(FEF-ARG-REQ FEF-ARG-OPT FEF-ARG-REST)))
	(COND ((NOT (ZEROP (LOGAND OPT-Q %FEF-NAME-PRESENT)))
	       (SETQ ADL (CDR ADL))))
	(COND ((EQ (NTH (LDB %%FEF-ARG-SYNTAX OPT-Q) FEF-ARG-SYNTAX) 'FEF-ARG-REST)
	       (FORMAT T "~&Rest arg (~A) is " (EH:REST-ARG-NAME FEF))
	       (INCF LOCALNUM))
	      (ARGP
	       (FORMAT T "~&Arg ~D (~A) is " ARGNUM (EH:ARG-NAME FEF ARGNUM))
	       (INCF ARGNUM))
	      ((EQ ARG-SYNTAX 'FEF-ARG-FREE)
	       (GO L))
	      ((EQ ARG-SYNTAX 'FEF-ARG-INTERNAL-AUX)
	       (RETURN NIL))
	      (T
	       (FORMAT T "~&Local ~D (~A) is " LOCALNUM (EH:LOCAL-NAME FEF LOCALNUM))
	       (INCF LOCALNUM)))
	(PRINC (OR (NTH (LDB %%FEF-ARG-SYNTAX OPT-Q)
			'("required, " "optional, "))
		   ""))
	(IF (EQ (NTH (LDB %%FEF-QUOTE-STATUS OPT-Q)
		     FEF-QUOTE-STATUS)
		'FEF-QT-QT)
	    (PRINC "quoted, "))
	(PRINC (NTH (LDB %%FEF-SPECIALNESS OPT-Q)
		    '("local, " "special, " "" "remote, ")))
;	(PRINC (NTH (LDB %%FEF-DES-DT OPT-Q)
;			       FEF-DES-DT))
	(SETQ INIT-OPTION (NTH (LDB %%FEF-INIT-OPTION OPT-Q)
			       FEF-INIT-OPTION))
	(SELECTQ INIT-OPTION
	  (FEF-INI-NIL (FORMAT T "initialized to NIL."))
	  (FEF-INI-NONE (FORMAT T "not initialized."))
	  (FEF-INI-SELF (FORMAT T "initialized by binding it to itself."))
	  (FEF-INI-COMP-C (FORMAT T "initialized by execution of the function."))
	  (FEF-INI-PNTR
	   (PRINC "initialized to ")
	   (LET ((COMPILER:DISASSEMBLE-OBJECT-OUTPUT-FUN NIL))
	     (COMPILER:DISASSEMBLE-POINTER FEF (%POINTER-DIFFERENCE ADL FEF) 0))
	   (PRINC ".")
	   (POP ADL))
	  (FEF-INI-C-PNTR
	   (LET ((LOC (CAR ADL))
		 (STR (%FIND-STRUCTURE-HEADER (CAR ADL))))
	     (COND ((SYMBOLP STR)
		    (FORMAT T "initialized to the ~A of ~S."
			    (SELECTQ (%POINTER-DIFFERENCE LOC STR)
			      (1 "value")
			      (2 "function definition")
			      (3 "property list")
			      (4 "package"))
			    STR))
		   ((CONSP STR)
		    (FORMAT T "initialized to the function definition of ~S."
			    (CAR STR)))
		   (T (FORMAT T "initialized to the contents of ~S." (CAR ADL)))))
	   (POP ADL))
	  (FEF-INI-EFF-ADR
	   (FORMAT T "initialized to the value of ")
	   (LET ((SLOT (LOGAND 77 (CAR ADL))))
	     (IF (= (LOGAND 700 (CAR ADL)) (GET 'COMPILER:LOCBLOCK 'COMPILER:QLVAL))
		 (FORMAT T "local ~D (~S)." SLOT (EH:LOCAL-NAME FEF SLOT))
	       (FORMAT T "arg ~D (~S)." SLOT (EH:ARG-NAME FEF SLOT))))
	   (POP ADL))
	  (FEF-INI-OPT-SA (FORMAT T "initialized by the code up to pc ~o." (CAR ADL))
			  (POP ADL)))
	(GO L)
))

(DEFUN DESCRIBE-STACK-GROUP (SG &AUX TEM)
  (FORMAT T "~%Stack Group; name is ~S, current state ~S"
	  (SG-NAME SG)
	  (NTH (SG-CURRENT-STATE SG) SG-STATES))
  (COND ((NOT (ZEROP (SG-IN-SWAPPED-STATE SG)))
	 (FORMAT T "~%  Variables currently swapped out")))
  (COND ((NOT (ZEROP (SG-FOOTHOLD-EXECUTING-FLAG SG)))
	 (FORMAT T "~%  Foothold currently executing")))
  (COND ((NOT (ZEROP (SG-PROCESSING-ERROR-FLAG SG)))
	 (FORMAT T "~% Currently processing an error")))
  (COND ((NOT (ZEROP (SG-PROCESSING-INTERRUPT-FLAG SG)))
	 (FORMAT T "~% Currently processing an interrupt")))
  (FORMAT T "~%ERROR-MODE:")
     (PRINT-ERROR-MODE (SG-SAVED-M-FLAGS SG))
  (FORMAT T "~%SG-SAFE ~D, SG-SWAP-SV-ON-CALL-OUT ~D, SG-SWAP-SV-OF-SG-THAT-CALLS-ME ~D"
	  (SG-SAFE SG)
	  (SG-SWAP-SV-ON-CALL-OUT SG)
	  (SG-SWAP-SV-OF-SG-THAT-CALLS-ME SG))
  (FORMAT T "~%SG-INST-DISP: ~D (~:*~[Normal~;Debug~;Single-step~;Single-step done~])"
	    (SG-INST-DISP SG))
  (FORMAT T 
      "~%SG-PREVIOUS-STACK-GROUP ~S, SG-CALLING-ARGS-NUMBER ~S, SG-CALLING-ARGS-POINTER ~S"
          (SG-PREVIOUS-STACK-GROUP SG)
	  (SG-CALLING-ARGS-NUMBER SG)
	  (SG-CALLING-ARGS-POINTER SG))
  (FORMAT T "~%Regular PDL pointer ~D, ~D available, ~D limit"
          (SG-REGULAR-PDL-POINTER SG)
	  (ARRAY-LENGTH (SG-REGULAR-PDL SG))
	  (SG-REGULAR-PDL-LIMIT SG))
  (FORMAT T "~%Special PDL pointer ~D, ~D available, ~D limit"
	  (SG-SPECIAL-PDL-POINTER SG)
	  (ARRAY-LENGTH (SG-SPECIAL-PDL SG))
	  (SG-SPECIAL-PDL-LIMIT SG))
  (COND ((SETQ TEM (SG-RECOVERY-HISTORY SG))
	 (FORMAT T "~%Recovery history ~S" TEM)))
  (COND ((SETQ TEM (SG-UCODE SG))
	 (FORMAT T "~%SG-UCODE ~S" TEM)))
)

(DEFUN DESCRIBE-FEF (FEF &AUX HEADER NAME FAST-ARG SV MISC LENGTH DBI)
   (COND ((SYMBOLP FEF)
	  (DESCRIBE-FEF (CAR (FUNCTION-CELL-LOCATION FEF))))
	 ((NEQ (%DATA-TYPE FEF) DTP-FEF-POINTER)
	  (FERROR NIL "~S is not a FEF" FEF))
	 (T
	  (SETQ HEADER (%P-LDB-OFFSET %%HEADER-REST-FIELD FEF %FEFHI-IPC))
	  (SETQ LENGTH (%P-CONTENTS-OFFSET FEF %FEFHI-STORAGE-LENGTH))
	  (SETQ NAME (%P-CONTENTS-OFFSET FEF %FEFHI-FCTN-NAME))
	  (SETQ FAST-ARG (%P-CONTENTS-OFFSET FEF %FEFHI-FAST-ARG-OPT))
	  (SETQ SV (%P-CONTENTS-OFFSET FEF %FEFHI-SV-BITMAP))
	  (SETQ MISC (%P-CONTENTS-OFFSET FEF %FEFHI-MISC))
	  
	  (FORMAT T "~%FEF for function ~S~%" NAME)
	  (IF (NOT (ZEROP (%P-LDB %%FEFH-GET-SELF-MAPPING-TABLE FEF)))
	      (FORMAT T "This is a method of flavor ~S.~%"
		      (%P-CONTENTS-OFFSET FEF (1- (%P-LDB-OFFSET %%FEFHI-MS-ARG-DESC-ORG
								 FEF %FEFHI-MISC)))))
	  (FORMAT T "Initial relative PC: ~S halfwords.~%" (LDB %%FEFH-PC HEADER))
; -- Print out the fast arg option
	  (FORMAT T "The Fast Argument Option is ~A"
		    (IF (ZEROP (LDB %%FEFH-FAST-ARG HEADER))
			"not active, but here it is anyway:"
			"active:"))
	  (DESCRIBE-NUMERIC-DESCRIPTOR-WORD FAST-ARG)
; -- Randomness.
	  (FORMAT T "~%The length of the local block is ~S~%"
		    (LDB %%FEFHI-MS-LOCAL-BLOCK-LENGTH MISC))
	  (FORMAT T "The total storage length of the FEF is ~S~%"
		    LENGTH)
; -- Special variables
	  (COND ((ZEROP (LDB %%FEFH-SV-BIND HEADER))
		 (PRINC "There are no special variables present."))
		(T (PRINC "There are special variables, ")
		   (TERPRI)
		   (COND ((ZEROP (LDB %%FEFHI-SVM-ACTIVE SV))
			  (PRINC "but the S-V bit map is not active. "))
			 (T (FORMAT T "and the S-V bit map is active and contains: ~O"
				      (LDB %%FEFHI-SVM-BITS SV))))))
          (TERPRI)
; -- ADL.
	  (COND ((ZEROP (LDB %%FEFH-NO-ADL HEADER))
		 (FORMAT T "There is an ADL:  It is ~S long, and starts at ~S"
			   (LDB %%FEFHI-MS-BIND-DESC-LENGTH MISC)
			   (LDB %%FEFHI-MS-ARG-DESC-ORG MISC))
		 (DESCRIBE-FEF-ADL FEF)
		 )
		(T (PRINC "There is no ADL.")))
	  (TERPRI)
	  (COND ((SETQ DBI (FUNCTION-DEBUGGING-INFO FEF))
		 (FORMAT T "Debugging info:~%")
		 (DOLIST (ITEM DBI)
		   (FORMAT T "  ~S~%" ITEM))))
	  )))

(DEFUN DESCRIBE-NUMERIC-DESCRIPTOR-WORD (N &AUX MIN MAX)
    (TERPRI)
    (PRINC "   ")
    (AND (BIT-TEST %ARG-DESC-QUOTED-REST N)
	 (PRINC "Quoted rest arg, "))
    (AND (BIT-TEST %ARG-DESC-EVALED-REST N)
	 (PRINC "Evaluated rest arg, "))
    (AND (BIT-TEST %ARG-DESC-FEF-QUOTE-HAIR N)
	 (PRINC "Some args quoted, "))
    (AND (BIT-TEST %ARG-DESC-INTERPRETED N)
	 (PRINC "Interpreted function, "))
    (AND (BIT-TEST %ARG-DESC-FEF-BIND-HAIR N)
	 (PRINC "Linear enter must check ADL, "))
    (SETQ MAX (LDB %%ARG-DESC-MAX-ARGS N))
    (SETQ MIN (LDB %%ARG-DESC-MIN-ARGS N))
    (COND ((= MAX MIN)
	   (PRINC MAX) (PRINC " args."))
	  (T
	   (PRINC "Takes between ") (PRINC MIN) (PRINC " and ") (PRINC MAX) (PRINC " args."))))


(DEFUN DESCRIBE-ARRAY (ARRAY &AUX ARRAYDIMS NDIMS LONG-LENGTH-FLAG)
    (COND ((SYMBOLP ARRAY)
	   (COND ((AND (BOUNDP ARRAY)
		       (ARRAYP (SYMEVAL ARRAY)))
		  (DESCRIBE-ARRAY (SYMEVAL ARRAY)))
		 ((AND (FBOUNDP ARRAY)
		       (ARRAYP (FSYMEVAL ARRAY)))
		  (DESCRIBE-ARRAY (FSYMEVAL ARRAY)))
		 (T NIL)))
	  ((ARRAYP ARRAY)
	   (FORMAT STANDARD-OUTPUT "~%This is a ~S type array." (ARRAY-TYPE ARRAY))
	   (SETQ ARRAYDIMS (ARRAY-DIMENSIONS ARRAY))
	   (SETQ NDIMS (LENGTH ARRAYDIMS))
	   (SETQ LONG-LENGTH-FLAG (%P-LDB-OFFSET %%ARRAY-LONG-LENGTH-FLAG ARRAY 0))
	   (COND ((> NDIMS 1)
		  (FORMAT STANDARD-OUTPUT "~%It is ~D-dimensional, with dimensions "
			  NDIMS)
		  (DO L ARRAYDIMS (CDR L) (NULL L)
		    (FORMAT STANDARD-OUTPUT "~S " (CAR L))))
		 (T (FORMAT STANDARD-OUTPUT "~%It is ~S long." (CAR ARRAYDIMS))
		    (AND (< (ARRAY-ACTIVE-LENGTH ARRAY) (CAR ARRAYDIMS))
			 (FORMAT STANDARD-OUTPUT "  Active length is ~S"
				 (ARRAY-ACTIVE-LENGTH ARRAY)))))
	   (AND (ARRAY-HAS-LEADER-P ARRAY)
		(FORMAT STANDARD-OUTPUT "~%It has a leader, of length ~S"
			(ARRAY-LEADER-LENGTH ARRAY)))
	   (COND ((ARRAY-DISPLACED-P ARRAY)
		  (COND ((ARRAY-INDIRECT-P ARRAY)
			 (FORMAT STANDARD-OUTPUT "~%The array is indirected to ~S"
				 (%P-CONTENTS-OFFSET ARRAY (+ NDIMS LONG-LENGTH-FLAG)))
			 (AND (ARRAY-INDEXED-P ARRAY)
			      (FORMAT STANDARD-OUTPUT ", with index-offset ~S"
				    (%P-CONTENTS-OFFSET ARRAY (+ NDIMS LONG-LENGTH-FLAG 2))))
			 (FORMAT STANDARD-OUTPUT "~%Description:")
			 (DESCRIBE-ARRAY (%P-CONTENTS-OFFSET ARRAY
							     (+ NDIMS LONG-LENGTH-FLAG))))
			(T (FORMAT STANDARD-OUTPUT "~%The array is displaced to ~S"
				   (%P-CONTENTS-OFFSET ARRAY (+ NDIMS LONG-LENGTH-FLAG))))))))
	  (T (FERROR NIL "~S is not an array" ARRAY))))

;DESCRIBE ANYTHING
(DEFUN DESCRIBE (ANYTHING &OPTIONAL NO-COMPLAINTS &AUX TYPE)
  "Describe the value or components of any Lisp object.
This is a good way to find out more than the printed representation says."
  (COND	((AND (NAMED-STRUCTURE-P ANYTHING)
	      (COND ((AND (GET (NAMED-STRUCTURE-P ANYTHING) 'NAMED-STRUCTURE-INVOKE)
			  (MEMQ ':DESCRIBE
				(NAMED-STRUCTURE-INVOKE ANYTHING ':WHICH-OPERATIONS)))
		     (NAMED-STRUCTURE-INVOKE ANYTHING ':DESCRIBE))
		    ((GET (SETQ TYPE (NAMED-STRUCTURE-P ANYTHING)) 'DEFSTRUCT-ITEMS)
		     (DESCRIBE-OLD-DEFSTRUCT TYPE ANYTHING))
		    ((GET (NAMED-STRUCTURE-P ANYTHING) 'DEFSTRUCT-DESCRIPTION)
		     (DESCRIBE-DEFSTRUCT ANYTHING)))))
	((OR (ENTITYP ANYTHING) (= (%DATA-TYPE ANYTHING) DTP-INSTANCE))
	 (FUNCALL ANYTHING ':DESCRIBE))
	((ARRAYP ANYTHING)
	 (DESCRIBE-ARRAY ANYTHING))
	((CLOSUREP ANYTHING)
	 (DESCRIBE-CLOSURE ANYTHING))
	((= (%DATA-TYPE ANYTHING) DTP-FEF-POINTER)
	 (DESCRIBE-FEF ANYTHING))
	((SYMBOLP ANYTHING)
	 (DESCRIBE-SYMBOL ANYTHING))
	((CONSP ANYTHING)
	 (DESCRIBE-LIST ANYTHING))
	((= (%DATA-TYPE ANYTHING) DTP-STACK-GROUP)
	 (DESCRIBE-STACK-GROUP ANYTHING))
	((SMALL-FLOATP ANYTHING)
	 (DESCRIBE-SMALL-FLONUM ANYTHING))
	((FLOATP ANYTHING)
	 (DESCRIBE-FLONUM ANYTHING))
        ((= (%DATA-TYPE ANYTHING) DTP-SELECT-METHOD)
         (DESCRIBE-SELECT-METHOD ANYTHING))
	((bigp anything)
	 (describe-bignum anything))
	((FIXP ANYTHING)
	 (FORMAT T "~%~R is ~[even~;odd~]" ANYTHING (LDB 0001 ANYTHING)))
	((RATIONALP ANYTHING)
	 (DESCRIBE-RATIONAL-NUMBER ANYTHING))
	((LOCATIVEP ANYTHING)
	 (DESCRIBE-LOCATIVE ANYTHING))
	((COMPLEXP ANYTHING)
	 (DESCRIBE-COMPLEX-NUMBER ANYTHING))
	((NOT NO-COMPLAINTS)
	 (FORMAT STANDARD-OUTPUT "~%I don't know how to describe ~S" ANYTHING)))
  (FUNCALL STANDARD-OUTPUT ':FRESH-LINE)
  ANYTHING)

(DEFUN DESCRIBE-1 (THING)	;AN INTERNAL SUBROUTINE
  (COND ((OR (NULL THING) ;Don't recursively describe relatively boring things
	     (NUMBERP THING) (SYMBOLP THING) (STRINGP THING))
	 NIL)
	(T (LET ((STANDARD-OUTPUT	;Arrange for indentation by 4 spaces
		   (CLOSURE '(STANDARD-OUTPUT)
		     #'(LAMBDA (&REST ARGS)
			  ;; Have to do it this way rather than with PROG1
			  ;; due to multiple-values not getting passed back
			  ;; This vile kludgery seems to be the only way to get it to work
			  ;; due to various things shafting me left and right.
			  (PROG (X1 X2 X3 X4 X5)
			    (MULTIPLE-VALUE (X1 X2 X3 X4 X5)
			       (APPLY STANDARD-OUTPUT ARGS))
			    (AND (EQ (CAR ARGS) ':TYO) (= (CADR ARGS) #\CR)
				 (FUNCALL STANDARD-OUTPUT ':STRING-OUT "    "))
			    (RETURN X1 X2 X3 X4 X5))))))
	     (DESCRIBE THING T))
	   (FUNCALL STANDARD-OUTPUT ':FRESH-LINE))))

(DEFUN DESCRIBE-SYMBOL (SYM)
  (FORMAT T "~%Symbol ~S is in ~:[no~;the ~:*~A~] package." SYM (SYMBOL-PACKAGE SYM))
  (COND ((BOUNDP SYM)
	 (LET ((PRINLEVEL 2) (PRINLENGTH 3))
	   (FORMAT STANDARD-OUTPUT "~%The value of ~S is ~S" SYM (SYMEVAL SYM)))
	 (DESCRIBE-1 (SYMEVAL SYM))))
  (COND ((FBOUNDP SYM)
	 (LET ((PRINLEVEL 2) (PRINLENGTH 3))
	   (IGNORE-ERRORS
	    (FORMAT STANDARD-OUTPUT "~%The function definition of ~S is ~S: ~S"
		    SYM (FSYMEVAL SYM) (ARGLIST SYM))))
	 (DESCRIBE-1 (FSYMEVAL SYM))))
  (DO ((PL (PLIST SYM) (CDDR PL))
       (PRINLEVEL 2)
       (PRINLENGTH 3))
      ((NULL PL))
    (FORMAT STANDARD-OUTPUT "~%~S has property ~S: ~S"
	    SYM (CAR PL) (CADR PL))
    (DESCRIBE-1 (CADR PL)))
  (IF (NOT (OR (BOUNDP SYM) (FBOUNDP SYM) (PLIST SYM)))
      (FORMAT T "~%It has no value, definition or properties"))
  NIL)

(DEFUN DESCRIBE-LIST (L)
  (FORMAT STANDARD-OUTPUT "~%~S is a list" L))

(DEFUN DESCRIBE-LOCATIVE (X)
  (LET ((AREA (%AREA-NUMBER X)))
    (COND (AREA
	   (FORMAT T "~%~S is a locative pointer into area ~S~%It points "
		     X (AREA-NAME AREA))
	   (LET* ((STRUC (%FIND-STRUCTURE-HEADER X))
		  (BASEP (%POINTER (%FIND-STRUCTURE-LEADER STRUC)))
		  (BOUND (+ (%STRUCTURE-TOTAL-SIZE STRUC) BASEP)))
	     (IF (AND ( BASEP (%POINTER X)) (< (%POINTER X) BOUND))
		 (FORMAT T "to word ~O of ~S~%" (%POINTER-DIFFERENCE X STRUC) STRUC)
		 (FORMAT T "at some sort of forwarded version of ~S~%" STRUC))
	     (DESCRIBE-1 STRUC)))
	  (T (FORMAT T "~%~S is a locative pointer not into any area." X)))))

(DEFUN DESCRIBE-OLD-DEFSTRUCT (SYMBOL X)
  (FORMAT T "~%~S is a ~S~%" X SYMBOL)
  (DO L (GET SYMBOL 'DEFSTRUCT-ITEMS) (CDR L) (NULL L)
      (FORMAT T "   ~30A~S~%"
	      (STRING-APPEND (CAR L) ":")
	      (EVAL `(,(CAR L) ',X)))))

(DEFUN DESCRIBE-DEFSTRUCT (X &OPTIONAL DEFSTRUCT-TYPE &AUX DESCRIPTION)
  (SETQ DESCRIPTION (GET (OR DEFSTRUCT-TYPE
			     (IF (CONSP X) (CAR X)
			       (NAMED-STRUCTURE-P X)))
			 'DEFSTRUCT-DESCRIPTION))
  (FORMAT T "~%~S is a ~S~%" X (DEFSTRUCT-DESCRIPTION-NAME))
  (DO L (DEFSTRUCT-DESCRIPTION-SLOT-ALIST) (CDR L) (NULL L)
      (FORMAT T "   ~30A~S~%"
	      (STRING-APPEND (CAAR L) ":")
	      (EVAL `(,(DEFSTRUCT-SLOT-DESCRIPTION-REF-MACRO-NAME (CDAR L)) ',X))))
  X)

(DEFUN DESCRIBE-CLOSURE (CL)
  (LET ((C (%MAKE-POINTER DTP-LIST CL))
	(SYM NIL) (OFFSET NIL))
    (FORMAT T "~%~S is a closure of ~S:~%" CL (CAR C))
    (DO L (CDR C) (CDDR L) (NULL L)
	(SETQ SYM (%FIND-STRUCTURE-HEADER (CAR L))
	      OFFSET (%POINTER-DIFFERENCE (CAR L) SYM))
	(FORMAT T
		"   ~A cell of ~S: ~40T~:[unbound~;~S~]~%"
		(SELECTQ OFFSET
		  (0 "Print name") (1 "Value") (2 "Function")
		  (3 "Property list") (4 "Package"))
		SYM
		(LOCATION-BOUNDP (CADR L))
		(AND (LOCATION-BOUNDP (CADR L))
		     (CAADR L))))
    (DESCRIBE-1 (CAR C))
    ))

(DEFUN DESCRIBE-SELECT-METHOD (M)
  (FORMAT T "~%~S handles:" M)
  (DO ((ML (%MAKE-POINTER DTP-LIST M) (CDR ML)))
      ((ATOM ML)
       (COND (ML
	      (FORMAT T "~%   anything else to ~S" ML)
	      (COND ((SYMBOLP ML)
		     (AND (BOUNDP ML) (FORMAT T "  -> ~S" (SYMEVAL ML))) ;probably a class
		     )))))
    (COND ((ATOM (CAR ML)) (FORMAT T "~%   subroutine ~S" (CAR ML)))
          (T (FORMAT T "~%   ~S: ~34T" (CAAR ML))
	     (OR (EQ (FUNCTION-NAME (CDAR ML)) (CDAR ML))
		 (PRINC "#'"))
	     (PRIN1 (FUNCTION-NAME (CDAR ML)))))))

(DEFUN DESCRIBE-SMALL-FLONUM (X)
  (FORMAT T "~%~S is a small flonum.~%  " X)
  (FORMAT T "Excess-100 exponent ~O, 17-bit mantissa ~O (with sign bit deleted)"
	    (LDB 2107 (%POINTER X)) (LDB 0021 (%POINTER X))))

(DEFUN DESCRIBE-FLONUM (X)
  (FORMAT T "~%~S is a flonum.~%  " X)
  (FORMAT T "Excess-2000 exponent ~O, 32-bit mantissa ~O~4,48O~4,48O (including sign)"
	       (%P-LDB-OFFSET 1013 X 0)
	       (%P-LDB-OFFSET 0010 X 0)
	       (%P-LDB-OFFSET 1414 X 1)
	       (%P-LDB-OFFSET 0014 X 1)))

(defun describe-bignum (x)
  (let ((len (%p-ldb-offset #o0022 x 0))
	(barf nil))
    (format t "~&~S is a bignum.~&It is ~R word~:P long.  It is ~[positive~;negative~].  ~
                 It is stored starting at location: ~O~&Its contents:~2%"
	    x len (%p-ldb-offset #o2201 x 0) (%pointer x))
    (do ((i 1 (1+ i)))
	((> i len))
      (or (zerop (%p-ldb-offset #o3701 x i))
	  (setq barf t))
      (format t "~&~3O: ~[ ~;*~]"
	      i (%p-ldb-offset #o3701 x i))
      (do ((ppss #o3601 (- ppss #o0100)))
	  ((< ppss #o0001))
	(tyo (+ #/0 (%p-ldb-offset ppss x i))))
      (format t "  ~O," (%p-ldb-offset #o3601 x i))
      (do ((ppss #o3303 (- ppss #o0300)))
	  ((< ppss #o0003))
	(tyo (+ #/0 (%p-ldb-offset ppss x i))))
      (princ "  ")
      (do ((ppss #o3403 (- ppss #o0300)))
	  ((< ppss #o0103))
	(tyo (+ #/0 (%p-ldb-offset ppss x i))))
      (format t ",~O  ~O," (%p-ldb-offset #o0001 x i) (%p-ldb-offset #o3502 x i))
      (do ((ppss #o3203 (- ppss #o0300)))
	  ((< ppss #o0203))
	(tyo (+ #/0 (%p-ldb-offset ppss x i))))
      (format t ",~O" (%p-ldb-offset #o0002 x i)))
    (if barf
	(format t "~2&* = high order bit illegally 1, bug in bignum microcode?"))
    (terpri))
  x)

(DEFUN DESCRIBE-AREA (AREA &AUX LENGTH USED N-REGIONS)
  "Tell all about the area AREA, including all its regions."
  (AND (NUMBERP AREA) (SETQ AREA (AREA-NAME AREA)))
  (DO AREA-NUMBER 0 (1+ AREA-NUMBER) (> AREA-NUMBER SIZE-OF-AREA-ARRAYS)
    (COND ((EQ AREA (AREA-NAME AREA-NUMBER))
	   (MULTIPLE-VALUE (LENGTH USED N-REGIONS) (ROOM-GET-AREA-LENGTH-USED AREA-NUMBER))
	   (FORMAT T "~&Area #~O: ~S has " 
		   AREA-NUMBER AREA)
	   (OR (= (AREA-MAXIMUM-SIZE AREA-NUMBER)
		  (%LOGDPB 0 %%Q-BOXED-SIGN-BIT -1))
	       (FORMAT T "max size ~O, " (AREA-MAXIMUM-SIZE AREA-NUMBER)))
	   (FORMAT T "region size ~O." (AREA-REGION-SIZE AREA-NUMBER))
	   (OR (ZEROP (AREA-SWAP-RECOMMENDATIONS AREA-NUMBER))
	       (FORMAT T "  Swap ~D pages." (AREA-SWAP-RECOMMENDATIONS AREA-NUMBER)))
	   (TERPRI)
	   (IF (AREA-TEMPORARY-P AREA-NUMBER)
	       (FORMAT T "It is a temporary area.  "))
	   (FORMAT T "It has ~D region~P:~%" N-REGIONS N-REGIONS)
	   (DO ((REGION (AREA-REGION-LIST AREA-NUMBER) (REGION-LIST-THREAD REGION)))
	       ((MINUSP REGION))
	     (DESCRIBE-REGION REGION))
	   (RETURN T)))))

(DEFUN DESCRIBE-ALL-REGIONS NIL
  "Tell all about all regions."
  (DO REGION SIZE-OF-AREA-ARRAYS (1- REGION) (MINUSP REGION)
      (DESCRIBE-REGION REGION)))

(DEFUN DESCRIBE-REGION (REGION)
  "Tell all about the region number REGION."
  (LET ((BITS (REGION-BITS REGION)))
    (FORMAT T "  Region #~O: Origin ~O, Length ~O, Used ~O, GC ~O, Type ~A ~A, Map ~O,~[NoScav~;Scav~]~%"
	    REGION (REGION-ORIGIN-TRUE-VALUE REGION) (REGION-LENGTH REGION)
	    (REGION-FREE-POINTER REGION) (REGION-GC-POINTER REGION)
	    (NTH (LDB %%REGION-REPRESENTATION-TYPE BITS)
		 '(LIST STRUC "REP=2" "REP=3"))
	    (NTH (LDB %%REGION-SPACE-TYPE BITS)
		 '(FREE OLD NEW NEW1 NEW2 NEW3 NEW4 NEW5 NEW6
			STATIC FIXED EXTRA-PDL COPY "TYPE=15" "TYPE=16" "TYPE=17"))
	    (LDB %%REGION-MAP-BITS BITS)
	    (LDB %%REGION-SCAVENGE-ENABLE BITS))))

(DEFUN DESCRIBE-RATIONAL-NUMBER (NUMBER)
  (FORMAT T "~&~S is a rational number with numerator ~S and denominator ~S"
	  NUMBER (NUMERATOR NUMBER) (DENOMINATOR NUMBER)))

(DEFUN DESCRIBE-COMPLEX-NUMBER (NUMBER)
  (FORMAT T "~&~S is a complex number with real part ~S and imaginary part ~S.
Its conjugate is ~S."
	  NUMBER (REALPART NUMBER) (IMAGPART NUMBER) (CONJUGATE NUMBER)))

(DEFUN SET-MEMORY-SIZE (NEW-SIZE)
  "Specify how much main memory is to be used, in pages.
By default, all the memory on the machine is used.
This is mainly useful running benchmarks with different memory sizes.
If you specify more memory than is present on the machine,
new memory boards are constructed; in the meantime, the machine crashes."
  (PROG (OLD-SIZE NEWP OLDP)
	(COND ((< NEW-SIZE (+ (SYSTEM-COMMUNICATION-AREA %SYS-COM-WIRED-SIZE) 20000)) ;8K MIN
	       (FERROR NIL "~O is smaller than wired + 8K"  NEW-SIZE)))
    L   (SETQ OLD-SIZE (SYSTEM-COMMUNICATION-AREA %SYS-COM-MEMORY-SIZE))
        (SETQ OLDP (CEILING OLD-SIZE PAGE-SIZE))
        (SETQ NEWP (CEILING NEW-SIZE PAGE-SIZE))
	(COND ((OR (> NEWP (REGION-LENGTH PHYSICAL-PAGE-DATA))
		   (> NEWP (TRUNCATE (* 4 (REGION-LENGTH PAGE-TABLE-AREA)) 9)))
	       (FERROR NIL "~O is bigger than page tables allow"  NEW-SIZE))
	      ((= NEWP OLDP) (RETURN T))
              ((< NEWP OLDP) (GO FLUSH)))
  MORE  (COND ((%DELETE-PHYSICAL-PAGE OLD-SIZE)
               (PRINT (LIST OLD-SIZE "EXISTED"))))
        (%CREATE-PHYSICAL-PAGE OLD-SIZE)
	(SETF (SYSTEM-COMMUNICATION-AREA %SYS-COM-MEMORY-SIZE)
	      (+ OLD-SIZE PAGE-SIZE))
        (GO L)

  FLUSH (COND ((NULL (%DELETE-PHYSICAL-PAGE (- OLD-SIZE PAGE-SIZE)))
               (PRINT (LIST (- OLD-SIZE PAGE-SIZE) "DID-NOT-EXIST"))))
	(SETF (SYSTEM-COMMUNICATION-AREA %SYS-COM-MEMORY-SIZE)
	      (- OLD-SIZE PAGE-SIZE))
        (GO L)))

(DEFUN SET-ERROR-MODE (&OPTIONAL (CAR-SYM-MODE 1) (CDR-SYM-MODE 1)
			         (CAR-NUM-MODE 0) (CDR-NUM-MODE 0))
       (SETQ %MODE-FLAGS (%LOGDPB CAR-SYM-MODE %%M-FLAGS-CAR-SYM-MODE %MODE-FLAGS))
       (SETQ %MODE-FLAGS (%LOGDPB CDR-SYM-MODE %%M-FLAGS-CDR-SYM-MODE %MODE-FLAGS))
       (SETQ %MODE-FLAGS (%LOGDPB CAR-NUM-MODE %%M-FLAGS-CAR-NUM-MODE %MODE-FLAGS))
       (SETQ %MODE-FLAGS (%LOGDPB CDR-NUM-MODE %%M-FLAGS-CDR-NUM-MODE %MODE-FLAGS)))

(DEFUN PRINT-ERROR-MODE (&OPTIONAL (EM %MODE-FLAGS) (STREAM STANDARD-OUTPUT))
  (FORMAT STREAM
	  "CAR of a number is ~A.~%CDR of a number is ~A.~%CAR of a symbol is ~A.~%CDR of a symbol is a ~A.~%Trapping is ~A.~%"
	  (SELECTQ (LDB %%M-FLAGS-CAR-NUM-MODE EM)
	      (0 "an error")
	      (1 "NIL")
	      (OTHERWISE "in an unknown state"))
	  (SELECTQ (LDB %%M-FLAGS-CDR-NUM-MODE EM)
	      (0 "an error")
	      (1 "NIL")
	      (OTHERWISE "in an unknown state"))
	  (SELECTQ (LDB %%M-FLAGS-CAR-SYM-MODE EM)
	      (0 "an error")
	      (1 "NIL if the symbol is NIL, otherwise an error")
	      (2 "NIL")
	      (3 "its print-name"))
	  (SELECTQ (LDB %%M-FLAGS-CDR-SYM-MODE EM)
	      (0 "an error")
	      (1 "NIL if the symbol is NIL, otherwise an error")
	      (2 "NIL")
	      (3 "its property list"))
	  (SELECTQ (LDB %%M-FLAGS-TRAP-ENABLE EM)
	      (0 "disabled")
	      (1 "enabled"))
	  ))

(DEFUN APROPOS-LIST (SUBSTRING &OPTIONAL PKG)
  "Return a list of symbols whose names contain SUBSTRING, but don't print anything.
Like APROPOS with :DONT-PRINT specified as non-NIL."
  (APROPOS SUBSTRING ':PACKAGE PKG ':DONT-PRINT T))

(DEFUN APROPOS (SUBSTRING &REST ARGS &KEY &OPTIONAL ((:PACKAGE PKG))
		(INHERITORS NIL) (INHERITED T) DONT-PRINT
		PREDICATE &ALLOW-OTHER-KEYS)
  "Find all symbols in one or more packages whose names contain SUBSTRING, or
containing each string in it, if SUBSTRING is a list of strings.
If PREDICATE is non-NIL, it is a function to be called with a symbol as arg;
only symbols for which the predicate returns non-NIL will be mentioned.
The :PACKAGE argument defaults to NIL, meaning do all packages.
The packages which USE that package are processed also, unless :INHERITORS is NIL.
The packages USEd by that package are processed also, unless :INHERITED is NIL.
/(Any other packages which inherit from them also are NOT processed in any case.)
The symbols are printed unless DONT-PRINT is set.
A list of the symbols found is returned."
  (DECLARE (ARGLIST SUBSTRING &KEY &OPTIONAL ((:PACKAGE PKG))
		    (INHERITORS NIL) (INHERITED T) DONT-PRINT
		    PREDICATE)
	   (SPECIAL RETURN-LIST APROPOS-PREDICATE APROPOS-SUBSTRING APROPOS-DONT-PRINT))
  (IF (= (LENGTH ARGS) 1)
      (SETQ PKG (CAR ARGS)))
  (SETQ PKG (IF (NULL PKG) PKG-GLOBAL-PACKAGE (PKG-FIND-PACKAGE PKG)))
  (LET (RETURN-LIST
	(APROPOS-PREDICATE PREDICATE)
	(APROPOS-DONT-PRINT DONT-PRINT)
	(APROPOS-SUBSTRING SUBSTRING))
    (COND (PKG
	   (MAPATOMS #'APROPOS-1 PKG INHERITED)
	   (AND INHERITORS
		(DOLIST (P (PACKAGE-USED-BY-LIST PKG))
		  (MAPATOMS #'APROPOS-1 P))))
	  (T
	   (DOLIST (P *ALL-PACKAGES*)
	     (MAPATOMS #'APROPOS-1 P))))
    RETURN-LIST))

(DEFUN APROPOS-1 (SYMBOL &AUX (P (GET-PNAME SYMBOL)))
  (DECLARE (SPECIAL RETURN-LIST APROPOS-PREDICATE APROPOS-SUBSTRING APROPOS-DONT-PRINT))
  (COND ((AND (IF (LISTP APROPOS-SUBSTRING)
		  (DOLIST (S APROPOS-SUBSTRING T)
		    (UNLESS (STRING-SEARCH S P) (RETURN NIL)))
		(STRING-SEARCH APROPOS-SUBSTRING P))
	      (NOT (MEMQ SYMBOL RETURN-LIST))
	      (OR (NULL APROPOS-PREDICATE)
		  (FUNCALL APROPOS-PREDICATE SYMBOL)))
	 (PUSH SYMBOL RETURN-LIST)
	 (OR APROPOS-DONT-PRINT
	     (PROGN
	       ;; Binding the package to NIL forces the package to be printed.
	       ;; This is better than explicitly printing the package, because
	       ;; this way you get the "short" version.
	       (LET ((PACKAGE NIL))
		 (FORMAT T "~%~S" SYMBOL))
	       (AND (FBOUNDP SYMBOL)
		    (FORMAT T " - Function ~:S" (ARGLIST SYMBOL)))
	       (AND (BOUNDP SYMBOL)
		    (COND ((FBOUNDP SYMBOL) (PRINC ", Bound"))
			  (T (PRINC " - Bound"))))
	       (AND (GET SYMBOL 'FLAVOR)
		    (COND ((OR (BOUNDP SYMBOL) (FBOUNDP SYMBOL))
			   (PRINC ", Flavor"))
			  (T (PRINC " - Flavor")))))))))

(DEFUN SUB-APROPOS (SUBSTRING STARTING-LIST &KEY &OPTIONAL PREDICATE DONT-PRINT)
  "Find all symbols in STARTING-LIST whose names contain SUBSTRING, or
containing each string in it, if SUBSTRING is a list of strings.
If :PREDICATE is set, it should be a function of one arg;
only symbols for which the predicate returns non-NIL are included.
The symbols are printed unless :DONT-PRINT is set.
A list of the symbols found is returned."
  (DECLARE (SPECIAL RETURN-LIST APROPOS-PREDICATE APROPOS-SUBSTRING APROPOS-DONT-PRINT))
  (LET (RETURN-LIST
	(APROPOS-PREDICATE PREDICATE)
	(APROPOS-SUBSTRING SUBSTRING)
	(APROPOS-DONT-PRINT DONT-PRINT))
    (MAPC 'APROPOS-1 STARTING-LIST)
    RETURN-LIST))

(DEFUN SYMEVAL-IN-CLOSURE (CLOSURE PTR)
  "Return the value which the symbol or value cell locative PTR has in CLOSURE.
More precisely, the value which is visible within CLOSURE is returned.
If CLOSURE does not contain a binding for it, the current value is returned."
  (CHECK-ARG CLOSURE (OR (CLOSUREP CLOSURE) (ENTITYP CLOSURE)) "a closure or an entity")
  (CHECK-ARG PTR (COND ((SYMBOLP PTR) (SETQ PTR (VALUE-CELL-LOCATION PTR)))
		       ((= (%DATA-TYPE PTR) DTP-LOCATIVE)))
	         "a symbol or a locative")
  (DO ((L (CDR (%MAKE-POINTER DTP-LIST CLOSURE)) (CDDR L)))
      ((NULL L)
       (CAR PTR))
    (AND (EQ (CAR L) PTR)
	 (RETURN (CAADR L)))))

(DEFUN BOUNDP-IN-CLOSURE (CLOSURE PTR &AUX PTR1)
  "T if the symbol or value cell locative PTR is BOUNDP within CLOSURE.
More precisely, the binding which is visible within CLOSURE is tested.
If CLOSURE does not contain a binding for it, the current binding is tested."
  (CHECK-ARG CLOSURE (OR (CLOSUREP CLOSURE) (ENTITYP CLOSURE)) "a closure or an entity")
  (CHECK-ARG PTR (OR (SYMBOLP PTR) (LOCATIVEP PTR))
	         "a symbol or a locative")
  (SETQ PTR1 (IF (SYMBOLP PTR) (LOCF (SYMEVAL PTR)) PTR))
  (DO ((L (CDR (%MAKE-POINTER DTP-LIST CLOSURE)) (CDDR L)))
      ((NULL L)
       (LOCATION-BOUNDP PTR1))
    (AND (EQ (CAR L) PTR1)
	 (RETURN (LOCATION-BOUNDP (CADR L))))))

(DEFUN MAKUNBOUND-IN-CLOSURE (CLOSURE PTR &AUX PTR1)
  "Make the symbol or value cell locative PTR unbound in CLOSURE.
More precisely, the binding which is visible within CLOSURE is made unbound.
If CLOSURE does not contain a binding for it, the current binding is made unbound."
  (CHECK-ARG CLOSURE (OR (CLOSUREP CLOSURE) (ENTITYP CLOSURE)) "a closure or an entity")
  (CHECK-ARG PTR (OR (SYMBOLP PTR) (LOCATIVEP PTR))
	         "a symbol or a locative")
  (SETQ PTR1 (IF (SYMBOLP PTR) (LOCF (SYMEVAL PTR)) PTR))
  (DO ((L (CDR (%MAKE-POINTER DTP-LIST CLOSURE)) (CDDR L)))
      ((NULL L)
       (IF (SYMBOLP PTR) (MAKUNBOUND PTR)
	 (LOCATION-MAKUNBOUND PTR)))
    (COND ((EQ (CAR L) PTR1)
	   (RETURN (LOCATION-MAKUNBOUND (CADR L))))))
  NIL)

(DEFUN LOCATE-IN-CLOSURE (CLOSURE PTR)
  "Return the location of the value which the symbol or value cell locative PTR has in CLOSURE.
More precisely, the location of the binding visible within CLOSURE is returned.
If CLOSURE does not contain a binding for it, the value cell
locative itself, or the symbol's value cell location, is returned."
  (CHECK-ARG CLOSURE (OR (CLOSUREP CLOSURE) (ENTITYP CLOSURE)) "a closure or an entity")
  (CHECK-ARG PTR (COND ((SYMBOLP PTR) (SETQ PTR (VALUE-CELL-LOCATION PTR)))
		       ((= (%DATA-TYPE PTR) DTP-LOCATIVE)))
	         "a symbol or a locative")
  (DO ((L (CDR (%MAKE-POINTER DTP-LIST CLOSURE)) (CDDR L)))
      ((NULL L)
       PTR)
    (AND (EQ (CAR L) PTR)
	 (RETURN (CADR L)))))

(DEFUN SET-IN-CLOSURE (CLOSURE PTR VAL)
  "Set the value which the symbol or value cell locative PTR has in CLOSURE to VAL.
More precisely, the binding which is visible within CLOSURE is set.
If CLOSURE does not contain a binding for it, the current binding is set."
  (CHECK-ARG CLOSURE (OR (CLOSUREP CLOSURE) (ENTITYP CLOSURE)) "a closure or an entity")
  (CHECK-ARG PTR (COND ((SYMBOLP PTR) (SETQ PTR (VALUE-CELL-LOCATION PTR)))
		       ((= (%DATA-TYPE PTR) DTP-LOCATIVE)))
	         "a symbol or a locative")
  (DO ((L (CDR (%MAKE-POINTER DTP-LIST CLOSURE)) (CDDR L)))
      ((NULL L)
       (RPLACA PTR VAL))
    (COND ((EQ (CAR L) PTR)
	   (RETURN (RPLACA (CADR L) VAL)))))
  VAL)

(DEFUN CLOSUREP (X)
  "T if X is a closure."
  (= (%DATA-TYPE X) DTP-CLOSURE))

(DEFUN ENTITYP (X)
  "T if X is an entity."
  (= (%DATA-TYPE X) DTP-ENTITY))

(DEFVAR ARRAY-ORDER-INITIALIZATION-LIST NIL
  "Initialization list run after changing the value of ARRAY-INDEX-ORDER.")

(DEFUN MAKE-PIXEL-ARRAY (WIDTH HEIGHT &REST OPTIONS)
  "Make a pixel array of WIDTH by HEIGHT.  You must specify :TYPE as in MAKE-ARRAY.
This will create an array of the apropriate shape and knows whether
the height is supposed to be the first dimension or the second.
Access the resulting array with AR-2-REVERSE and AS-2-REVERSE to make sure
that accessing also is independent of array dimension order."
  (LEXPR-FUNCALL 'MAKE-ARRAY
		 (IF ARRAY-INDEX-ORDER (LIST HEIGHT WIDTH) (LIST WIDTH HEIGHT))
		 OPTIONS))

(DEFUN PIXEL-ARRAY-WIDTH (ARRAY)
  "Return the width in pixels of an array of pixels.
The width is the dimension which varies more faster."
  (ARRAY-DIMENSION ARRAY (IF ARRAY-INDEX-ORDER 1 0)))

(DEFUN PIXEL-ARRAY-HEIGHT (ARRAY)
  "Return the height in pixels of an array of pixels.
The height is the dimension which varies more slowly."
  (ARRAY-DIMENSION ARRAY (IF ARRAY-INDEX-ORDER 0 1)))

;ARRAY-POP, eventually to be micro-coded
;UNDOES (ARRAY-PUSH ARRAY <DATA>) AND RETURNS <DATA>
(DEFUN ARRAY-POP (ARRAY)
  "Returns the last used element of ARRAY, and decrements the fill pointer.
For an ART-Q-LIST array, the cdr codes are updated
so the overlayed list no longer contains the element removed."
  (PROG (IDX VAL ARRAY-TYPE (INHIBIT-SCHEDULING-FLAG T))
	(COND ((ZEROP (SETQ IDX (ARRAY-LEADER ARRAY 0)))
	       (FERROR NIL "~S Overpopped" ARRAY)))
	(SETQ ARRAY-TYPE (AR-1 (FUNCTION ARRAY-TYPES)
			       (%P-LDB-OFFSET %%ARRAY-TYPE-FIELD ARRAY 0)))
	(SETQ VAL (AR-1 ARRAY (SETQ IDX (1- IDX))))	;1- BECAUSE IDX IS # ACTIVE ELEMENTS
	(COND ((MEMQ ARRAY-TYPE '(ART-Q ART-Q-LIST))
	       (AS-1 NIL ARRAY IDX)))   ;FLUSH SO NOT THERE FOR GC (HA HA)
	(STORE-ARRAY-LEADER IDX ARRAY 0)
	(COND ((AND (EQ ARRAY-TYPE 'ART-Q-LIST)
		    (NOT (ZEROP IDX)))
	       (%P-DPB CDR-NIL %%Q-CDR-CODE (AP-1 ARRAY (1- IDX)))))
	(RETURN VAL)))

(DEFF VECTOR-POP #'ARRAY-POP)

;; Called by ucode thru support vector when a named structure is funcalled.
;; ARGS are operation and the associated args.
;; The structure was pushed on the pdl after the last arg - ugh.
(DEFUN CALL-NAMED-STRUCTURE (&REST ARGS)
  (LET ((TEM (LAST ARGS)))
    (LEXPR-FUNCALL 'NAMED-STRUCTURE-INVOKE (CAR ARGS) (%P-CONTENTS-OFFSET TEM 1)
		   (CDR ARGS))))

;;; The following definitions of FILLARRAY and LISTARRAY should be completely
;;; compatible with Maclisp.  Slow, maybe, but compatible.

;;; When filling from an array, extra elements in the destination get the default initial
;;; value for the array type.  When filling from a list it sticks at the last element.
;;; Extra elements in the source are ignored.  copy-array-contents
;;; does the right thing for one-d arrays, but for multi-dimensional arrays
;;; uses column-major rather than row-major order.

(DEFRESOURCE FILLARRAY-INDEX-ARRAYS ()
	:CONSTRUCTOR (MAKE-ARRAY 10)
	:INITIAL-COPIES 2)

(DEFUN FILLARRAY (ARRAY SOURCE)
  "Fill the contents of ARRAY from SOURCE.
If SOURCE is a list or array, its elements are used over and over until ARRAY is all filled.
If SOURCE is NIL, the default element value is used; this is 0, 0.0 or NIL.
If ARRAY is NIL, a new list as big as SOURCE is created."
  (LET ((DEST (COND ((NULL ARRAY)
		     (SETQ ARRAY
			   (MAKE-ARRAY
			     (COND ((NULL SOURCE) 0)
				   ((LISTP SOURCE) (LENGTH SOURCE))
				   ((ARRAYP SOURCE) (ARRAY-DIMENSIONS SOURCE))
				   (T (FERROR NIL
					      "Unable to default destination array"))))))
		    ((AND (SYMBOLP ARRAY)
			  (FBOUNDP ARRAY)
			  (ARRAYP (FSYMEVAL ARRAY)))
		     (FSYMEVAL ARRAY))
		    (T ARRAY))))
    (CHECK-ARG ARRAY (ARRAYP DEST) "an array or a symbol FBOUND to an array")
    ;; Note, I really mean LISTP here -- Maclisp does not allow NIL, and that is right.
    ;; Well, there is code in the system that depends on the empty list working as a source,
    ;; at least for zero-length arrays.  This code says filling from () means fill
    ;; with the default initial value for the destination array type.
    (CHECK-ARG SOURCE (OR (ARRAYP SOURCE) (LISTP SOURCE) (NULL SOURCE)) "an array or a list")
    (LET ((DEST-NDIMS (ARRAY-RANK DEST))
	  (SOURCE-IS-AN-ARRAY-P (ARRAYP SOURCE)))
      (COND (SOURCE-IS-AN-ARRAY-P
	     (LET ((SOURCE-NDIMS (ARRAY-RANK SOURCE)))
	       (COND ((AND (= DEST-NDIMS 1)
			   (= SOURCE-NDIMS 1))
		      ;; One-D array into a one-D array is in microcode!
		      (LET ((N-ELEMENTS (MIN (ARRAY-LENGTH SOURCE)
					     (ARRAY-LENGTH DEST))))
			(COPY-ARRAY-PORTION SOURCE 0 N-ELEMENTS DEST 0 N-ELEMENTS)))
		     (T
		      ;; Hairy case, some array is multi-dimensional.
		      (USING-RESOURCE (SOURCE-INDEX-ARRAY FILLARRAY-INDEX-ARRAYS)
			(USING-RESOURCE (DEST-INDEX-ARRAY FILLARRAY-INDEX-ARRAYS)
			  (DOTIMES (I 10)
			    (ASET 0 SOURCE-INDEX-ARRAY I)
			    (ASET 0 DEST-INDEX-ARRAY I))
			  (LET ((SOURCE-ELEMENTS (ARRAY-LENGTH SOURCE))
				(DEST-ELEMENTS (ARRAY-LENGTH DEST)))
			    (DOTIMES (I (MIN SOURCE-ELEMENTS DEST-ELEMENTS))
			      (FILLARRAY-PUT (FILLARRAY-GET SOURCE
							    SOURCE-INDEX-ARRAY
							    SOURCE-NDIMS)
					     DEST DEST-INDEX-ARRAY DEST-NDIMS)))))))))
	    ((NULL SOURCE) (COPY-ARRAY-PORTION DEST 0 0 DEST 0 (ARRAY-LENGTH DEST)))
	    (T
	     ;; Source is a list.
	     (COND ((= DEST-NDIMS 1)
		    (DOTIMES (X (ARRAY-DIMENSION DEST 0))
		      (ASET (CAR SOURCE) DEST X)
		      (IF (NOT (NULL (CDR SOURCE))) (SETQ SOURCE (CDR SOURCE)))))
		   ((= DEST-NDIMS 2)
		    (DOTIMES (X (ARRAY-DIMENSION DEST 0))
		      (DOTIMES (Y (ARRAY-DIMENSION DEST 1))
			(ASET (CAR SOURCE) DEST X Y)
			(IF (NOT (NULL (CDR SOURCE))) (SETQ SOURCE (CDR SOURCE))))))
		   ((= DEST-NDIMS 3)
		    (DOTIMES (X (ARRAY-DIMENSION DEST 0))
		      (DOTIMES (Y (ARRAY-DIMENSION DEST 1))
			(DOTIMES (Z (ARRAY-DIMENSION DEST 2))
			  (ASET (CAR SOURCE) DEST X Y Z)
			  (IF (NOT (NULL (CDR SOURCE))) (SETQ SOURCE (CDR SOURCE)))))))
		   (T
		    (USING-RESOURCE (DEST-INDEX-ARRAY FILLARRAY-INDEX-ARRAYS)
		      (DOTIMES (I 10)
			(ASET 0 DEST-INDEX-ARRAY I))
		      (DOTIMES (I (ARRAY-LENGTH DEST))
			(FILLARRAY-PUT (CAR SOURCE) DEST DEST-INDEX-ARRAY DEST-NDIMS)
			(IF (NOT (NULL (CDR SOURCE))) (SETQ SOURCE (CDR SOURCE)))))))))))
  ARRAY)

(DEFUN FILLARRAY-GET (ARRAY INDEX-ARRAY NDIMS)
  (%OPEN-CALL-BLOCK ARRAY 0 1)			;d-stack
  (%ASSURE-PDL-ROOM NDIMS)
  (DOTIMES (I NDIMS)
    (%PUSH (AREF INDEX-ARRAY I)))
  (%ACTIVATE-OPEN-CALL-BLOCK)
  (FILLARRAY-INCREMENT-INDEX ARRAY INDEX-ARRAY NDIMS)
  (%POP))

(DEFUN FILLARRAY-PUT (VALUE ARRAY INDEX-ARRAY NDIMS)
  (%OPEN-CALL-BLOCK #'ASET 0 0)			;d-ignore
  (%ASSURE-PDL-ROOM (+ 2 NDIMS))
  (%PUSH VALUE)
  (%PUSH ARRAY)
  (DOTIMES (I NDIMS)
    (%PUSH (AREF INDEX-ARRAY I)))
  (%ACTIVATE-OPEN-CALL-BLOCK)
  (FILLARRAY-INCREMENT-INDEX ARRAY INDEX-ARRAY NDIMS))

(DEFUN FILLARRAY-INCREMENT-INDEX (ARRAY INDEX-ARRAY NDIMS)
  (DO ((DIM (1- NDIMS) (1- DIM)))
      ((< DIM 0))
    (LET ((VAL (1+ (AREF INDEX-ARRAY DIM))))
      (COND ((< VAL (ARRAY-DIMENSION ARRAY DIM))
	     (ASET VAL INDEX-ARRAY DIM)
	     (RETURN))
	    (T
	     (ASET 0 INDEX-ARRAY DIM))))))

;;; LISTARRAY of a one-dimensional array respects the fill pointer, but
;;; for multi-dimensional arrays it ignores the fill pointer.
(DEFUN LISTARRAY (ARRAY &OPTIONAL LIMIT)
  "Return a list of the elements of ARRAY, up to index LIMIT.
If LIMIT is NIL, the array size is used; for one-dimensional arrays,
the fill pointer is used if there is one."
  (IF (AND (SYMBOLP ARRAY)
	   (FBOUNDP ARRAY)
	   (ARRAYP (FSYMEVAL ARRAY)))
      (SETQ ARRAY (FSYMEVAL ARRAY)))
  (CHECK-ARG ARRAY ARRAYP "an array or a symbol FBOUND to an array")
  (CHECK-ARG LIMIT (OR (NULL LIMIT) (FIXP LIMIT)) "NIL or a fixnum")
  (LET* ((NDIMS (ARRAY-RANK ARRAY))
	 (ELEMENTS (IF (= NDIMS 1)
		       (ARRAY-ACTIVE-LENGTH ARRAY)
		       (ARRAY-LENGTH ARRAY)))
	 (TIMES (IF (NULL LIMIT)
		    ELEMENTS
		    (MIN LIMIT ELEMENTS)))
	 (LIST (MAKE-LIST TIMES))
	 (L LIST)
	 (COUNT 0))
    (COND ((= NDIMS 1)
	   (DOTIMES (X (ARRAY-ACTIVE-LENGTH ARRAY))
	     (SETQ COUNT (1+ COUNT))
	     (IF (> COUNT TIMES)
		 (RETURN))
	     (RPLACA L (AREF ARRAY X))
	     (SETQ L (CDR L))))
	  ((= NDIMS 2)
	   (DOTIMES (X (ARRAY-DIMENSION ARRAY 0))
	     (DOTIMES (Y (ARRAY-DIMENSION ARRAY 1))
	       (SETQ COUNT (1+ COUNT))
	       (IF (> COUNT TIMES)
		   (RETURN))
	       (RPLACA L (AREF ARRAY X Y))
	       (SETQ L (CDR L)))))
	  ((= NDIMS 3)
	   (DOTIMES (X (ARRAY-DIMENSION ARRAY 0))
	     (DOTIMES (Y (ARRAY-DIMENSION ARRAY 1))
	       (DOTIMES (Z (ARRAY-DIMENSION ARRAY 2))
		 (SETQ COUNT (1+ COUNT))
		 (IF (> COUNT TIMES)
		     (RETURN))
		 (RPLACA L (AREF ARRAY X Y Z))
		 (SETQ L (CDR L))))))
	  (T
	   (USING-RESOURCE (INDEX-ARRAY FILLARRAY-INDEX-ARRAYS)
	     (DOTIMES (I 10) (ASET 0 INDEX-ARRAY I))
	     (DOTIMES (I TIMES)
	       (RPLACA L (FILLARRAY-GET ARRAY INDEX-ARRAY NDIMS))
	       (SETQ L (CDR L))))))
    LIST))

(DEFUN LIST-ARRAY-LEADER (ARRAY &OPTIONAL LIMIT)
  "Return a list of the contents of ARRAY's leader, up to LIMIT."
  (IF (AND (SYMBOLP ARRAY)
	   (FBOUNDP ARRAY)
	   (ARRAYP (FSYMEVAL ARRAY)))
      (SETQ ARRAY (FSYMEVAL ARRAY)))
  (IF (NULL LIMIT)
      (SETQ LIMIT (OR (ARRAY-LEADER-LENGTH ARRAY) 0)))
  (LET ((LIST (MAKE-LIST DEFAULT-CONS-AREA LIMIT)))
    (DO ((I 0 (1+ I))
	 (L LIST (CDR L)))
	((>= I LIMIT)
	 LIST)
      (RPLACA L (ARRAY-LEADER ARRAY I)))))

(DEFUN *RSET (&OPTIONAL (NEW-MODE T))
    (SETQ *RSET NEW-MODE))

(COMPILER:MAKE-OBSOLETE ARRAY-/#-DIMS "use ARRAY-RANK")
(DEFF ARRAY-/#-DIMS 'ARRAY-RANK)

(COMPILER:MAKE-OBSOLETE ARRAY-DIMENSION-N
			"use ARRAY-DIMENSION (with a different calling sequence)")
(DEFUN ARRAY-DIMENSION-N (N ARRAY)
  "Return the length of dimension N of ARRAY.  The first dimension is N=1.
If N is 0, the leader length is returned.  Use ARRAY-LEADER-LENGTH instead."
  (CHECK-ARG ARRAY ARRAYP "an array")
  (COND ((> N (ARRAY-RANK ARRAY))
	 NIL)
	((NOT (PLUSP N))
	 (ARRAY-LEADER-LENGTH ARRAY))
	(T
	 (ARRAY-DIMENSION ARRAY (1- N)))))

(comment ;microcoded now.
(DEFUN ARRAY-RANK (ARRAY)
  "Return the number of dimensions ARRAY has."
  (CHECK-ARG ARRAY ARRAYP "an array")
  (%P-LDB-OFFSET %%ARRAY-NUMBER-DIMENSIONS ARRAY 0)))

(DEFUN DATA-TYPE (X)
  "Return the name for the data type of X."
  (AR-1 (FSYMEVAL 'Q-DATA-TYPES) (%DATA-TYPE X)))

;;; Facilities for looking through all functions in the world
;;; and finding out what they do.

(DEFUN WHO-CALLS (SYMBOL &OPTIONAL PKG (INHERITORS T) (INHERITED T) &AUX RETURN-LIST)
  "Find all symbols in package PKG whose values, definitions or properties use SYMBOL.
PKG defaults to NIL, which means search all packages.
The packages which inherit from PKG are processed also, unless INHERITORS is NIL.
The packages PKG inherits from are processed also, unless INHERITED is NIL.
/(Other packages which merely inherit from the same ones are NOT processed.)
The symbols are printed and a list of them is returned."
  (DECLARE (SPECIAL RETURN-LIST))
  (FIND-CALLERS-OF-SYMBOLS SYMBOL PKG
	#'(LAMBDA (CALLER CALLEE HOW)
	    (FORMAT T "~&~S" CALLER)
	    (FORMAT T (SELECTQ HOW
			(:VARIABLE " uses ~S as a variable.")
			(:FUNCTION " calls ~S as a function.")
			(:MISC-FUNCTION " calls ~S via a 'misc' instruction.")
			(:CONSTANT " uses ~S as a constant.")
			(:FLAVOR " uses ~S's flavor definition.")
			(:UNBOUND-FUNCTION " calls ~S, an undefined function.")
			(NIL ", an interpreted function, uses ~S somehow."))
		    CALLEE)
	    (PUSH CALLER RETURN-LIST))
	INHERITORS INHERITED)
  RETURN-LIST)

(DEFF WHO-USES 'WHO-CALLS)

(DEFUN WHAT-FILES-CALL (SYMBOL-OR-SYMBOLS &OPTIONAL PKG (INHERITORS T) (INHERITED T))
  "Find all files in package PKG which use SYMBOL.
PKG defaults to NIL, which means search all packages.
The packages which inherit from PKG are processed also, unless INHERITORS is NIL.
The packages PKG inherits from are processed also, unless INHERITED is NIL.
/(Other packages which merely inherit from the same ones are NOT processed.)
The files are printed and a list of them is returned."
  (LOCAL-DECLARE ((SPECIAL L))
    (LET ((L NIL))
      (FIND-CALLERS-OF-SYMBOLS SYMBOL-OR-SYMBOLS PKG
	#'(LAMBDA (CALLER IGNORE IGNORE)
	    (AND (SETQ CALLER (GET-SOURCE-FILE-NAME CALLER 'DEFUN))
		 (NOT (MEMQ CALLER L))
		 (PUSH CALLER L)))
	INHERITORS INHERITED)
      L)))

(DEFUN FIND-CALLERS-OF-SYMBOLS (SYMBOL PKG FUNCTION
				&OPTIONAL (INHERITORS T) (INHERITED T))
  "This is the main driving function for WHO-CALLS and friends.
Looks at all symbols in PKG and USErs (if INHERITORS is T)
and the ones it USEs (if INHERITED is T).
If PKG is NIL, looks at all packages.
Looks at each symbol's function definition and if it
refers to SYMBOL calls FUNCTION with the function name, the symbol used,
and the type of use (:VARIABLE, :FUNCTION, :MISC-FUNCTION,
 :CONSTANT, :UNBOUND-FUNCTION, :FLAVOR,
 or NIL if used in an unknown way in an interpreted function.)
SYMBOL can be a single symbol or a list of symbols.
The symbol :UNBOUND-FUNCTION is treated specially."
  (DECLARE (SPECIAL SYMBOL FUNCTION))
  ;; Sorting first, in order of function definitions, didn't help much when
  ;; tried in the previous generation of this function.
  (WHEN PKG (SETQ PKG (PKG-FIND-PACKAGE PKG)))
  (CHECK-ARG SYMBOL
	     (OR (SYMBOLP SYMBOL)
		 (LOOP FOR SYM IN SYMBOL ALWAYS (SYMBOLP SYM)))
	     "a symbol or a list of symbols")
  (IF (SYMBOLP SYMBOL)
      (SETQ SYMBOL (ADD-SYMBOLS-OPTIMIZED-INTO SYMBOL (LIST SYMBOL)))
    (DOLIST (SYM SYMBOL)
      (SETQ SYMBOL (ADD-SYMBOLS-OPTIMIZED-INTO SYM SYMBOL))))
  ;; If one of the symbols is :PUTPROP, say, make sure we look for GLOBAL:PUTPROP too.
  (LET (TEM)
    (DOLIST (SYM SYMBOL)
      (AND (EQ (SYMBOL-PACKAGE SYM) PKG-KEYWORD-PACKAGE)
	   (SETQ TEM (INTERN-SOFT SYM PKG-GLOBAL-PACKAGE))
	   (PUSH TEM SYMBOL))))
  (COND (PKG
	 (MAPATOMS #'FIND-CALLERS-OF-SYMBOLS-AUX PKG INHERITED)
	 (AND INHERITORS
	      (DOLIST (P (PACKAGE-USED-BY-LIST PKG))
		(MAPATOMS #'FIND-CALLERS-OF-SYMBOLS-AUX P NIL))))
	(T (DOLIST (P *ALL-PACKAGES*)
	     (MAPATOMS #'FIND-CALLERS-OF-SYMBOLS-AUX P NIL))))
  NIL)

(DEFUN ADD-SYMBOLS-OPTIMIZED-INTO (SYM LIST)
  (IF (SYMBOLP LIST) (SETQ LIST (LIST LIST)))
  (DOLIST (SYM1 (GET SYM 'COMPILER:OPTIMIZED-INTO))
    (UNLESS (MEMQ SYM1 LIST)
      (SETQ LIST (ADD-SYMBOLS-OPTIMIZED-INTO SYM1 (CONS SYM1 LIST)))))
  LIST)

(DEFUN FIND-CALLERS-OF-SYMBOLS-AUX (CALLER &AUX FL)
  (DECLARE (SPECIAL SYMBOL FUNCTION))
  ;; Ignore all symbols which are forwarded to others, to avoid duplication.
  (AND ( (%P-LDB-OFFSET %%Q-DATA-TYPE CALLER 2) DTP-ONE-Q-FORWARD)
       (FBOUNDP CALLER)
       (FIND-CALLERS-OF-SYMBOLS-AUX1 CALLER (FSYMEVAL CALLER)))
  (COND (( (%P-LDB-OFFSET %%Q-DATA-TYPE CALLER 3) DTP-ONE-Q-FORWARD)
	 ;; Also look for properties
	 (DO ((L (PLIST CALLER) (CDDR L)))
	     ((NULL L))
	   (COND ((= (%DATA-TYPE (CADR L)) DTP-FEF-POINTER)
		  (FIND-CALLERS-OF-SYMBOLS-AUX-FEF
		    (LIST ':PROPERTY CALLER (CAR L)) (CADR L)))))
	 ;; Also look for flavor methods
	 (AND (SETQ FL (GET CALLER 'FLAVOR))
	      (ARRAYP FL)		;Could be T
	      (DOLIST (MTE (FLAVOR-METHOD-TABLE FL))
		(DOLIST (METH (CDDDR MTE))
		  (IF (METH-DEFINEDP METH)
		      (FIND-CALLERS-OF-SYMBOLS-AUX1 (METH-FUNCTION-SPEC METH)
						    (METH-DEFINITION METH))))))
	 ;; Also look for initializations
	 (IF (GET CALLER 'INITIALIZATION-LIST)
	     ;; It is an initialization list.
	     (DOLIST (INIT-LIST-ENTRY (SYMEVAL CALLER))
	       (FIND-CALLERS-OF-SYMBOLS-AUX-LIST CALLER (INIT-FORM INIT-LIST-ENTRY)))))))

(DEFUN FIND-CALLERS-OF-SYMBOLS-AUX1 (CALLER DEFN)
  (DECLARE (SPECIAL SYMBOL FUNCTION))
  ;; Don't be fooled by macros, interpreted or compiled.
  (AND (CONSP DEFN) (EQ (CAR DEFN) 'MACRO) (SETQ DEFN (CDR DEFN)))
  (TYPECASE DEFN
    (:COMPILED-FUNCTION (FIND-CALLERS-OF-SYMBOLS-AUX-FEF CALLER DEFN))
    (:LIST (FIND-CALLERS-OF-SYMBOLS-AUX-LAMBDA CALLER DEFN))
    (:SELECT-METHOD (FIND-CALLERS-OF-SYMBOLS-AUX-LIST CALLER (%MAKE-POINTER DTP-LIST DEFN))))
  ;; this function is traced, advised, etc.
  ;; then look through the actual definition.
  (IF (OR (LISTP DEFN) (TYPEP DEFN ':COMPILED-FUNCTION))
      (LET* ((DEBUG-INFO (FUNCTION-DEBUGGING-INFO DEFN))
	     (INNER (ASSQ 'SI:ENCAPSULATED-DEFINITION DEBUG-INFO)))
	(AND INNER (FIND-CALLERS-OF-SYMBOLS-AUX (CADR INNER))))))
		 
(DEFUN FIND-CALLERS-OF-SYMBOLS-AUX-FEF (CALLER DEFN &AUX TEM OFFSET SYM)
  (DECLARE (SPECIAL SYMBOL FUNCTION))
  (DO ((I %FEF-HEADER-LENGTH (1+ I))
       (LIM (TRUNCATE (FEF-INITIAL-PC DEFN) 2)))
      ((>= I LIM) NIL)
    (COND ((= (%P-LDB-OFFSET %%Q-DATA-TYPE DEFN I) DTP-EXTERNAL-VALUE-CELL-POINTER)
	   (SETQ TEM (%P-CONTENTS-AS-LOCATIVE-OFFSET DEFN I)
		 SYM (%FIND-STRUCTURE-HEADER TEM)
		 OFFSET (%POINTER-DIFFERENCE TEM SYM))
	   (COND ((NOT (SYMBOLP SYM)))
		 ((= OFFSET 2)			;Function cell reference
		  (IF (IF (ATOM SYMBOL) (EQ SYM SYMBOL) (MEMQ SYM SYMBOL))
		      (FUNCALL FUNCTION CALLER SYM ':FUNCTION)
		      (AND (IF (ATOM SYMBOL) (EQ ':UNBOUND-FUNCTION SYMBOL)
			       (MEMQ ':UNBOUND-FUNCTION SYMBOL))
			   (NOT (FBOUNDP SYM))
			   (FUNCALL FUNCTION CALLER SYM ':UNBOUND-FUNCTION))))
		 (T				;Value reference presumably
		  (IF (IF (ATOM SYMBOL) (EQ SYM SYMBOL) (MEMQ SYM SYMBOL))
		      (FUNCALL FUNCTION CALLER SYM ':VARIABLE)))))
	  ((= (%P-LDB-OFFSET %%Q-DATA-TYPE DEFN I) DTP-SELF-REF-POINTER)
	   (LET* ((FN (FEF-FLAVOR-NAME DEFN)))
	     (IF FN
		 (MULTIPLE-VALUE-BIND (SYM USE)
		     (FLAVOR-DECODE-SELF-REF-POINTER FN (%P-LDB-OFFSET %%Q-POINTER DEFN I))
		   (IF (OR (EQ SYM SYMBOL)
			   (AND (CONSP SYMBOL) (MEMQ SYM SYMBOL)))
		       (FUNCALL FUNCTION CALLER SYM
				(IF USE ':FLAVOR ':VARIABLE)))))))
	  ((SYMBOLP (SETQ SYM (%P-CONTENTS-OFFSET DEFN I)))
	   (IF (IF (ATOM SYMBOL) (EQ SYM SYMBOL) (MEMQ SYM SYMBOL))
	       (FUNCALL FUNCTION CALLER SYM ':CONSTANT)))))
  ;; See if the fef uses the symbol as a macro.
  (LET ((DI (DEBUGGING-INFO DEFN)))
    (DOLIST (M (CADR (ASSQ ':MACROS-EXPANDED DI)))
      (IF (IF (ATOM SYMBOL)
	      (EQ SYMBOL (IF (CONSP M) (CAR M) M))
	    (MEMQ (IF (CONSP M) (CAR M) M) SYMBOL))
	  (FUNCALL FUNCTION CALLER SYMBOL ':MACRO))))
  ;; See if we have a function reference compiled into a misc instruction
  (IF (SYMBOLP SYMBOL)
      (IF (FEF-CALLS-MISC-FUNCTION DEFN SYMBOL)
	  (FUNCALL FUNCTION CALLER SYMBOL ':MISC-FUNCTION))
      (DOLIST (SYM SYMBOL)
	(IF (FEF-CALLS-MISC-FUNCTION DEFN SYM)
	    (FUNCALL FUNCTION CALLER SYM ':MISC-FUNCTION))))
  (AND (LDB-TEST %%FEFHI-MS-DEBUG-INFO-PRESENT
		 (%P-CONTENTS-OFFSET DEFN %FEFHI-MISC))
       (SETQ TEM (CDR (ASSQ ':INTERNAL-FEF-OFFSETS
			    (%P-CONTENTS-OFFSET DEFN (1- (%P-LDB %%FEFH-PC-IN-WORDS DEFN))))))
       (LOOP FOR OFFSET IN TEM
	     FOR I FROM 0
	     DO (FIND-CALLERS-OF-SYMBOLS-AUX-FEF `(:INTERNAL ,CALLER ,I)
						 (%P-CONTENTS-OFFSET DEFN OFFSET)))))

;;; See if this FEF uses a certain MISC instruction
(DEFUN FEF-CALLS-MISC-FUNCTION (FEF SYM &AUX TEM INST)
  (AND (GET SYM 'COMPILER:QINTCMP)
       (SETQ TEM (GET SYM 'COMPILER:QLVAL))
       (DO ((MISCINST	;Misc instruction sought
	      (IF (>= TEM 1000)
		  (+ 35_11 (LOGAND 777 TEM))
		(+ 15_11 TEM)))
	    (MISCMASK 37777)		;Masks out destination
	    (LONGJUMP 14777)		;First word of 2-word jump instruction
	    (LONGJUMP1 34777)		;First word of 2-word jump instruction
	    (PC (FEF-INITIAL-PC FEF) (1+ PC))
	    (MAXPC (* (FEF-LENGTH FEF) 2)))
	   ((>= PC MAXPC) NIL)
	 (SETQ INST (LOGAND (%P-LDB-OFFSET (IF (ODDP PC) %%Q-HIGH-HALF %%Q-LOW-HALF)
					   FEF (TRUNCATE PC 2))
			    MISCMASK))
	 (COND ((= INST MISCINST) (RETURN T))
	       ((= INST LONGJUMP) (SETQ PC (1+ PC)))
	       ((= INST LONGJUMP1) (SETQ PC (1+ PC)))))))

;;; Tree-walk CALLER looking for FUNCTION.  CALLER should be the function name,
;;; and DEFN should be its definition.  Avoids listing symbols twice.
(DEFUN FIND-CALLERS-OF-SYMBOLS-AUX-LIST (CALLER DEFN)
  (DECLARE (SPECIAL SUPPRESS))
  (LET ((SUPPRESS NIL))
    (FIND-CALLERS-OF-SYMBOLS-AUX-LIST1 CALLER DEFN)))

(DEFUN FIND-CALLERS-OF-SYMBOLS-AUX-LAMBDA (CALLER DEFN)
  (DECLARE (SPECIAL SUPPRESS))
  (DECLARE (SPECIAL SYMBOL FUNCTION))
  (LET ((SUPPRESS NIL))
    (FIND-CALLERS-OF-SYMBOLS-AUX-LIST1 CALLER (LAMBDA-EXP-ARGS-AND-BODY DEFN))))

(DEFUN FIND-CALLERS-OF-SYMBOLS-AUX-LIST1 (CALLER DEFN)
  (DECLARE (SPECIAL SUPPRESS))
  (DECLARE (SPECIAL SYMBOL FUNCTION))
  (DO ((L DEFN (CDR L)))
      ((ATOM L))
    (COND ((AND (SYMBOLP (CAR L))
		(NOT (MEMQ (CAR L) SUPPRESS))
		(IF (ATOM SYMBOL) (EQ (CAR L) SYMBOL) (MEMQ (CAR L) SYMBOL)))
	   (PUSH (CAR L) SUPPRESS)
	   (FUNCALL FUNCTION CALLER (CAR L) NIL))
	  ((CONSP (CAR L))
	   (FIND-CALLERS-OF-SYMBOLS-AUX-LIST1 CALLER (CAR L))))))

(DEFUN %MAKE-PAGE-READ-ONLY (P)
  "Make virtual page at address P read only.  Lasts only until it is swapped out!"
  (%CHANGE-PAGE-STATUS P NIL (DPB 2 0603 (LDB %%REGION-MAP-BITS  ;CHANGE MAP-STATUS
                                              (REGION-BITS (%REGION-NUMBER P))))))
;MAR-HACKING FUNCTIONS

(DEFUN CLEAR-MAR ()
  "Clear out the mar setting."
  (DO ((P %MAR-LOW (+ P 200)))
      ((> P %MAR-HIGH)) ;TROUBLE WITH NEGATIVE NUMBERS HERE!
    (%CHANGE-PAGE-STATUS P NIL (LDB %%REGION-MAP-BITS
				    (REGION-BITS (%REGION-NUMBER P)))))
  (SETQ %MAR-LOW -1
	%MAR-HIGH -2
	%MODE-FLAGS (%LOGDPB 0 %%M-FLAGS-MAR-MODE %MODE-FLAGS))
  NIL)

;NOT GC-SAFE, ADDITIONAL HAIR REQUIRED, ALSO NEGATIVE NUMBER TROUBLE
(DEFUN SET-MAR (LOCATION CYCLE-TYPE &OPTIONAL (N-WORDS 1))
					;N-WORDS SHOULD DEFAULT TO (SIZE LOCATION)
  "Set trap on reference to N-WORDS words starting at LOCATION.
N-WORDS defaults to 1.  CYCLE-TYPE is T, :READ or :WRITE."
  (SETQ CYCLE-TYPE
	(SELECTQ CYCLE-TYPE
	   (:READ 1)
	   (:WRITE 2)
	   ((T) 3)  ;Parens around the T so it doesn't look like an otherwise
	   (OTHERWISE (FERROR NIL "~S is not a valid CYCLE-TYPE" CYCLE-TYPE))))
  (CLEAR-MAR) ;CLEAR OLD MAR
  (SETQ %MAR-HIGH (+ (1- N-WORDS) (SETQ %MAR-LOW (%POINTER LOCATION))))
  ;IF MAR'ED PAGES ARE IN CORE, SET UP THEIR TRAPS
  (DO P %MAR-LOW (+ P 200) (> P %MAR-HIGH)
    (%CHANGE-PAGE-STATUS P NIL (DPB 6 0604 (LDB %%REGION-MAP-BITS  ;CHANGE MAP-STATUS
						(REGION-BITS (%REGION-NUMBER P))))))
  (SETQ %MODE-FLAGS (%LOGDPB CYCLE-TYPE %%M-FLAGS-MAR-MODE %MODE-FLAGS))	;ENERGIZE
  T)

(DEFUN MAR-MODE ()
   (LET ((MODE (LDB %%M-FLAGS-MAR-MODE %MODE-FLAGS)))
     (SELECTQ MODE
	(0 'NIL)
	(1 ':READ)
	(2 ':WRITE)
	(3 'T)
	(OTHERWISE (FERROR NIL "The MAR mode, ~O, is invalid." MODE)))))

(DEFUN DEL-IF-NOT (PRED LIST)
  "Destructively remove all elements of LIST that don't satisfy PRED."
       (PROG (LST OLST)
        A    (COND ((ATOM LIST) (RETURN LIST))
                   ((FUNCALL PRED (CAR LIST)))
                   (T
                    (SETQ LIST (CDR LIST))
                    (GO A)))
             (SETQ OLST (SETQ LST LIST))
        B    (SETQ LST (CDR LST))
             (COND ((ATOM LST) (RETURN LIST))
                   ((FUNCALL PRED (CAR LST))
                    (SETQ OLST LST))
                   (T
                    (RPLACD OLST (CDR LST))))
             (GO B)))

(DEFUN DEL-IF (PRED LIST)
  "Destructively remove all elements of LIST that satisfy PRED."
       (PROG (LST OLST)
        A    (COND ((ATOM LIST) (RETURN LIST))
                   ((FUNCALL PRED (CAR LIST))
                    (SETQ LIST (CDR LIST))
                    (GO A)))
             (SETQ OLST (SETQ LST LIST))
        B    (SETQ LST (CDR LST))
             (COND ((ATOM LST) (RETURN LIST))
                   ((FUNCALL PRED (CAR LST))
                    (RPLACD OLST (CDR LST)))
                   (T
                    (SETQ OLST LST)))
             (GO B)))

(DEFUN HAIPART (X N &AUX TEM)
  "Return N significant bits of the absolute value of X.
N > 0 means high N bits; N < 0 means low -N bits.
If X is too small, all of it is returned."
  ;; Get number of significant bits
  (SETQ TEM (HAULONG (SETQ X (ABS X))))
  (COND ;; Positive N means get high N bits, or as many as there are
	((> N 0) (SETQ TEM (- N TEM))	;minus number of low bits to discard
		 (COND ((< TEM 0) (ASH X TEM))
		       (T X)))
	;; Zero N means return no bits
	((= N 0) 0)
	;; Negative N means get low -N bits, or as many as there are
	((< (SETQ N (MINUS N)) TEM)
	 (\ X (ASH 1 N)))
	(T X)))

;;; This should really be fixed to expand more than just top level functions.
(DEFUN MEXP ()
  "Read-macroexpand-print loop, for seeing how macros expand.
MEXP reads s-expressions and macroexpands each one, printing the expansion.
Type NIL to exit (or Abort)."
    (DO ((TEM))
	(())
      (FORMAT T "~2%Macro form ")
      (FUNCALL STANDARD-INPUT ':UNTYI (FUNCALL STANDARD-INPUT ':TYI))	;Allow abort to exit
      (CATCH-ERROR-RESTART ((SYS:ABORT ERROR) "Return to MEXP input loop.")
	(SETQ TEM (READ-FOR-TOP-LEVEL))
	(AND (SYMBOLP TEM) (RETURN NIL))
	(DO EXP (MACROEXPAND-1 TEM) (MACROEXPAND-1 EXP) (EQ EXP TEM)
	  ;(FORMAT T "  ~S" (SETQ TEM EXP))
	  (PRINC "  ")
	  (GRIND-TOP-LEVEL (SETQ TEM EXP))
	  ))))


;; STATUS and SSTATUS 
;; Note that these have to be Maclisp compatible and therefore have to work
;; independent of packages.  All symbols on feature lists are in the keyword package.

(DEFVAR *FEATURES*
	'(:LISPM :CADR :MIT :LMI
	  :CHAOS :SORT :FASLOAD :STRING :NEWIO :ROMAN :TRACE :GRINDEF :GRIND))

(DEFVAR STATUS-STATUS-LIST '(:FEATURE :FEATURES :NOFEATURE :STATUS :SSTATUS :TABSIZE
			     :USERID :SITE :OPSYS))

(DEFVAR STATUS-SSTATUS-LIST '(:FEATURE :NOFEATURE))

(DEFUN RETURN-STATUS (STATUS-LIST ITEM ITEM-P)
       (COND ((NOT ITEM-P) STATUS-LIST)
	     ((NUMBERP ITEM) (MEMBER ITEM STATUS-LIST))
	     (T (NOT (NULL (MEM #'STRING-EQUAL ITEM STATUS-LIST))))))

(DEFUN STATUS (&QUOTE STATUS-FUNCTION &OPTIONAL (ITEM NIL ITEM-P))
  (SELECTOR STATUS-FUNCTION STRING-EQUAL
    (('FEATURE 'FEATURES) (RETURN-STATUS *FEATURES* ITEM ITEM-P))
    (('NOFEATURE) (COND ((NOT ITEM-P)
			 (FERROR NIL "Too few args to STATUS NOFEATURE."))
			(T (NOT (RETURN-STATUS *FEATURES* ITEM ITEM-P)))))
    (('STATUS) (RETURN-STATUS STATUS-STATUS-LIST ITEM ITEM-P))
    (('SSTATUS) (RETURN-STATUS STATUS-SSTATUS-LIST ITEM ITEM-P))
    (('TABSIZE) 8)
    (('USERID) USER-ID)
    (('SITE) LOCAL-HOST-NAME)
    (('OPSYS) ':LISPM)
    (OTHERWISE (FERROR NIL "~S is not a legal STATUS request." STATUS-FUNCTION))))

(DEFUN SSTATUS (&QUOTE STATUS-FUNCTION ITEM
		&AUX (DEFAULT-CONS-AREA WORKING-STORAGE-AREA))
  (IF (SYMBOLP ITEM)
      (SETQ ITEM (INTERN (STRING ITEM) PKG-KEYWORD-PACKAGE)))	;These are all keywords
  (SELECTOR STATUS-FUNCTION STRING-EQUAL
    (('FEATURE) (COND ((NOT (MEMBER ITEM *FEATURES*))
		       (SETQ *FEATURES*
			     (CONS ITEM *FEATURES*))))
		ITEM)
    (('NOFEATURE) (COND ((MEMBER ITEM *FEATURES*)
			 (SETQ *FEATURES*
			       (DELQ ITEM *FEATURES*))))
		  ITEM)
    (OTHERWISE (FERROR NIL "~S is not a legal SSTATUS request." STATUS-FUNCTION))))

;;; Site stuff
(DEFUN UPDATE-SITE-CONFIGURATION-INFO ()
  "Read the latest site configuration files, including the host table."
  (MAYBE-MINI-LOAD-FILE-ALIST SITE-FILE-ALIST)
  (INITIALIZATIONS 'SITE-INITIALIZATION-LIST T)
  (SET-LOCAL-HOST-VARIABLES))  ;Runs SITE-OPTION-INITIALIZATION-LIST

(DEFVAR SITE-NAME NIL)
(DEFVAR SITE-OPTION-ALIST NIL
  "Alist of site option keywords as specified in SYS:SITE;SITE LISP")

(DEFVAR HOST-OVERRIDDEN-SITE-OPTION-ALIST NIL
  "Alist of site-keywords overridden on a per-machine basis, specified in SYS:SITE;LMLOCS LISP")

(DEFVAR SITE-INITIALIZATION-LIST NIL
  "Initializations run after new site tables are loaded.")

(DEFVAR SITE-OPTION-INITIALIZATION-LIST NIL
  "Initializations run when site options change
/(after loading new site tables and after warm boot).")

(DEFMACRO DEFSITE (SITE &BODY OPTIONS)
  "DEFSITE is used only in the file SYS:SITE;SITE LISP."
  `(DEFSITE-1 ',SITE ',OPTIONS))

(DEFUN DEFSITE-1 (NEW-SITE OPTIONS)
  (SETQ SITE-NAME NEW-SITE)
  (SETQ SITE-OPTION-ALIST (LOOP FOR (KEY EXP) IN OPTIONS
				COLLECT `(,KEY . ,(EVAL EXP)))))

(DEFUN GET-SITE-OPTION (KEY)
  "Return the value at this site for site option KEY (a symbol in the keyword package).
The values of site options are specified in the file SYS: SITE; SITE LISP."
  (CDR (OR (ASSQ KEY HOST-OVERRIDDEN-SITE-OPTION-ALIST)
	   (ASSQ KEY SITE-OPTION-ALIST))))

(DEFMACRO DEFINE-SITE-VARIABLE (VAR KEY &OPTIONAL DOCUMENTATION)
  "Define a variable whose value is automatically updated from the site option KEY's value."
  `(PROGN 'COMPILE
     ,(IF DOCUMENTATION
	  `(DEFVAR ,VAR :UNBOUND ,DOCUMENTATION)
	`(DEFVAR ,VAR))
     (ADD-INITIALIZATION ,(FORMAT NIL "SITE:~A" VAR)
			 `(SETQ ,',VAR (GET-SITE-OPTION ',',KEY))
			 '(SITE-OPTION))))

(DEFMACRO DEFINE-SITE-HOST-LIST (VAR KEY &OPTIONAL DOCUMENTATION)
  "Define a variable whose value is a list of hosts, specified by the site option KEY.
The option's value itself will be a list of strings,
but the variable's value is a list of hosts with those names."
  `(PROGN 'COMPILE
     ,(IF DOCUMENTATION
	  `(DEFVAR ,VAR NIL ,DOCUMENTATION)
	`(DEFVAR ,VAR))
     (ADD-INITIALIZATION ,(FORMAT NIL "SITE:~A" VAR)
			 `(SETQ ,',VAR (MAPCAR 'PARSE-HOST (GET-SITE-OPTION ',',KEY)))
			 '(SITE-OPTION))))

;;; Set by major local network
;;; A function called with a host (string or host-object), a system-type and a local net
;;; address.
(DEFVAR NEW-HOST-VALIDATION-FUNCTION)

(DEFUN SET-SYS-HOST (HOST-NAME &OPTIONAL OPERATING-SYSTEM-TYPE HOST-ADDRESS
					 SITE-FILE-DIRECTORY DEFAULT-DEVICE
			       &AUX HOST-OBJECT)
  "Specify the host to read system files from.
You can specify the operating system type, host address, and the directory
for finding the site files, in case the system does not know that host yet."
  (CHECK-ARG HOST-NAME (OR (STRINGP HOST-NAME) (TYPEP HOST-NAME 'HOST)) "a host name")
  (CHECK-ARG OPERATING-SYSTEM-TYPE (OR (NULL OPERATING-SYSTEM-TYPE)
				       (GET OPERATING-SYSTEM-TYPE 'SYSTEM-TYPE-FLAVOR))
	     "an operating system type")
  (AND (SETQ HOST-OBJECT (OR (FS:GET-PATHNAME-HOST HOST-NAME T)
			     (SI:PARSE-HOST HOST-NAME T T)))
       OPERATING-SYSTEM-TYPE
       (NEQ OPERATING-SYSTEM-TYPE (FUNCALL HOST-OBJECT ':SYSTEM-TYPE))
       (FERROR NIL "~A is ~A, not ~A." HOST-OBJECT
	       (FUNCALL HOST-OBJECT ':SYSTEM-TYPE) OPERATING-SYSTEM-TYPE))
  (SETQ HOST-OBJECT (FUNCALL NEW-HOST-VALIDATION-FUNCTION (OR HOST-OBJECT HOST-NAME)
			     OPERATING-SYSTEM-TYPE HOST-ADDRESS))
  (FS:DEFINE-SYS-LOGICAL-DEVICE HOST-OBJECT DEFAULT-DEVICE)
  (AND SITE-FILE-DIRECTORY
       (FS:CHANGE-LOGICAL-PATHNAME-DIRECTORY "SYS" "SITE" SITE-FILE-DIRECTORY))
  T)


(comment
;;; Interfaces to chaosnet physical support facilities
(DEFUN CALL-ELEVATOR ()
  (COND ((TECH-SQUARE-FLOOR-P 8)
	 (CHAOS:HACK-DOOR "8"))
	((TECH-SQUARE-FLOOR-P 9)
	 (CHAOS:HACK-DOOR "9"))
	(T (TV:NOTIFY NIL "I don't know how to get an elevator to your location."))))

(DEFUN BUZZ-DOOR ()
  (COND ((TECH-SQUARE-FLOOR-P 9) (CHAOS:HACK-DOOR "D"))
	(T (TV:NOTIFY NIL "I can only open the 9th floor door at Tech square"))))

(DEFUN TECH-SQUARE-FLOOR-P (FLOOR)
  (AND LOCAL-FLOOR-LOCATION
       (EQ (FIRST LOCAL-FLOOR-LOCATION) 'MIT-NE43)
       (= (SECOND LOCAL-FLOOR-LOCATION) FLOOR)))
);end comment

;; Special floating arithmetic functions.

;; Not patched in 94.
(DEFUN FLOAT (NUMBER &OPTIONAL OTHER)
  "Convert NUMBER to floating point, of same precision as OTHER.
If OTHER is omitted, a full size flonum is returned."
  (IF (SMALL-FLOATP OTHER)
      (SMALL-FLOAT NUMBER)
    (FLOAT NUMBER)))

(DEFUN FFLOOR (DIVIDEND &OPTIONAL DIVISOR)
  "Like FLOOR but converts first value to a flonum."
  (DECLARE (VALUES QUOTIENT REMAINDER))
  (MULTIPLE-VALUE-BIND (QUOTIENT REMAINDER)
      (FLOOR DIVIDEND (OR DIVISOR 1))
    (VALUES (FLOAT QUOTIENT) REMAINDER)))

(DEFUN FCEILING (DIVIDEND &OPTIONAL DIVISOR)
  "Like CEILING but converts first value to a flonum."
  (DECLARE (VALUES QUOTIENT REMAINDER))
  (MULTIPLE-VALUE-BIND (QUOTIENT REMAINDER)
      (CEILING DIVIDEND (OR DIVISOR 1))
    (VALUES (FLOAT QUOTIENT) REMAINDER)))

(DEFUN FTRUNCATE (DIVIDEND &OPTIONAL DIVISOR)
  "Like TRUNCATE but converts first value to a flonum."
  (DECLARE (VALUES QUOTIENT REMAINDER))
  (MULTIPLE-VALUE-BIND (QUOTIENT REMAINDER)
      (TRUNCATE DIVIDEND (OR DIVISOR 1))
    (VALUES (FLOAT QUOTIENT) REMAINDER)))

(DEFUN FROUND (DIVIDEND &OPTIONAL DIVISOR)
  "Like ROUND but converts first value to a flonum."
  (DECLARE (VALUES QUOTIENT REMAINDER))
  (MULTIPLE-VALUE-BIND (QUOTIENT REMAINDER)
      (ROUND DIVIDEND (OR DIVISOR 1))
    (VALUES (FLOAT QUOTIENT) REMAINDER)))

(DEFUN FLOAT-RADIX (FLONUM)
  "Returns the radix of the exponent of a flonum.  That is always 2."
  (CHECK-ARG-TYPE FLONUM FLOAT)
  2)

(DEFUN FLOAT-DIGITS (FLONUM)
  "Returns the number of bits of fraction part FLONUM has.
This depends only on the data type of FLONUM (float vs small-float)."
  (IF (SMALL-FLOATP FLONUM) 21 40))

(DEFUN FLOAT-PRECISION (FLONUM)
  "Returns the number of significant bits of fraction part FLONUM has.
For normalized arguments this is defined to be the same as FLOAT-DIGITS,
and all flonums are normalized on the Lisp machine, so they are identical."
  (IF (SMALL-FLOATP FLONUM) 21 40))

(DEFUN DECODE-FLOAT (FLONUM)
  "Returns three values describing the fraction part, exponent, and sign of FLONUM.
The first is a flonum between 1/2 and 1 (but zero if the arg is zero).
This value, times two to a suitable power, equals FLONUM except in sign.
The second value is an integer, the exponent of two needed for that calculation.
The third value is a flonum whose sign and type match FLONUM's
and whose magnitude is 1."
  (DECLARE (VALUES FRACTION-FLONUM EXPONENT SIGN-FLONUM))
  (VALUES (ABS (FLOAT-FRACTION FLONUM))
	  (FLOAT-EXPONENT FLONUM)
	  (IF (MINUSP FLONUM)
	      (IF (SMALL-FLOATP FLONUM) -1.0S0 -1.0)
	    (IF (SMALL-FLOATP FLONUM) 1.0S0 1.0))))

(DEFUN INTEGER-DECODE-FLOAT (FLONUM)
  "Returns three values describing the fraction part, exponent, and sign of FLONUM.
The first is an integer representing the fraction part of FLONUM.
This value floated, times two to a suitable power, equals FLONUM except in sign.
The second value is an integer, the exponent of two needed for that calculation.
The third value is a flonum whose sign and type match FLONUM's
and whose magnitude is 1."
  (DECLARE (VALUES FRACTION-FLONUM EXPONENT SIGN-FLONUM))
  (VALUES (FLONUM-MANTISSA (ABS FLONUM))
	  (FLONUM-EXPONENT (ABS FLONUM))
	  (IF (MINUSP FLONUM)
	      (IF (SMALL-FLOATP FLONUM) -1.0S0 -1.0)
	    (IF (SMALL-FLOATP FLONUM) 1.0S0 1.0))))

(DEFUN FLOAT-SIGN (SIGN-FLONUM &OPTIONAL MAGNITUDE-FLONUM)
  "Returns a flonum whose sign matches SIGN-FLONUM and magnitude matches MAGNITUDE-FLONUM.
If MAGNITUDE-FLONUM is omitted, it defaults to 1.
The type of flonum returned matches MAGNITUDE-FLONUM
if that is specified; else SIGN-FLONUM."
  (IF MAGNITUDE-FLONUM
      (IF (EQ (MINUSP SIGN-FLONUM) (MINUSP MAGNITUDE-FLONUM))
	  MAGNITUDE-FLONUM (- MAGNITUDE-FLONUM))
    (IF (MINUSP SIGN-FLONUM)
	(IF (SMALL-FLOATP SIGN-FLONUM) -1.0S0 -1.0)
      (IF (SMALL-FLOATP SIGN-FLONUM) 1.0S0 1.0))))

;;; Stuff for function specs

;These are here because they must be loaded after the package system is operational
;(or maybe only because they aren't needed in the cold load?)

;This is useful for sorting function specs
(DEFUN FUNCTION-SPEC-LESSP (FS1 FS2)
  "Compare two function specs, approximately alphabetically."
  (STRING-LESSP (IF (SYMBOLP FS1) FS1 (SECOND FS1))
		(IF (SYMBOLP FS2) FS2 (SECOND FS2))))

(DEFUN FUNDEFINE (FUNCTION-SPEC)
  "Makes FUNCTION-SPEC not have a function definition."
  ;; First, validate the function spec and determine its type
  (SETQ FUNCTION-SPEC (DWIMIFY-ARG-PACKAGE FUNCTION-SPEC 'FUNCTION-SPEC))
  (IF (SYMBOLP FUNCTION-SPEC) (FMAKUNBOUND FUNCTION-SPEC)
      (FUNCALL (GET (CAR FUNCTION-SPEC) 'FUNCTION-SPEC-HANDLER) 'FUNDEFINE FUNCTION-SPEC)))

(DEFUN FDEFINITION-LOCATION (FUNCTION-SPEC &AUX HANDLER)
  "Returns a locative pointer to the cell containing FUNCTION-SPEC's definition."
  ;; First, validate the function spec and determine its type
  (COND ((SYMBOLP FUNCTION-SPEC) (LOCF (FSYMEVAL FUNCTION-SPEC)))
	((AND (CONSP FUNCTION-SPEC)
	      (SETQ HANDLER (GET (CAR FUNCTION-SPEC) 'FUNCTION-SPEC-HANDLER)))
	 (FUNCALL HANDLER 'FDEFINITION-LOCATION FUNCTION-SPEC))
	(T (FERROR 'SYS:INVALID-FUNCTION-SPEC
		   "The function spec ~S is invalid." FUNCTION-SPEC))))

(DEFUN FUNCTION-PARENT (FUNCTION-SPEC &AUX DEF TEM)
  (DECLARE (RETURN-LIST NAME TYPE))
  "Returns NIL or the name of another definition which has the same source code.
The second value is the type of that definition (which can be NIL).
This is used for things like internal functions, methods automatically
created by a defflavor, and macros automatically created by a defstruct."
  (COND ((AND (FDEFINEDP FUNCTION-SPEC)
	      (SETQ TEM (CDR (ASSQ 'FUNCTION-PARENT
				   (DEBUGGING-INFO (SETQ DEF (FDEFINITION FUNCTION-SPEC))))))
	      ;; Don't get confused by circular function-parent pointers.
	      (NOT (EQUAL TEM FUNCTION-SPEC)))
	 (VALUES (CAR TEM) (CADR TEM)))
	((AND (CONSP DEF) (EQ (CAR DEF) 'MACRO) (SYMBOLP (CDR DEF))  ;for DEFSTRUCT
	      (SETQ DEF (GET (CDR DEF) 'MACROEXPANDER-FUNCTION-PARENT)))
	 (FUNCALL DEF FUNCTION-SPEC))
	((CONSP FUNCTION-SPEC)
	 (FUNCALL (GET (CAR FUNCTION-SPEC) 'FUNCTION-SPEC-HANDLER)
		  'FUNCTION-PARENT FUNCTION-SPEC))))

;; (:LOCATION locative-or-list-pointer) refers to the CDR of the pointer.
;; This is for pointing at an arbitrary place which there is no special
;; way to describe.
(D                                                                                                                                                                                                                                                                         @ :  x          h       h   4\n6(2Ebp3n' 7QMw)],W 7Zm9KEbp:R`0[O8:-vp0[w0[-V9Hh7YW7M(;@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             'REDEFINITION ':PROBABLE-ERROR NIL
			   (IF NEW-PATHNAME
			       "~A ~S being redefined by file ~A.
 It was previously defined by file ~A."
			     "~A ~S being redefined;~* it was previously defined by file ~A.")
			   (OR (GET TYPE 'DEFINITION-TYPE-NAME) TYPE) FUNCTION-SPEC
			   NEW-PATHNAME OLD-PATHNAME))
	 (LET (CONDITION CHOICE)
	   (SETQ CONDITION
		 (MAKE-CONDITION 'SYS:REDEFINITION
				 (IF NEW-PATHNAME
				     "~A ~S being redefined by file ~A.
It was previously defined by file ~A."
				   "~A ~S being redefined;~* it was previously defined by file ~A.")
				 (OR (GET TYPE 'DEFINITION-TYPE-NAME) TYPE)
				 FUNCTION-SPEC
				 NEW-PATHNAME OLD-PATHNAME))
	   (SETQ CHOICE (SIGNAL CONDITION))
	   (UNLESS CHOICE
	     (UNLESS (AND INHIBIT-FDEFINE-WARNINGS
			  (NEQ INHIBIT-FDEFINE-WARNINGS ':JUST-WARN))
	       (FORMAT QUERY-IO "~&~A" CONDITION))
	     (IF INHIBIT-FDEFINE-WARNINGS
		 (SETQ CHOICE T)
	       (SETQ CHOICE
		     (FQUERY '(:CHOICES (((ERROR "Error.") #/E)
					 ((PROCEED "Proceed.") #/P)
					 . #.FORMAT:Y-OR-N-P-CHOICES)
					:HELP-FUNCTION
					(LAMBDA (STREAM &REST IGNORE)
					  (PRINC "
  Type Y to proceed to redefine the function, N to not redefine it, E to go into the
  error handler, or P to proceed and not ask in the future (for this pair of files): "
						 STREAM))
					:CLEAR-INPUT T
					:FRESH-LINE NIL
					:SELECT T)
			     " OK? "))))
	   (SELECTQ CHOICE
	     ((T :NO-ACTION) T)
	     ((NIL :INHIBIT-DEFINITION) NIL)
	     (ERROR
	      (ERROR CONDITION)
	      T)
	     (PROCEED
	      (IF NEW-PATHNAME
		  (PUSH OLD-PATHNAME (GET NEW-PATHNAME ':REDEFINES-FILES))
		(PUSH OLD-PATHNAME NON-PATHNAME-REDEFINED-FILES))
	      T))))))

(DEFUN UNDEFUN (FUNCTION-SPEC &AUX TEM)
  "Restore the saved previous function definition of a function spec."
  (SETQ FUNCTION-SPEC (DWIMIFY-ARG-PACKAGE FUNCTION-SPEC 'FUNCTION-SPEC))
  (SETQ TEM (FUNCTION-SPEC-GET FUNCTION-SPEC ':PREVIOUS-DEFINITION))
  (COND (TEM
	 (FSET-CAREFULLY FUNCTION-SPEC TEM T))
	((Y-OR-N-P (FORMAT NIL "~S has no previous definition.  Undefine it? "
			   FUNCTION-SPEC))
	 (FUNDEFINE FUNCTION-SPEC))))

;;; Some source file stuff that does not need to be in QRAND
(DEFUN GET-SOURCE-FILE-NAME (FUNCTION-SPEC &OPTIONAL TYPE)
  "Return source file for definition of type TYPE of FUNCTION-SPEC.
If TYPE is NIL, the most recent definition is used, regardless of type.
FUNCTION-SPEC really is a function spec only if TYPE is DEFUN;
for example, if TYPE is DEFVAR, FUNCTION-SPEC is a variable name."
  (DECLARE (RETURN-LIST PATHNAME TYPE))
  (LET ((PROPERTY (FUNCTION-SPEC-GET FUNCTION-SPEC ':SOURCE-FILE-NAME)))
    (COND ((NULL PROPERTY) NIL)
	  ((ATOM PROPERTY)
	   (AND (MEMQ TYPE '(DEFUN NIL))
		(VALUES PROPERTY 'DEFUN)))
	  (T
	   (LET ((LIST (IF TYPE (ASSQ TYPE PROPERTY) (CAR PROPERTY))))
	     (LOOP FOR FILE IN (CDR LIST)
		   WHEN (NOT (FUNCALL FILE ':GET ':PATCH-FILE))
		   RETURN (VALUES FILE (CAR LIST))))))))

(DEFUN GET-ALL-SOURCE-FILE-NAMES (FUNCTION-SPEC)
  "Return list describing source files for all definitions of FUNCTION-SPEC.
Each element of the list has a type of definition as its car,
and its cdr is a list of generic pathnames that made that type of definition."
  (LET ((PROPERTY (FUNCTION-SPEC-GET FUNCTION-SPEC ':SOURCE-FILE-NAME)))
    (COND ((NULL PROPERTY) NIL)
	  ((ATOM PROPERTY)
	   (SETQ PROPERTY `((DEFUN ,PROPERTY)))
	   ;; May as well save this consing.
	   (FUNCTION-SPEC-PUTPROP FUNCTION-SPEC PROPERTY ':SOURCE-FILE-NAME)
	   PROPERTY)
	  (T PROPERTY))))

(DEFUN DOCUMENTATION (SYMBOL &OPTIONAL (DOC-TYPE 'FUNCTION))
  "Try to return the documentation string for SYMBOL, else return NIL.
Standard values of DOC-TYPE are: FUNCTION, VARIABLE, TYPE, STRUCTURE and SETF,
 but you can put on and retrieve documentation for any DOC-TYPE.
Documentation strings are installed by SETFing a call to DOCUMENTATION."
  (COND ((AND (EQ DOC-TYPE 'VALUE)
	      (GET SYMBOL ':DOCUMENTATION)))
	((AND (SYMBOLP SYMBOL)
	      (LET ((DOC-PROP (GET SYMBOL 'DOCUMENTATION-PROPERTY)))
		(GET (LOCF DOC-PROP) DOC-TYPE))))
	((AND (EQ DOC-TYPE 'TYPE)
	      (GET SYMBOL 'TYPE-EXPANDER)
	      (DOCUMENTATION (GET SYMBOL 'TYPE-EXPANDER) 'FUNCTION)))
	((SYMBOLP SYMBOL)
	 (OR (AND (FBOUNDP SYMBOL)
		  (DOCUMENTATION (FDEFINITION (UNENCAPSULATE-FUNCTION-SPEC SYMBOL))))))
	((CONSP SYMBOL)
	 (COND ((FUNCTIONP SYMBOL T)
		(IF (EQ (CAR SYMBOL) 'MACRO)
		    (DOCUMENTATION (CDR SYMBOL))
		  (MULTIPLE-VALUE-BIND (NIL NIL DOC)
		      (EXTRACT-DECLARATIONS (CDR (LAMBDA-EXP-ARGS-AND-BODY SYMBOL)) NIL T)
		    DOC)))
	       (T
		(AND (FDEFINEDP SYMBOL)
		     (DOCUMENTATION (FDEFINITION (UNENCAPSULATE-FUNCTION-SPEC SYMBOL)))))))
	((= (%DATA-TYPE SYMBOL) DTP-FEF-POINTER)
	 (CADR (ASSQ ':DOCUMENTATION (FUNCTION-DEBUGGING-INFO SYMBOL))))))

;Old name.
(DEFF FUNCTION-DOCUMENTATION 'DOCUMENTATION)

;These are for reading in QCOM, and the like
(DEFUN ASSIGN-ALTERNATE (X)
   (PROG NIL 
    L	(COND ((NULL X)(RETURN NIL)))
	(SET (CAR X) (CADR X))
	(SETQ X (CDDR X))
	(GO L)))

(DEFUN GET-ALTERNATE (X)
   (PROG (Y)
    L	(COND ((NULL X)(RETURN (REVERSE Y))))
	(SETQ Y (CONS (CAR X) Y))
	(SETQ X (CDDR X))
	(GO L)))

(DEFUN ASSIGN-VALUES (INPUT-LIST &OPTIONAL (SHIFT 0) (INIT 0) (DELTA 1))
   (PROG ()
LP	(COND ((NULL INPUT-LIST)(RETURN INIT)))
	(SET (CAR INPUT-LIST) (LSH INIT SHIFT))
	(SETQ INPUT-LIST (CDR INPUT-LIST))
	(SETQ INIT (+ INIT DELTA))
	(GO LP)))

(DEFUN ASSIGN-VALUES-INIT-DELTA (INPUT-LIST SHIFT INIT DELTA)
    (PROG NIL 
LP	(COND ((NULL INPUT-LIST) (RETURN INIT)))
	(SET (CAR INPUT-LIST) (LSH INIT SHIFT))
	(SETQ INPUT-LIST (CDR INPUT-LIST))
	(SETQ INIT (+ INIT DELTA))
	(GO LP)))

;(CALL function arg-desc-1 arg-data-1 arg-desc-2 arg-data-2 ...)
;The first argument is a function to call.
;The remaining arguments are in pairs, consisting of
;a descriptor arg and a data arg.
;The descriptor arg says what to do with the data arg.
;The descriptor arg value should be either a keyword or
;a list of keywords, the allowed keywords being :SPREAD and :OPTIONAL.
;:SPREAD means that the data argument is a list of arguments
;rather than a single argument.
;:OPTIONAL means that the data argument can be ignored if
;the function being called doesn't ask for it.
;After the first :OPTIONAL, all args supplied are considered optional.

(DEFUN CALL (FN &REST ALTERNATES
		&AUX (MAX-ARGS 100) (ARGS-INF (ARGS-INFO FN)))
    (AND (ZEROP (LDB %%ARG-DESC-QUOTED-REST ARGS-INF))
         (ZEROP (LDB %%ARG-DESC-EVALED-REST ARGS-INF))
         (SETQ MAX-ARGS (LDB %%ARG-DESC-MAX-ARGS ARGS-INF)))
    (%OPEN-CALL-BLOCK FN 0 4)
    (DO ((Y ALTERNATES (CDDR Y)) (OPTIONAL-FLAG) (SPREAD-FLAG NIL NIL)) ((NULL Y))
	(COND ((AND (SYMBOLP (CAR Y)) (NOT (NULL (CAR Y))))
	       (SELECTQ (CAR Y)
		   (:SPREAD (SETQ SPREAD-FLAG T))
		   (:OPTIONAL (SETQ OPTIONAL-FLAG T))
		   (OTHERWISE (FERROR NIL "Invalid CALL keyword ~S." (CAR Y)))))
	      (T (DO X (CAR Y) (CDR X) (NULL X)
		     (SELECTQ (CAR X)
			 (:SPREAD (SETQ SPREAD-FLAG T))
			 (:OPTIONAL (SETQ OPTIONAL-FLAG T))
			 (OTHERWISE (FERROR NIL "Invalid CALL keyword ~S." (CAR X)))))))
	(AND OPTIONAL-FLAG (<= MAX-ARGS 0)
	     (RETURN NIL))
	(COND (SPREAD-FLAG
	       (DO X (CADR Y) (CDR X) (OR (NULL X) (AND OPTIONAL-FLAG (<= MAX-ARGS 0)))
		   (%ASSURE-PDL-ROOM 1)
		   (%PUSH (CAR X))
		   (SETQ MAX-ARGS (1- MAX-ARGS))))
	      (T (%ASSURE-PDL-ROOM 1)
		 (%PUSH (CADR Y))
		 (SETQ MAX-ARGS (1- MAX-ARGS)))))
    (%ACTIVATE-OPEN-CALL-BLOCK))

;This is not a macro, for the sake of the compiler's definition of it,
;and for the sake of COMPILE-DRIVER.
(DEFUN COMPILER-LET (&QUOTE BINDLIST &REST BODY)
  "Perform bindings in BINDLIST at evaluation or compilation time.
In interpreted code, this is the same as LET.
When found in code being compiled, the bindings are done at compile time,
and are not done when the compiled code is run."
    (EVAL `(LET ,BINDLIST . ,BODY)))
(DEFMACRO-SET-INDENTATION-FOR-ZWEI 'COMPILER-LET 1)

(DEFUN DISK-RESTORE (&OPTIONAL PARTITION &AUX NAME COMMENT DESIRED-UCODE)
  "Restore partition PARTITION as a saved Lisp world.
PARTITION can be either a string naming a partition, or a number
which signifies a partition whose name starts with LOD.
Note that this does not change the running microcode.
You cannot successfully DISK-RESTORE a world that will not work
with the microcode that is running."
  (LET ((L (DISK-RESTORE-DECODE PARTITION)) (RQB NIL) BLOCK)
    (UNWIND-PROTECT
      (PROGN (SETQ RQB (GET-DISK-LABEL-RQB))
	     (READ-DISK-LABEL RQB 0)
	     (SETQ NAME (IF PARTITION
			    (STRING-APPEND (LDB 0010 (CADR L)) (LDB 1010 (CADR L))
					   (LDB 0010 (CAR L)) (LDB 1010 (CAR L)))
			    (GET-DISK-STRING RQB 7 4)))
	     (SETQ BLOCK (FIND-DISK-PARTITION-FOR-READ NAME RQB)
		   COMMENT (PARTITION-COMMENT NAME 0))
	     (MULTIPLE-VALUE-BIND (BASE-BAND VALID-FLAG)
		 (INC-BAND-BASE-BAND NAME 0)
	       (WHEN (AND BASE-BAND (NOT VALID-FLAG))
		 (FERROR NIL "Band ~A is incremental, and the base band ~A is no longer valid."
			 NAME BASE-BAND)))
	     (SETQ DESIRED-UCODE (GET-UCODE-VERSION-OF-BAND NAME)))
      (RETURN-DISK-RQB RQB))
    (AND ( DESIRED-UCODE %MICROCODE-VERSION-NUMBER)
	 (NOT (ZEROP DESIRED-UCODE))		;Not stored yet
	 (FORMAT QUERY-IO
		 "~&That band prefers microcode ~D but the running microcode is ~D.~%"
		 DESIRED-UCODE %MICROCODE-VERSION-NUMBER))
    (COND ((FQUERY FORMAT:YES-OR-NO-QUIETLY-P-OPTIONS
		   "Do you really want to reload ~A (~A)? " NAME COMMENT)
	   (AND (FBOUNDP 'TV:CLOSE-ALL-SERVERS)
		(TV:CLOSE-ALL-SERVERS "Disk-Restoring"))
	   (%DISK-RESTORE (CAR L) (CADR L))))))

(DEFVAR WHO-LINE-JUST-COLD-BOOTED-P NIL) ;Set to T upon cold boot for who-line's benefit

;;; Not patched in 94 due to GET-NEW-SYSTEM-VERSION.

;; Please do not add garbage to DISK-SAVE if possible.
;; Put random initializations on the BEFORE-COLD initialization list.
(DEFUN DISK-SAVE (PARTITION &OPTIONAL NO-QUERY INCREMENTAL)
  "Save the current Lisp world in partition PARTITION.
PARTITION can be either a string naming a partition, or a number
which signifies a partition whose name starts with LOD.
NO-QUERY says do not ask for confirmation (or any keyboard input at all)."
  (PROG* DISK-SAVE
	 ((L (DISK-RESTORE-DECODE PARTITION))
	  (PART-NAME (STRING-APPEND (LDB 0010 (CADR L)) (LDB 1010 (CADR L))
				    (LDB 0010 (CAR L)) (LDB 1010 (CAR L))))
	  PART-BASE PART-SIZE SYSTEM-VERSION MAX-ADDR
	  (INC-PAGES-SAVED 0))
    (OR (MULTIPLE-VALUE (PART-BASE PART-SIZE)
	  (IF NO-QUERY
	      (FIND-DISK-PARTITION-FOR-READ PART-NAME)
	    (FIND-DISK-PARTITION-FOR-WRITE PART-NAME)))
	(RETURN NIL))

    (UNLESS NO-QUERY
      (DOLIST (PATCH-SYSTEM PATCH-SYSTEMS-LIST)
	(WHEN (EQ (PATCH-STATUS PATCH-SYSTEM) ':INCONSISTENT)
	  (BEEP)
	  (FORMAT QUERY-IO "~&You have loaded patches out of sequence,
 or loaded unreleased patches, in ~A.
As a result, the environment is probably inconsistent with the
current patches and will remain so despite attempts to update it.
Unless you understand these problems well and know how to
be sure whether they are occurring, or how to clean them up,
you should not save this environment."
		  (PATCH-NAME PATCH-SYSTEM))
	  (SEND QUERY-IO ':CLEAR-INPUT)
	  (UNLESS (YES-OR-NO-P "Dump anyway? ")
	    (RETURN-FROM DISK-SAVE NIL)))))

    ;; This will catch most lossages before the user has waited.
    (UNLESS INCREMENTAL
      (CHECK-PARTITION-SIZE PART-SIZE))

    ;; Prompt now for this rather than waiting through all the initializations.
    (SETQ SYSTEM-VERSION
	  (IF NO-QUERY
	      (LET ((VERS (SYSTEM-VERSION-INFO T)))
		(SUBSTRING VERS 0 (MIN (LENGTH VERS) 16.)))
	    (GET-NEW-SYSTEM-VERSION INCREMENTAL)))

    ;; Cause cold boot initializations to happen when rebooted
    ;; and do the BEFORE-COLD initializations now
    (INITIALIZATIONS 'BEFORE-COLD-INITIALIZATION-LIST T)
    (RESET-INITIALIZATIONS 'COLD-INITIALIZATION-LIST)
    (SETQ WHO-LINE-JUST-COLD-BOOTED-P T)
    (LOGOUT)

    ;; Help stop user from getting worried.
    (WHEN INCREMENTAL
      (FORMAT T "~&NOTE: Comparing current memory contents with the original band
will take a few minutes.")
      (PROCESS-SLEEP 120.))

    ;; This can't be a before-cold initialization, because some other
    ;; initializations sometimes type out
    TV:(SHEET-FORCE-ACCESS (INITIAL-LISP-LISTENER)
	 (FUNCALL INITIAL-LISP-LISTENER ':REFRESH))

    (CHAOS:RESET)  ;Otherwise, UCODE could lose hacking packets as world dumped.

    ;; Compare all pages with band we booted from,
    ;; record unchanged pages in a bitmap in the band being saved in.
    (WHEN INCREMENTAL
      (SETQ INC-PAGES-SAVED (DISK-SAVE-INCREMENTAL PART-BASE)))

    ;; Check again before updating the partition comment.
    (CHECK-PARTITION-SIZE (+ INC-PAGES-SAVED PART-SIZE))
    (UPDATE-PARTITION-COMMENT PART-NAME SYSTEM-VERSION 0)

    ;; Now shut down the world and check the partition size for real, just
    ;; to make sure that we didn't exceed the size very recently.
    (DOLIST (S TV:ALL-THE-SCREENS) (TV:SHEET-GET-LOCK S))
    (TV:WITH-MOUSE-USURPED
      (WITHOUT-INTERRUPTS
	(SETQ TV:MOUSE-SHEET NIL)
	(DOLIST (S TV:ALL-THE-SCREENS)
	  (FUNCALL S ':DEEXPOSE)
	  (TV:SHEET-RELEASE-LOCK S))
	;; The process we are now executing in will look like it was warm-booted when
	;; this saved band is restored.  Suppress the warm-boot message, but disable
	;; and flush the process so it doesn't start running with its state destroyed.
	;; We'd like to :RESET it, but can't because we are still running in it.
	;; If the process is the initial process, it will get a new state and get enabled
	;; during the boot process.
	(PROCESS-DISABLE CURRENT-PROCESS)
	(SET-PROCESS-WAIT CURRENT-PROCESS 'FLUSHED-PROCESS NIL)
	(SETQ CURRENT-PROCESS NIL)
	;; Once more with feeling, and bomb out badly if losing.
	(SETQ MAX-ADDR (FIND-MAX-ADDR))
	(CHECK-PARTITION-SIZE (+ INC-PAGES-SAVED PART-SIZE) T)
	;; Store the size in words rather than pages.  But don't get a bignum!
	(SETF (SYSTEM-COMMUNICATION-AREA %SYS-COM-HIGHEST-VIRTUAL-ADDRESS)
	      (LSH MAX-ADDR 8))
	(DO I 600 (1+ I) (= I 640)	;Clear the disk error log
	    (%P-DPB 0 %%Q-LOW-HALF I)
	    (%P-DPB 0 %%Q-HIGH-HALF I))
	(%DISK-SAVE (IF INCREMENTAL
			(- (SYSTEM-COMMUNICATION-AREA %SYS-COM-MEMORY-SIZE))
		      (SYSTEM-COMMUNICATION-AREA %SYS-COM-MEMORY-SIZE))
		    (CAR L) (CADR L))))))

(DEFUN CHECK-PARTITION-SIZE (PART-SIZE &OPTIONAL EXPOSE-P)
  (LET ((DUMP-SIZE (ESTIMATE-DUMP-SIZE)))
    (COND ((> DUMP-SIZE PART-SIZE)
	 ;; This test is not necessarily accurate, since we have not
	 ;; yet shut off the world.  However, it should catch most cases,
	 ;; so that this error will be detected before the partition comment
	 ;; gets clobbered.
	   (AND EXPOSE-P (FUNCALL TV:MAIN-SCREEN ':EXPOSE))
	   (FERROR NIL "Cannot save, partition too small.  Need at least ~D. pages.~@[~@
                      Warm Boot please.~]" DUMP-SIZE EXPOSE-P)))
    DUMP-SIZE))

(DEFUN ESTIMATE-DUMP-SIZE NIL
  (DO ((REGION 0 (1+ REGION))
       (SIZE 0))
      ((= REGION (REGION-LENGTH REGION-LENGTH))
       SIZE)
    ;; Check each region.  If it is free, ignore it.  Otherwise,
    ;; add how many pages it will take to dump it.
    (COND ((NOT (= (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))
		   %REGION-SPACE-FREE))	   
	   (SETQ SIZE (+ SIZE (CEILING (REGION-TRUE-FREE-POINTER REGION)
				       PAGE-SIZE)))))))

;;; Find the highest address in the virtual memory.  If you call this without
;;; inhibiting interrupts, the result is not strictly correct since some
;;; other process could invalidate it at any time by CONSing.  However,
;;; it gives you a good idea and a lower bound.  The answer is in number
;;; of pages.
(DEFUN FIND-MAX-ADDR ()
  (DO ((REGION 0 (1+ REGION))
       (MAX-ADDR 0))
      ((= REGION (REGION-LENGTH REGION-LENGTH))
       (TRUNCATE MAX-ADDR PAGE-SIZE))
    ;; Check each region.  If it is free, ignore it.  Otherwise,
    ;; find the highest address of that region, and get the
    ;; highest such address.
    (COND ((NOT (= (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))
		   %REGION-SPACE-FREE))	   
	   (SETQ MAX-ADDR (MAX MAX-ADDR (+ (REGION-ORIGIN-TRUE-VALUE REGION)
					   (REGION-TRUE-LENGTH REGION))))))))

(DEFUN REGION-ORIGIN-TRUE-VALUE (REGION)
  	;below crock avoids returning a negative number if region starts above
	; half way point in address space.  It can make a bignum so be careful!
  (24-BIT-UNSIGNED (REGION-ORIGIN REGION)))

(DEFUN REGION-TRUE-LENGTH (REGION)
  	;below crock avoids returning a negative number if region has a large
        ; length. It can make a bignum so be careful!
  (24-BIT-UNSIGNED (REGION-LENGTH REGION)))

(DEFUN REGION-TRUE-FREE-POINTER (REGION)
  	;below crock avoids returning a negative number if region has a large
        ; length. It can make a bignum so be careful!
  (24-BIT-UNSIGNED (REGION-FREE-POINTER REGION)))

(DEFUN DISK-RESTORE-DECODE (PARTITION &AUX LOW-16-BITS HI-16-BITS)
    (COND ((NULL PARTITION)
	   (SETQ LOW-16-BITS 0 HI-16-BITS 0))
	  ((NUMBERP PARTITION)
	   (SETQ LOW-16-BITS (+ #/L (LSH #/O 8)))
	   (SETQ HI-16-BITS (+ #/D (LSH (+ #/0 PARTITION) 8))))
	  ((SYMBOLP PARTITION)
	   (SETQ LOW-16-BITS (+ #/L (LSH #/O 8)))
	   (SETQ HI-16-BITS (+ #/D (LSH (AREF (GET-PNAME PARTITION) 0) 8))))
	  ((STRINGP PARTITION)
	   (SETQ LOW-16-BITS (+ (CHAR-UPCASE (AR-1 PARTITION 0))
				(LSH (CHAR-UPCASE (AR-1 PARTITION 1)) 8)))
	   (SETQ HI-16-BITS (+ (CHAR-UPCASE (AR-1 PARTITION 2))
			       (LSH (CHAR-UPCASE (AR-1 PARTITION 3)) 8))))
	  (T (FERROR NIL "~S is not a valid partition name." PARTITION)))
    (LIST HI-16-BITS LOW-16-BITS))

(DEFUN GET-FROM-ALTERNATING-LIST (L KEY) 
"Retreive associated item from an alternating list
Like GET, but no initial CAR"
  (GET (LOCF L) KEY))

(DEFUN PUT-ON-ALTERNATING-LIST (ITEM L KEY)
"Put an item on an alternating association list
Modifies the current association, if any.
Otherwise adds one to the head of the list.  
Returns the augmented list as value.
The user should alway use this value unless he is
certain there is a current association"
  (PROG (PNTR)
	(SETQ PNTR L)
     L  (COND ((NULL L) (RETURN (CONS KEY (CONS ITEM L))))
	      ((EQ KEY (CAR L))
	       (RPLACA (CDR L) ITEM)
	       (RETURN L)))
	(SETQ L (CDDR L))
	(GO L)))

(DEFUN READ-METER (NAME)
"Read the value of the A Memory metering location
specified by the argument"
   (LET ((A-OFF (+ %COUNTER-BLOCK-A-MEM-ADDRESS
		   (OR (FIND-POSITION-IN-LIST NAME A-MEMORY-COUNTER-BLOCK-NAMES)
		       (FERROR NIL "~S is not a valid counter name." NAME)))))
      (WITHOUT-INTERRUPTS	;Try not to get inconsistent numbers
	  (DPB (%P-LDB 2020 (+ A-MEMORY-VIRTUAL-ADDRESS A-OFF))
	       2020
	       (%P-LDB 0020 (+ A-MEMORY-VIRTUAL-ADDRESS A-OFF))))))

(DEFUN WRITE-METER (NAME VAL)
"Set  the value of the A Memory metering location
specified by the first argument to the second argument"
    (LET ((A-OFF (+ %COUNTER-BLOCK-A-MEM-ADDRESS
		   (OR (FIND-POSITION-IN-LIST NAME A-MEMORY-COUNTER-BLOCK-NAMES)
		       (FERROR NIL "~S is not a valid counter name." NAME)))))
     (WITHOUT-INTERRUPTS
	 (%P-DPB (LDB 2020 VAL)
		 2020
		 (+ A-MEMORY-VIRTUAL-ADDRESS A-OFF))
	 (%P-DPB (LDB 0020 VAL)  ;Must LDB to get correct low bits if bignum!
		 0020
		 (+ A-MEMORY-VIRTUAL-ADDRESS A-OFF)))))

(DEFUN CHANGE-INDIRECT-ARRAY (ARRAY TYPE DIMLIST DISPLACED-P INDEX-OFFSET
			      &AUX INDEX-LENGTH NDIMS INDIRECT-LENGTH TEM
				   OLD-NDIMS OLD-INDIRECT-LENGTH)
  "Change an indirect array ARRAY's type, size, or target pointed at.
TYPE specifies the new array type, DIMLIST its new dimensions,
DISPLACED-P the target it should point to (array, locative or fixnum),
INDEX-OFFSET the new offset in the new target."
  (CHECK-ARG ARRAY ARRAYP "an array")
  (OR (= (%P-LDB-OFFSET %%ARRAY-DISPLACED-BIT ARRAY 0) 1)
      (FERROR NIL "~S is not a displaced array." ARRAY))
  (CHECK-ARG DISPLACED-P (OR (ARRAYP DISPLACED-P) (FIXP DISPLACED-P)
			     (LOCATIVEP DISPLACED-P))
	     "an array or physical address to indirect to")
  (CHECK-ARG TYPE		;TEM gets the numeric array type
	     (SETQ TEM (COND ((NUMBERP TYPE) (LDB %%ARRAY-TYPE-FIELD TYPE))
			     ((FIND-POSITION-IN-LIST TYPE ARRAY-TYPES))))
	     "an array type")
  (SETQ TYPE TEM)
  (COND ((NLISTP DIMLIST)
	 (SETQ NDIMS 1 INDEX-LENGTH (EVAL DIMLIST)))
	(T (SETQ NDIMS (LENGTH DIMLIST)
		 INDEX-LENGTH (LIST-PRODUCT DIMLIST))))
  (SETQ INDIRECT-LENGTH (IF INDEX-OFFSET 3 2)
	OLD-NDIMS (%P-LDB-OFFSET %%ARRAY-NUMBER-DIMENSIONS ARRAY 0)
	OLD-INDIRECT-LENGTH (%P-LDB-OFFSET %%ARRAY-INDEX-LENGTH-IF-SHORT ARRAY 0))
  (OR (= NDIMS OLD-NDIMS)
      (FERROR NIL "Attempt to change the number of dimensions from ~D to ~D."
	          OLD-NDIMS NDIMS))
  (OR (= INDIRECT-LENGTH OLD-INDIRECT-LENGTH)
      (FERROR NIL "Attempt to add or remove index-offset."))
  (%P-DPB-OFFSET TYPE %%ARRAY-TYPE-FIELD ARRAY 0)
  (AND ARRAY-INDEX-ORDER
       (LISTP DIMLIST)
       (SETQ DIMLIST (REVERSE DIMLIST)))
  (AND (LISTP DIMLIST)
       (DO ((I 1 (1+ I))
	    (N NDIMS (1- N)))
	   ((< N 2))
	 (%P-STORE-CONTENTS-OFFSET (EVAL (CAR DIMLIST)) ARRAY I)
	 (SETQ DIMLIST (CDR DIMLIST))))
  (%P-STORE-CONTENTS-OFFSET DISPLACED-P ARRAY NDIMS)
  (%P-STORE-CONTENTS-OFFSET INDEX-LENGTH ARRAY (1+ NDIMS))
  (COND (INDEX-OFFSET
	  (%P-STORE-CONTENTS-OFFSET INDEX-OFFSET ARRAY (+ NDIMS 2))))
  ARRAY)

(DEFUN IGNORE (&REST IGNORE)
  "Discard any number of arguments and return NIL."
  NIL)

(DEFF LEXPR-FUNCALL-WITH-MAPPING-TABLE-INTERNAL 'LEXPR-FUNCALL-WITH-MAPPING-TABLE)
(DEFUN LEXPR-FUNCALL-WITH-MAPPING-TABLE (FUNCTION &QUOTE TABLE &EVAL &REST ARGS)
  "Call FUNCTION like LEXPR-FUNCALL but provide mapping table TABLE.
If FUNCTION is a flavor method, this saves it from having to find
the correct flavor mapping table, but it will lose if you give the wrong one."
  TABLE
  (LEXPR-FUNCALL 'LEXPR-FUNCALL FUNCTION ARGS))

(DEFF FUNCALL-WITH-MAPPING-TABLE-INTERNAL 'FUNCALL-WITH-MAPPING-TABLE)
(DEFUN FUNCALL-WITH-MAPPING-TABLE (FUNCTION &QUOTE TABLE &EVAL &REST ARGS)
  "Call FUNCTION like FUNCALL but provide mapping table TABLE.
If FUNCTION is a flavor method, this saves it from having to find
the correct flavor mapping table, but it will lose if you give the wrong one."
  TABLE
  (APPLY FUNCTION ARGS))

; STRING-IO stream handler.  Note that DEFSELECT doesn't work in the cold load.
; WITH-INPUT-FROM-STRING and WITH-OUTPUT-FROM-STRING used to compile into calls to this.
; It is now obsolete, but present for the sake of old compiled code.

; Supported operations:
; :TYI, :TYO, :STRING-OUT, :LINE-OUT, :FRESH-LINE, :READ-POINTER -- these are normal
; :SET-POINTER -- This works to any location in the string.  If done to an output string,
;                 and it hasn't gotten there yet, the string will be extended.  (The
;                 elements in between will contain garbage.)
; :UNTYI -- you can UNTYI as many characters as you like.  The argument is ignored.
; :READ-CURSORPOS, :INCREMENT-CURSORPOS -- These work on the X axis only; they ignore Y.
;                 They are defined only for :CHARACTER units; :PIXEL will give an error.
; :UNTYO, :UNTYO-MARK -- These exist to keep the grinder happy.
; :CONSTRUCTED-STRING -- This is a special operation required by the operation of the
;                 WITH-OPEN-STRING macro.  This is how the string is extracted from the
;                 stream closure.  You shouldn't need to use this.

(defvar *string-io-string*)
(defvar *string-io-index*)
(defvar *string-io-limit*)
(defvar *string-io-direction*)
(defvar *string-io-stream*)

(defmacro-displace maybe-grow-io-string (index)
  `(if ( ,index *string-io-limit*)
       (adjust-array-size *string-io-string*
			  (setq *string-io-limit* (fix (* (1+ ,index) 1.5s0))))))

(defmacro-displace string-io-add-character (ch)
  `(progn (maybe-grow-io-string *string-io-index*)
	  (aset ,ch *string-io-string* *string-io-index*)
	  (incf *string-io-index*)))

(defmacro-displace string-io-add-line (string start end)
  `(let* ((string-io-length (- ,end ,start))
	  (string-io-finish-index (+ *string-io-index* string-io-length)))
     (maybe-grow-io-string string-io-finish-index)
     (copy-array-portion ,string ,start ,end
			 *string-io-string* *string-io-index* string-io-finish-index)
     (setq *string-io-index* string-io-finish-index)))

(defselect (string-io string-io-default-handler)
  (:tyi (&optional eof)
	(if (< *string-io-index* *string-io-limit*)
	    (prog1 (aref *string-io-string* *string-io-index*)
		   (incf *string-io-index*))
	  (and eof (ferror 'sys:end-of-file-1 "End of file on ~S." *string-io-stream*))))
  (:untyi (ignore)
	  (if (minusp (setq *string-io-index* (1- *string-io-index*)))
	      (error "Attempt to :UNTYI past beginning -- STRING-IO")))
  (:tyo (ch)
	(string-io-add-character ch))
  (:string-out (string &optional start end)
	       (or start (setq start 0))
	       (or end (setq end (array-active-length string)))
	       (string-io-add-line string start end))
  (:line-out (string &optional start end)
	     (or start (setq start 0))
	     (or end (setq end (array-active-length string)))
	     (string-io-add-line string start end)
	     (string-io-add-character #\Return))
  (:fresh-line ()
	       (and (plusp *string-io-index*)
		    ( (aref *string-io-string* *string-io-index*) #\Return)
		    (string-io-add-character #\Return)))
  (:read-pointer () *string-io-index*)
  (:set-pointer (ptr)
		(and (neq *string-io-direction* ':in)
		     (< ptr *string-io-limit*)
		     (error "Attempt to :SET-POINTER beyond end of string -- STRING-IO"))
		(setq *string-io-index* ptr))
  (:untyo-mark () *string-io-index*)
  (:untyo (mark) (setq *string-io-index* mark))
  (:read-cursorpos (&optional (units ':pixel))
		   (string-io-confirm-movement-units units)
		   (let ((string-io-return-index
			   (string-reverse-search-char #\Return *string-io-string*
						       *string-io-index*)))
		     (if string-io-return-index
			 (- *string-io-index* string-io-return-index)
		       *string-io-index*)))
  (:increment-cursorpos (x ignore &optional (units ':pixel))
			(string-io-confirm-movement-units units)
			(dotimes (i x) (string-io-add-character #\Space)))
  (:constructed-string ()
    ;; Don't change allocated size if we have a fill pointer!
    (if (array-has-leader-p *string-io-string*)
	(setf (fill-pointer *string-io-string*) *string-io-index*)
      (setq *string-io-string*
	    (adjust-array-size *string-io-string* *string-io-index*)))))

(defun string-io-default-handler (op &optional arg1 &rest rest)
  (stream-default-handler 'string-io op arg1 rest))

(defun string-io-confirm-movement-units (units)
  (if (neq units ':character)
      (ferror nil "Unimplemented cursor-movement unit ~A -- STRING-IO." units)))


(DEFINE-SITE-VARIABLE *DEFAULT-PRINTER* :DEFAULT-PRINTER
  "Default for :PRINTER argument to hardcopy functions.
Either a keyword for a type of printer,
or a list of such a keyword and arguments saying which printer of that type.")

(DEFINE-SITE-VARIABLE *DEFAULT-BIT-ARRAY-PRINTER* :DEFAULT-BIT-ARRAY-PRINTER
  "Default for :PRINTER argument to HARDCOPY-SCREEN-ARRAY.
Either a keyword for a type of printer,
or a list of such a keyword and arguments saying which printer of that type.")

(DEFMACRO DECODE-PRINTER-ARGUMENT (PRINTER PROP)
  `(DO-FOREVER
     (LET ((PRINTER-TYPE (IF (CONSP ,PRINTER) (CAR ,PRINTER) ,PRINTER)))
       (IF (GET PRINTER-TYPE ,PROP) (RETURN (GET PRINTER-TYPE ,PROP)))
       (SETQ ,PRINTER (CERROR T NIL NIL
			      "The printer ~S cannot do ~A" ,PRINTER ,PROP)))))

(DEFUN HARDCOPY-FILE (FILE-NAME &REST OPTIONS
		      &KEY &OPTIONAL FORMAT (PRINTER *DEFAULT-PRINTER*)
		      &ALLOW-OTHER-KEYS
		      &AUX (PATHNAME (FS:MERGE-PATHNAME-DEFAULTS FILE-NAME)))
  "Print the file FILE-NAME on a printer.
:FORMAT specifies the file format; options are :TEXT, :PRESS, :XGP or :SUDS-PLOT.
:PRINTER specifies the printer to use; default is SI:*DEFAULT-PRINTER*.
:FONT specifies the font to use; or, :FONT-LIST a list of fonts to use.
:HEADING-FONT specifies the font for page headings.
:PAGE-HEADINGS NIL inhibits generation of page headings.
:VSP is the space to leave between lines, in micas [only for printers that use press]
:COPIES specifies the number of copies to be printed.
:SPOOL T says spool the file, if the selected printer has optional spooling."
  (DECLARE (ARGLIST FILE-NAME
		    &KEY &OPTIONAL FORMAT
		    (FONT "LPT8") FONT-LIST HEADING-FONT
		    (PAGE-HEADINGS T) VSP (COPIES 1) SPOOL))
  (OR FORMAT

      (SETQ FORMAT
	    (SELECTOR (SEND PATHNAME ':TYPE) EQUALP
	      (("PRESS" "PRE") ':PRESS)
	      ("XGP" ':XGP)
	      ("PLT" ':SUDS-PLOT)
	      (T ':TEXT))))
  (LEXPR-FUNCALL (DECODE-PRINTER-ARGUMENT PRINTER 'PRINT-FILE)
		   PRINTER FILE-NAME ':FORMAT FORMAT OPTIONS))

(DEFUN HARDCOPY-STREAM (STREAM &REST OPTIONS
			&KEY &OPTIONAL (PRINTER *DEFAULT-PRINTER*)
			&ALLOW-OTHER-KEYS)
  "Print the text read from STREAM on a printer.
:PRINTER specifies the printer to use; default is SI:*DEFAULT-PRINTER*.
:FILE-NAME is an arbitrary string to use as the /"filename/" on the listing.
:FONT specifies the font to use; or, :FONT-LIST a list of fonts to use.
:HEADING-FONT specifies the font for page headings.
:PAGE-HEADINGS NIL inhibits generation of page headings.
:VSP is the space to leave between lines, in micas [only for printers that use press]
:COPIES specifies the number of copies to be printed.
:SPOOL T says spool the file, if the selected printer has optional spooling."
  (DECLARE (ARGLIST STREAM
		    &KEY &OPTIONAL FILE-NAME
		    (FONT "LPT8") FONT-LIST HEADING-FONT
		    (PAGE-HEADINGS T) VSP (COPIES 1) SPOOL))
  (LEXPR-FUNCALL (DECODE-PRINTER-ARGUMENT PRINTER 'PRINT-STREAM)
		 PRINTER STREAM OPTIONS))

(DEFUN HARDCOPY-BIT-ARRAY (ARRAY LEFT TOP RIGHT BOTTOM &REST OPTIONS
			   &KEY &OPTIONAL
			   (PRINTER (OR *DEFAULT-BIT-ARRAY-PRINTER* *DEFAULT-PRINTER*))
			   &ALLOW-OTHER-KEYS)
  "Print all or part of the bits in ARRAY on the printer PRINTER.
PRINTER defaults to SI:*DEFAULT-BIT-ARRAY-PRINTER*,
 or to SI:*DEFAULT-PRINTER* if the former is NIL.
LEFT, TOP, RIGHT, BOTTOM specify the part of the array to print,
 measuring from the top left corner."
  (LEXPR-FUNCALL (DECODE-PRINTER-ARGUMENT PRINTER 'PRINT-BIT-ARRAY)
		 PRINTER ARRAY LEFT TOP RIGHT BOTTOM OPTIONS))

(DEFUN HARDCOPY-STATUS (&OPTIONAL (PRINTER *DEFAULT-PRINTER*)
			(STREAM STANDARD-OUTPUT))
  "Print the status of printer PRINTER on STREAM."
  (FUNCALL (DECODE-PRINTER-ARGUMENT PRINTER 'PRINT-STATUS)
	   PRINTER STREAM))

;; At the moment, there's only one "LPT" per host.  Maybe the FILE protocol can
;; accomodate us...  Also, there might be a way of simulating fonts with a DEC
;; (or a Paper Tiger, etc).  :LPT doesn't assume anything like that for now.
(DEFUN (:PROPERTY :LPT PRINT-FILE) (PRINTER FILE-NAME
				    &OPTIONAL &KEY (FORMAT ':TEXT) &ALLOW-OTHER-KEYS)
  (IF (EQ FORMAT ':TEXT)
      (WITH-OPEN-FILE-CASE (FILE-STREAM FILE-NAME ':DIRECTION ':INPUT)
	(FS:FILE-ERROR
	 (SEND ERROR-OUTPUT ':FRESH-LINE)
	 (SEND ERROR-OUTPUT ':STRING-OUT "LPT error in opening file: ")
	 (SEND FILE-STREAM ':REPORT ERROR-OUTPUT))
	(:NO-ERROR (LPT-PRINT-STREAM PRINTER FILE-STREAM)))
    (FORMAT ERROR-OUTPUT "~&LPT's only know about the TEXT format, not ~S." FORMAT)))

(DEFUN (:PROPERTY :LPT PRINT-STREAM) (PRINTER STREAM
				      &OPTIONAL &KEY (FORMAT ':TEXT) &ALLOW-OTHER-KEYS)
  (IF (EQ FORMAT ':TEXT)
      (LPT-PRINT-STREAM PRINTER STREAM)
    (FORMAT ERROR-OUTPUT "~&LPT's only now about the TEXT format, not ~S." FORMAT)))

;; By this point, the FORMAT had darn well better be :TEXT...
(DEFUN LPT-PRINT-STREAM (PRINTER FROM-STREAM &AUX (HOST (IF (LISTP PRINTER)
							    (SI:PARSE-HOST (SECOND PRINTER))
							  SI:ASSOCIATED-MACHINE)))
  (WITH-OPEN-FILE-CASE
    (STREAM (FS:MAKE-PATHNAME ':HOST HOST
			      ':DEVICE (SELECTQ (SEND HOST ':SYSTEM-TYPE)
					 (:ITS "TPL")
					 (:UNIX ':UNSPECIFIC)
					 (OTHERWISE "LPT"))
			      ':DIRECTORY (IF (EQ (SEND HOST ':SYSTEM-TYPE) ':UNIX) '("lpr")))
	    ':DIRECTION ':OUTPUT)
    (FS:FILE-ERROR
     (SEND ERROR-OUTPUT ':FRESH-LINE)
     (SEND ERROR-OUTPUT ':STRING-OUT "LPT error in opening file: ")
     (SEND STREAM ':REPORT ERROR-OUTPUT))
    (:NO-ERROR (STREAM-COPY-UNTIL-EOF FROM-STREAM STREAM))))

(DEFVAR *MODULES* NIL
  "List of modules marked present with PROVIDE.
All systems loaded with MAKE-SYSTEM are also present.")

(DEFUN PROVIDE (MODULE)
  "Mark MODULE as being already loaded."
  (UNLESS (MEM 'STRING= MODULE *MODULES*)
    (PUSH (INTERN (STRING MODULE) 'KEYWORD) *MODULES*)))

(DEFUN REQUIRE (MODULE &OPTIONAL PATHNAMES)
  "Cause MODULE to be loaded if it isn't yet.
If PATHNAMES is specified, it should be a pathname or a list of pathnames;
 those files are loaded.
Otherwise, MAKE-SYSTEM is done on MODULE."
  (UNLESS (MEM 'STRING= MODULE *MODULES*)
    (COND ((CONSP PATHNAMES)
	   (MAPC 'LOAD PATHNAMES))
	  (PATHNAMES (LOAD PATHNAMES))
	  (T (MAKE-SYSTEM MODULE)))))
