;;; -*- Mode:LISP; Package:SI; Cold-load:T; Base:8; Lowercase:T -*-
;;; LISP machine character level I/O stuff
;;; ** (c) Copyright 1980 Massachusetts Institute of Technology **

(SETQ STREAM-INPUT-OPERATIONS
      '(:TYI :LISTEN :UNTYI :LINE-IN :RUBOUT-HANDLER))

(SETQ STREAM-OUTPUT-OPERATIONS
      '(:TYO :FORCE-OUTPUT :FINISH :STRING-OUT :LINE-OUT :FRESH-LINE :UNTYO-MARK :UNTYO))

;;; Naming conventions:
;;;   Symbols whose names end in "-INPUT", "-OUTPUT", or "-IO" should
;;;      normally be BOUND to streams; which of the three you use depends on
;;;      what directions the stream normally supports.
;;;   Symbols whose names end in "-STREAM" are DEFINED as streams.


;;; Synonyms.
;;; MAKE-SYN-STREAM takes a symbol, and returns a stream which will forward all operations
;;;   to the binding of the symbol.  After (SETQ BAR (MAKE-SYN-STREAM 'FOO)), one says
;;;   that BAR is SYNned to FOO.


;;; The initial environment.
;;;   The initial binding of streams (set up by LISP-REINITIALIZE) is
;;;      as follows:
;;;   *TERMINAL-IO*	- This is how to get directly to the user's terminal.  It is set
;;;			up to go to the TV initially.  Other places it might go are to
;;;   *STANDARD-INPUT*	- This is initially bound to SYN to *TERMINAL-IO*.
;;;   *STANDARD-OUTPUT*	- This is initially bound to SYN to *TERMINAL-IO*. *STANDARD-INPUT*
;;;			and *STANDARD-OUTPUT* are the default streams for READ, PRINT and
;;;			other things.  *STANDARD-OUTPUT* gets hacked when the session is
;;;			being scripted, for example.
;;;   *ERROR-OUTPUT*	- This is where error messages should eventually get sent. Initially
;;;			SYNned to *TERMINAL-IO*.
;;;   *QUERY-IO*	- This is for unexpected user queries of the
;;;			"Do you really want to ..." variety. Initially SYNned to *TERMINAL-IO*
;;;   *TRACE-OUTPUT*	- Output produced by TRACE goes here.
;;;			 Initially SYNned to *ERROR-OUTPUT*.


(DEFVAR *STANDARD-INPUT* :UNBOUND
  "Default stream for input functions such as READ.")
(DEFVAR *TERMINAL-IO* :UNBOUND
  "Stream to use for /"terminal/" I//O.  Normally the selected window.
*STANDARD-INPUT* and other default streams are usually set up
as synonym streams which will use the value of *TERMINAL-IO*.")
(DEFVAR *ERROR-OUTPUT* :UNBOUND
  "Stream to use for unanticipated noninteractive output, such as warnings.")
(DEFVAR *QUERY-IO* :UNBOUND
  "Stream to use for unanticipated questions, and related prompting, echoing, etc.")

(DEFVAR STANDARD-INPUT :UNBOUND
  "Default stream for input functions such as READ.")
(DEFVAR TERMINAL-IO :UNBOUND
  "Stream to use for /"terminal/" I//O.  Normally the selected window.
*STANDARD-INPUT* and other default streams are usually set up
as synonym streams which will use the value of *TERMINAL-IO*.")
(DEFVAR ERROR-OUTPUT :UNBOUND
  "Stream to use for unanticipated noninteractive output, such as warnings.")
(DEFVAR QUERY-IO :UNBOUND
  "Stream to use for unanticipated questions, and related prompting, echoing, etc.")

(FORWARD-VALUE-CELL 'TERMINAL-IO '*TERMINAL-IO*)
(FORWARD-VALUE-CELL 'STANDARD-INPUT '*STANDARD-INPUT*)
(FORWARD-VALUE-CELL 'STANDARD-OUTPUT '*STANDARD-OUTPUT*)
(FORWARD-VALUE-CELL 'ERROR-OUTPUT '*ERROR-OUTPUT*)
(FORWARD-VALUE-CELL 'QUERY-IO '*QUERY-IO*)

(DEFVAR RUBOUT-HANDLER :UNBOUND
  "Bound to stream which is inside rubout-handler, or NIL if none.")

(DEFUN STREAMP (OBJECT)
  "Returns non-NIL if OBJECT is a stream.
This predicate considers the following to be streams:
 Any instance incorporating SI:STREAM or TV:SHEET
 Any function handling either :TYI or :TYO.
 Any symbol with a non-NIL SI:IO-STREAM-P property."
  (OR (AND (INSTANCEP OBJECT) (OR (TYPEP-STRUCTURE-OR-FLAVOR OBJECT 'STREAM)
				  (TYPEP OBJECT 'TV:SHEET)))
      ; Explicit FUNCALLed things that accept messages
      (AND (OR (CLOSUREP OBJECT)
	       (ENTITYP OBJECT)
	       (FUNCTIONP OBJECT))
	   (ARGLIST OBJECT T)
	   (LET ((WO (SEND OBJECT ':WHICH-OPERATIONS)))
	     (IGNORE-ERRORS
	       (OR (MEMQ ':TYO WO)
		   (MEMQ ':TYI WO)))))
      (AND (SYMBOLP OBJECT) (GET OBJECT 'IO-STREAM-P))))

(DEFUN INPUT-STREAM-P (STREAM) 
  "T if STREAM, assumed to be a stream, supports input."
  (MEMQ (SEND STREAM ':DIRECTION) '(:INPUT :BIDIRECTIONAL)))

(DEFUN OUTPUT-STREAM-P (STREAM)
  "T if STREAM, assumed to be a stream, supports output."
  (MEMQ (SEND STREAM ':DIRECTION) '(:OUTPUT :BIDIRECTIONAL)))

(DEFUN IO-STREAM-P (X)
  "T if X is a plausible I//O stream.
It must be an insance, entity, closure, compiled function
or a symbol which has a non-NIL SI:IO-STREAM-P property."
  (SELECT (%DATA-TYPE X)
    (DTP-INSTANCE T)
    (DTP-ENTITY T)
    (DTP-CLOSURE T)
    (DTP-FEF-POINTER T)
    (DTP-SELECT-METHOD T)
    (DTP-SYMBOL (GET X 'IO-STREAM-P))
    (T NIL)))

(DEFUN STREAM-ELEMENT-TYPE (STREAM)
  "Return a Common Lisp type describing the objects input or output by STREAM.
This will be either CHARACTER or STRING-CHAR or a subtype of INTEGER."
  (OR (SEND STREAM ':SEND-IF-HANDLES ':ELEMENT-TYPE)
      (IF (SEND STREAM ':CHARACTERS)
	  'CHARACTER
	(LET ((VALUE (SEND STREAM ':SEND-IF-HANDLES ':BYTE-SIZE)))
	  (IF VALUE `(UNSIGNED-BYTE ,VALUE) 'FIXNUM)))))

;;; Given the 2 arguments to READ (or TYI or READCH or TYIPEEK or READLINE)
;;; in the form of a REST argument this returns the input stream and the eof option.
;;; Note that the first arg would rather be the stream than the eof option.
;;; This is set up for Maclisp compatibility.
;;; HOWEVER, if the second argument is NIL or unsupplied, the first is
;;; assumed to be a stream if that is plausible,
;;; which is not compatible with Maclisp but more winning.
;;; If the user didn't supply an eof-option, the second value returned will
;;; be the symbol NO-EOF-OPTION.
(DEFUN DECODE-READ-ARGS (ARG-LIST)
  (SELECTQ (LENGTH ARG-LIST)
    (0 (VALUES *STANDARD-INPUT* 'NO-EOF-OPTION))
    (1 (LET ((ARG1 (FIRST ARG-LIST)))
	 (IF (OR (EQ ARG1 NIL) (EQ ARG1 T) (IO-STREAM-P ARG1))
	     ;; The arg is a plausible stream.
	     (VALUES (decode-read-arg arg1)
		     'NO-EOF-OPTION)
	     ;; It is not a stream and must be an EOF option.
	   (VALUES *STANDARD-INPUT*
		   ARG1))))
    (2 (LET ((ARG1 (FIRST ARG-LIST))
	     (ARG2 (SECOND ARG-LIST)))
	 (COND ((OR (EQ ARG1 NIL) (EQ ARG1 T) (IO-STREAM-P ARG1))
		(VALUES (decode-read-arg arg1)
			ARG2))
	       ((OR (EQ ARG2 NIL) (EQ ARG2 T) (IO-STREAM-P ARG2))
		(VALUES (decode-read-arg arg2)
			ARG1))
	       (T (VALUES ARG1 ARG2)))))
    (OTHERWISE
     (FERROR NIL "Too many arguments were given to one of the READ-like functions: ~S"
	     ARG-LIST))))

(DEFUN TERPRI (&OPTIONAL STREAM)
  "Go to a new line on STREAM."
  (SEND (DECODE-PRINT-ARG STREAM) ':TYO #/RETURN)
  T)

(DEFUN CLI:TERPRI (&OPTIONAL STREAM)
  "Go to a new line on STREAM."
  (SEND (DECODE-PRINT-ARG STREAM) ':TYO #/RETURN)
  NIL)

(DEFUN FRESH-LINE (&OPTIONAL STREAM)
  "Go to a new line on STREAM if not already at the beginning of one.
Returns T if a Return was output, NIL if nothing output."
  (SEND (DECODE-PRINT-ARG STREAM) ':FRESH-LINE))

(DEFUN TYO (CHAR &OPTIONAL STREAM)
  "Output CHAR to STREAM."
  (SEND (DECODE-PRINT-ARG STREAM) ':TYO (IF (CHARACTERP CHAR) (%POINTER CHAR) CHAR))
  CHAR)

(DEFUN WRITE-CHAR (CHAR &OPTIONAL (STREAM *STANDARD-OUTPUT*))
  "Output CHAR to STREAM.  Returns CHAR."
  (SEND (DECODE-PRINT-ARG STREAM) ':TYO (IF (CHARACTERP CHAR) (%POINTER CHAR) CHAR))
  CHAR)  

(DEFUN WRITE-BYTE (BYTE &OPTIONAL (STREAM *STANDARD-OUTPUT*))
  "Output BYTE to STREAM.  Returns BYTE."
  (SEND (DECODE-PRINT-ARG STREAM) ':TYO BYTE)
  BYTE)  

(DEFUN WRITE-STRING (STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*)
		     &KEY &OPTIONAL (START 0) END)
  "Output all or part of STRING to STREAM.
START and END are indices specifying the part.
START defaults to 0 and END to NIL (which means the end of STRING.)"
  (SEND (DECODE-PRINT-ARG STREAM) ':STRING-OUT STRING START END)
  STRING)

(DEFUN WRITE-LINE (STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*)
		   &KEY &OPTIONAL (START 0) END)
  "Output all or part of STRING to STREAM, followed by a Return.
START and END are indices specifying the part.
START defaults to 0 and END to NIL (which means the end of STRING.)"
  (SETQ STREAM (DECODE-PRINT-ARG STREAM))
  (SEND STREAM ':STRING-OUT STRING START END)
  (SEND STREAM ':TYO #/RETURN)
  STRING)

(DEFUN FORCE-OUTPUT (&OPTIONAL STREAM)
  "Force output buffers on STREAM to begin being transmitted immediately.
Useful on asynchronous streams such as the chaosnet, which normally
wait until a buffer is full before even starting to transmit."
  (SEND (DECODE-PRINT-ARG STREAM) ':FORCE-OUTPUT)
  NIL)

(DEFUN FINISH-OUTPUT (&OPTIONAL STREAM)
  "Wait until output buffers on STREAM are transmitted and processed completely.
For a file stream, this will not return until the data is recorded permanently
in the file system."
  (SEND (DECODE-PRINT-ARG STREAM) ':FINISH)
  NIL)

(DEFUN CLEAR-OUTPUT (&OPTIONAL STREAM)
  "Discard buffer output buffers on STREAM, if it is an interactive stream.
The discarded output will never appear where it was going.
For noninteractive streams, this usually does nothing."
  (SEND (DECODE-PRINT-ARG STREAM) ':CLEAR-OUTPUT)
  NIL)

;;; Common Lisp low level input functions

(DEFUN READ-CHAR (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERRORP T) EOF-VALUE RECURSIVE-P)
  "Read one character from STREAM, and return it as a character object.
If EOF-ERRORP is T (the default), EOF is an error.
Otherwise, at EOF we return EOF-VALUE.
RECURSIVE-P is not used; it is a confusion in Common Lisp."
  RECURSIVE-P
  (LET ((VALUE (SEND (decode-read-arg stream) ':TYI EOF-ERRORP)))
    (IF (NULL VALUE) EOF-VALUE
      (%MAKE-POINTER DTP-CHARACTER VALUE))))

(DEFUN UNREAD-CHAR (CHAR &OPTIONAL (STREAM *STANDARD-INPUT*))
  "Put CHAR back in STREAM to be read out again as the next input character.
CHAR must be the same character last read from STREAM,
or this may not work or might even signal an error."
  (SEND (decode-read-arg stream) ':UNTYI (+ 0 CHAR)))			;coerces to fixnum

(DEFUN READ-BYTE (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERRORP T) EOF-VALUE)
  "Read one byte from STREAM, and return it.
If EOF-ERRORP is T (the default), EOF is an error.
Otherwise, at EOF we return EOF-VALUE."
  (OR (SEND (decode-read-arg stream) ':TYI EOF-ERRORP)
      EOF-VALUE))

(DEFUN PEEK-CHAR (&OPTIONAL PEEK-TYPE (STREAM *STANDARD-INPUT*) (EOF-ERRORP T) EOF-VALUE
		  RECURSIVE-P)
  "Peek ahead at input from STREAM without discarding it.
The character peeked at is returned as a character object.
If PEEK-TYPE is NIL, peek at the next input character on STREAM,
 but leave it in the input stream so the next input will reread it.
If PEEK-TYPE is T, discard all whitespace chars and peek at first non-whitespace.
 The current readtable says what is whitespace.
Otherwise, discard all chars before the first one that is equal to PEEK-TYPE,
 which should be a number or a character.
EOF-ERRORP and EOF-VALUE are as for READ-CHAR."
  RECURSIVE-P
  (SETQ STREAM (decode-read-arg stream))
  (COND ((NULL PEEK-TYPE)
	 (LET ((VALUE (SEND STREAM ':TYI)))
	   (IF (NULL VALUE)
	       (IF EOF-ERRORP
		   (FERROR 'SYS:END-OF-FILE-1 "End of file encountered on stream ~S." STREAM)
		 EOF-VALUE)
	     (SEND STREAM ':UNTYI VALUE)
	     (%MAKE-POINTER DTP-CHARACTER VALUE))))
	(T
	 (DO ((WHITESPACE-CODE
		(CDR (GET (LOCF (RDTBL-PLIST READTABLE)) 'WHITESPACE))))
	     (())
	   (LET ((VALUE (SEND STREAM ':TYI)))
	     (IF (NULL VALUE)
		 (IF EOF-ERRORP
		     (FERROR 'SYS:END-OF-FILE-1 "End of file encountered on stream ~S." STREAM)
		   (RETURN EOF-VALUE))
	       (WHEN (COND ((EQ PEEK-TYPE T)
			    (OR ( (LDB %%CH-CHAR VALUE) VALUE)
				( (RDTBL-CODE READTABLE VALUE)
				   WHITESPACE-CODE)))
			   (T
			    (= PEEK-TYPE VALUE)))
		 (SEND STREAM ':UNTYI VALUE)
		 (RETURN (%MAKE-POINTER DTP-CHARACTER VALUE)))))))))

(DEFUN LISTEN (&OPTIONAL (STREAM *STANDARD-INPUT*))
  "T if input is available on STREAM.
On a noninteractive stream, this is T if not at EOF."
  (SEND (decode-read-arg stream) ':LISTEN))

(DEFUN CLEAR-INPUT (&OPTIONAL (STREAM *STANDARD-INPUT*))
  "Discard any buffered input on STREAM, if it is an interactive stream."
  (SEND (decode-read-arg stream) ':CLEAR-INPUT)
  NIL)

(DEFUN READ-CHAR-NO-HANG (&OPTIONAL (STREAM *STANDARD-INPUT*)
			  (EOF-ERRORP T) EOF-VALUE RECURSIVE-P)
  "Read one character from STREAM, and return it as a character object, but don't wait.
On an interactive stream, if no input is currently buffered, NIL is returned.
If EOF-ERRORP is T (the default), EOF is an error.
Otherwise, at EOF we return EOF-VALUE.
RECURSIVE-P is not used; it is a confusion in Common Lisp."
  RECURSIVE-P
  (CONDITION-CASE-IF (NOT EOF-ERRORP) ()
      (LET ((VALUE (SEND (decode-read-arg stream) ':TYI-NO-HANG T)))
	(IF (NULL VALUE) NIL
	  (%MAKE-POINTER DTP-CHARACTER VALUE)))
    (END-OF-FILE
     EOF-VALUE)))

;;; Old-fashioned low level input functions.

;This function is compatible with the regular Maclisp TYI.  If you want speed,
;FUNCALL the stream directly.  We have to echo, but cannot use the rubout handler
;because the user wants to see rubout, form, etc. characters.  Inside the rubout
;handler, we do not echo since echoing will have occurred already.
(DEFUN TYI (&REST READ-ARGS &AUX CH)
  "Read one character from a stream.  Args are a stream and an eof-option.
The order is irrelevant; an arg which is not a reasonable stream
is taken to be the eof-option, which is returned if end of file is reached.
If there is no eof-option, end of file is an error.
If the stream supports rubout handling but we are not inside the rubout handler,
then the character read is echoed."
  (DECLARE (ARGLIST STREAM EOF-OPTION))
  (MULTIPLE-VALUE-BIND (STREAM EOF-OPTION)
      (DECODE-READ-ARGS READ-ARGS)
    (COND ((NULL (SETQ CH (SEND STREAM ':TYI)))	;Get a character, check for EOF
	   (IF (EQ EOF-OPTION 'NO-EOF-OPTION)
	       (FERROR 'SYS:END-OF-FILE-1 "End of file encountered on stream ~S." STREAM)
	       EOF-OPTION))
	  ((OR RUBOUT-HANDLER			; If inside rubout handler, or
	       (NOT (MEMQ ':RUBOUT-HANDLER (SEND STREAM ':WHICH-OPERATIONS))))
	   CH)					;  ordinary device, just return char
	  (T 
	   ;; Echo anything but blips and rubout, even control and meta charcters.
	   (IF (AND (FIXP CH)
		    ( CH #/RUBOUT))
	       (FORMAT STREAM "~C" CH))
	   CH))))

(DEFUN READCH (&REST READ-ARGS &AUX CH)
  "Read one character from a stream, and return a symbol with that pname.
Otherwise the same as TYI.  This is an obsolete Maclisp function."
  (DECLARE (ARGLIST STREAM EOF-OPTION))
  (MULTIPLE-VALUE-BIND (STREAM EOF-OPTION)
      (DECODE-READ-ARGS READ-ARGS)
    (IF (EQ 'READCH-EOF-OPTION (SETQ CH (TYI STREAM 'READCH-EOF-OPTION)))
	(IF (EQ EOF-OPTION 'NO-EOF-OPTION)
	    (FERROR 'SYS:END-OF-FILE-1 "End of file encountered on stream ~S." STREAM)
	    EOF-OPTION)
	(INTERN (STRING CH))))) ;Character objects are in current package.

;This function is compatible, more or less, with the regular Maclisp TYIPEEK.
;It does not echo, since the echoing will occur when READ or TYI is called.
;It does echo characters which it discards.
(DEFUN TYIPEEK (&OPTIONAL PEEK-TYPE &REST READ-ARGS)
  (DECLARE (ARGLIST PEEK-TYPE STREAM EOF-OPTION))
  (MULTIPLE-VALUE-BIND (STREAM EOF-OPTION)
      (DECODE-READ-ARGS READ-ARGS)
    (AND (NUMBERP PEEK-TYPE) (>= PEEK-TYPE 1000)
	 (FERROR NIL "The ~S flavor of TYIPEEK is not implemented." PEEK-TYPE))
    (DO ((CH))	      ;Pass over characters until termination condition reached
	(())
      (OR (SETQ CH (SEND STREAM ':TYI))
	  (IF (EQ EOF-OPTION 'NO-EOF-OPTION)
	      (FERROR 'SYS:END-OF-FILE-1 "End of file encountered on stream ~S." STREAM)
	      (RETURN EOF-OPTION)))
      (SEND STREAM ':UNTYI CH)			;Put it back
      (AND (COND ((NULL PEEK-TYPE))		;Break on every
		 ((EQ CH PEEK-TYPE))		;Break on specified character
		 ((EQ PEEK-TYPE T)		;Break on start-of-object
		  (AND (< CH RDTBL-ARRAY-SIZE)
		       (ZEROP (LOGAND (RDTBL-BITS READTABLE CH) 1)))))
	   (RETURN CH))				;Break here
      (TYI STREAM))))				;Echo and eat this character

(DEFUN STREAM-COPY-UNTIL-EOF (FROM-STREAM TO-STREAM &OPTIONAL (LEADER-SIZE NIL))
  "Copy data from FROM-STREAM to TO-STREAM, until EOF on FROM-STREAM.
The default is to use the most efficient mode, but the third argument
may be used to force use of :LINE-IN//:LINE-OUT mode, especially useful
when the to-stream is an editor interval stream.  If you use this to
copy binary files, note that you had better open the streams with
appropriate host-dependent byte sizes, and that if the from-stream
supports :LINE-IN but not :READ-INPUT-BUFFER you will probably lose."
  (LET ((FWO (SEND FROM-STREAM ':WHICH-OPERATIONS))
	(TWO (SEND TO-STREAM ':WHICH-OPERATIONS)))
    (COND ((AND (NOT LEADER-SIZE)
		(MEMQ ':READ-INPUT-BUFFER FWO)
		(MEMQ ':STRING-OUT TWO))
	   ;; If it can go, this mode is the most efficient by far.
	   (DO ((BUF) (OFFSET) (LIMIT))
	       (())
	     (MULTIPLE-VALUE (BUF OFFSET LIMIT)
	       (SEND FROM-STREAM ':READ-INPUT-BUFFER))
	     (COND ((NULL BUF) (RETURN NIL)))
	     (SEND TO-STREAM ':STRING-OUT BUF OFFSET LIMIT)
	     (SEND FROM-STREAM ':ADVANCE-INPUT-BUFFER)))
	  ((AND (MEMQ ':LINE-IN FWO)
                (MEMQ ':LINE-OUT TWO))
	   ;; Not as good, but better than :TYI/:TYO
           (DO ((LINE) (EOF))
	       (())
	     (MULTIPLE-VALUE (LINE EOF)
	       (SEND FROM-STREAM ':LINE-IN LEADER-SIZE))
	     (COND ((NOT EOF)
		    (SEND TO-STREAM ':LINE-OUT LINE))
		   (T (SEND TO-STREAM ':STRING-OUT LINE)
		      (RETURN NIL)))))
	  ;; This always wins, but is incredibly slow.
	  (T (DO ((CHAR))
		 ((NULL (SETQ CHAR (SEND FROM-STREAM ':TYI))))
	       (SEND TO-STREAM ':TYO CHAR))))))


(DEFF MAKE-SYN-STREAM 'MAKE-SYNONYM-STREAM)
(DEFUN MAKE-SYNONYM-STREAM (STREAM-SYMBOL)
  "Return an I//O stream which passes all operations to the value of STREAM-SYMBOL.
This is most often used with STREAM-SYMBOL equal to '*TERMINAL-IO*.
STREAM-SYMBOL can be a locative instead of a symbol."
  (IF (SYMBOLP STREAM-SYMBOL)
      ;; Changed 10/16/83 to make an uninterned symbol
      ;; but record it on STREAM-SYMBOL's plist so only one symbol needs to be made.
      (OR (GET STREAM-SYMBOL 'SYN-STREAM)
	  (LET ((SYM (MAKE-SYMBOL (STRING-APPEND STREAM-SYMBOL "-SYN-STREAM"))))
	    (%P-STORE-TAG-AND-POINTER (LOCF (FSYMEVAL SYM))
				      DTP-EXTERNAL-VALUE-CELL-POINTER
				      (LOCF (SYMEVAL STREAM-SYMBOL)))
	    (PUTPROP SYM T 'IO-STREAM-P)
	    (PUTPROP STREAM-SYMBOL SYM 'SYN-STREAM)
	    SYM))
    (LET ((SYM (MAKE-SYMBOL "SYN-STREAM")))
      (%P-STORE-TAG-AND-POINTER (LOCF (FSYMEVAL SYM))
				DTP-EXTERNAL-VALUE-CELL-POINTER
				STREAM-SYMBOL)
      (PUTPROP SYM T 'IO-STREAM-P)
      SYM)))

(DEFUN FOLLOW-SYN-STREAM (STREAM)
  "If STREAM is a synonym stream symbol, return the stream it is currently a synonym for.
Otherwise return STREAM."
  (COND ((NOT (SYMBOLP STREAM)) STREAM)
	((NEQ (LOCF (FSYMEVAL STREAM))
	      (FOLLOW-CELL-FORWARDING (LOCF (FSYMEVAL STREAM)) T))
	 (FSYMEVAL STREAM))
	(T STREAM)))

(DEFUN MAKE-BROADCAST-STREAM (&REST STREAMS)
  "Return an I//O stream which passes all operations to all of the STREAMS.
Thus, output directed to the broadcast stream will go to multiple places."
  (IF (NULL STREAMS) 'NULL-STREAM
    (LET-CLOSED ((BROADCAST-STREAM-STREAMS (COPYLIST STREAMS))
		 (WHICH-OPERATIONS (LOOP WITH WO = (SEND (CAR STREAMS) ':WHICH-OPERATIONS)
					 WITH COPYP = T
					 FOR STREAM IN (CDR STREAMS)
					 DO (LOOP WITH WO2 = (SEND STREAM ':WHICH-OPERATIONS)
						  FOR OP IN WO
						  UNLESS (MEMQ OP WO2)
						    DO (IF COPYP (SETQ WO (COPYLIST WO)))
						       (SETQ COPYP NIL)
						       (SETQ WO (DELQ OP WO)))
					 FINALLY (RETURN WO))))
      (FUNCTION (LAMBDA (&REST ARGS)
		  (COND ((EQ (CAR ARGS) ':WHICH-OPERATIONS) WHICH-OPERATIONS)
			((EQ (CAR ARGS) ':OPERATION-HANDLED-P)
			 (MEMQ (CADR ARGS) WHICH-OPERATIONS))
			((EQ (CAR ARGS) ':SEND-IF-HANDLES)
			 (DO ((L BROADCAST-STREAM-STREAMS (CDR L)))
			     ((NULL (CDR L))	;Last one gets to return multiple values
			      (LEXPR-SEND (CAR L) ':SEND-IF-HANDLES ARGS))
			   (LEXPR-SEND (CAR L) ':SEND-IF-HANDLES ARGS)))
			(T
			 (DO ((L BROADCAST-STREAM-STREAMS (CDR L)))
			     ((NULL (CDR L))	;Last one gets to return multiple values
			      (APPLY (CAR L) ARGS))
			   (APPLY (CAR L) ARGS)))))))))

(DEFUN MAKE-CONCATENATED-STREAM (&REST STREAMS)
  "Return a stream which will read from each of the STREAMS, one by one.
Reading from the concatenated stream will first read data from the first STREAM.
When that reaches eof, it will then read data from the second STREAM,
and so on until all the STREAMS are exhausted.  Then the concatenated stream gets eof."
  (LET-CLOSED ((CONCATENATED-STREAM-STREAMS (COPYLIST STREAMS))
	       (WHICH-OPERATIONS (LOOP WITH WO = (SEND (CAR STREAMS) ':WHICH-OPERATIONS)
				       WITH COPYP = T
				       FOR STREAM IN (CDR STREAMS)
				       DO (LOOP WITH WO2 = (SEND STREAM ':WHICH-OPERATIONS)
						FOR OP IN WO
						UNLESS (MEMQ OP WO2)
						DO (IF COPYP (SETQ WO (COPYLIST WO)))
						(SETQ COPYP NIL)
						(SETQ WO (DELQ OP WO)))
				       FINALLY (RETURN WO)))
	       (CONCATENATED-STREAM-FUNCTION NIL))
    (SETQ CONCATENATED-STREAM-FUNCTION
	  #'(LAMBDA (OP &REST ARGS)
	      (PROG ()
		LOOP
		(RETURN
		  (SELECTQ OP
		    ((:TYI :TYI-NO-HANG :ANY-TYI-NO-HANG :ANY-TYI)
		     (IF (NULL CONCATENATED-STREAM-STREAMS)
			 (AND (CAR ARGS)
			      (FERROR 'SYS:END-OF-FILE-1 "End of file on ~S."
				      CONCATENATED-STREAM-FUNCTION))
		       (LET ((VALUE (SEND (CAR CONCATENATED-STREAM-STREAMS) ':TYI)))
			 (IF VALUE
			     VALUE
			   (POP CONCATENATED-STREAM-STREAMS)
			   (GO LOOP)))))
		    (:WHICH-OPERATIONS WHICH-OPERATIONS)
		    (:SEND-IF-HANDLES
		     (AND (MEMQ (CAR ARGS) WHICH-OPERATIONS)
			  (LEXPR-SEND CONCATENATED-STREAM-FUNCTION ARGS)))
		    (:OPERATION-HANDLED-P
		     (NOT (NULL (MEMQ (CAR ARGS) WHICH-OPERATIONS))))
		    (:UNTYI (SEND (CAR CONCATENATED-STREAM-STREAMS) ':UNTYI (CAR ARGS)))
		    (:DIRECTION ':INPUT)
		    (T (STREAM-DEFAULT-HANDLER CONCATENATED-STREAM-FUNCTION
					       OP (CAR ARGS) (CDR ARGS))))))))))

(DEFCONST TWO-WAY-INPUT-OPERATIONS
	  '(:TYI :TYI-NO-HANG :ANY-TYI-NO-HANG :ANY-TYI
	    :UNTYI :TYIPEEK :LISTEN :LINE-IN :STRING-IN
	    :GET-INPUT-BUFFER :ADVANCE-INPUT-BUFFER :READ-INPUT-BUFFER
	    :READ-UNTIL-EOF :CLEAR-INPUT))

(DEFUN MAKE-TWO-WAY-STREAM (INPUT-STREAM OUTPUT-STREAM)
  "Return a stream which does its input via INPUT-STREAM and its output via OUTPUT-STREAM.
This works by knowing about all the standard, ordinary input operations.
Use of unusual input operations, or operations that affect both input and output
/(such as random access) will not work."
  (LET-CLOSED ((TWO-WAY-INPUT-STREAM INPUT-STREAM)
	       (TWO-WAY-OUTPUT-STREAM OUTPUT-STREAM)
	       (WHICH-OPERATIONS
		 (UNION (INTERSECTION TWO-WAY-INPUT-OPERATIONS
				      (SEND INPUT-STREAM ':WHICH-OPERATIONS))
			(SUBSET-NOT #'(LAMBDA (ELT) (MEMQ ELT TWO-WAY-INPUT-OPERATIONS))
				    (SEND OUTPUT-STREAM ':WHICH-OPERATIONS))
			'(:SEND-IF-HANDLES :OPERATION-HANDLED-P)))
	       (TWO-WAY-STREAM-FUNCTION NIL))
    (SETQ TWO-WAY-STREAM-FUNCTION
	  #'(LAMBDA (OP &REST ARGS)
		(COND ((MEMQ OP TWO-WAY-INPUT-OPERATIONS)
		       (LEXPR-SEND TWO-WAY-INPUT-STREAM OP ARGS))
		      ((EQ OP ':WHICH-OPERATIONS) WHICH-OPERATIONS)
		      ((EQ OP ':SEND-IF-HANDLES)
		       (AND (MEMQ (CAR ARGS) WHICH-OPERATIONS)
			    (LEXPR-SEND TWO-WAY-STREAM-FUNCTION ARGS)))
		      ((EQ OP ':OPERATION-HANDLED-P)
		       (NOT (NULL (MEMQ (CAR ARGS) WHICH-OPERATIONS))))
		      (T
		       (LEXPR-SEND TWO-WAY-OUTPUT-STREAM OP ARGS)))))))

(DEFUN MAKE-ECHO-STREAM (INPUT-STREAM OUTPUT-STREAM)
  "Return a stream which does output via OUTPUT-STREAM, and input via INPUT-STREAM with echo.
All characters that this stream reads from INPUT-STREAM are also
echoed to OUTPUT-STREAM.
This works by knowing about all the standard, ordinary input operations.
Use of unusual input operations, or operations that affect both input and output
/(such as random access) will not work."
  (LET-CLOSED ((TWO-WAY-INPUT-STREAM INPUT-STREAM)
	       (TWO-WAY-OUTPUT-STREAM OUTPUT-STREAM)
	       (ECHO-STREAM-UNREAD-CHAR NIL)
	       (WHICH-OPERATIONS
		 (UNION '(:TYI :UNTYI)
			(SUBSET-NOT #'(LAMBDA (ELT) (MEMQ ELT TWO-WAY-INPUT-OPERATIONS))
				    (SEND OUTPUT-STREAM ':WHICH-OPERATIONS))
			'(:SEND-IF-HANDLES :OPERATION-HANDLED-P)))
	       (TWO-WAY-STREAM-FUNCTION NIL))
    (SETQ TWO-WAY-STREAM-FUNCTION
	  #'(LAMBDA (OP &REST ARGS)
		(COND ((EQ OP ':TYI)
		       (OR (PROG1 ECHO-STREAM-UNREAD-CHAR
				  (SETQ ECHO-STREAM-UNREAD-CHAR NIL))
			   (LET ((VALUE (SEND TWO-WAY-INPUT-STREAM ':TYI (CAR ARGS))))
			     (IF VALUE (SEND TWO-WAY-OUTPUT-STREAM ':TYO VALUE))
			     VALUE)))
		      ((EQ OP ':UNTYI)
		       (SETQ ECHO-STREAM-UNREAD-CHAR (CAR ARGS)))
		      ((MEMQ OP TWO-WAY-INPUT-OPERATIONS)
		       (STREAM-DEFAULT-HANDLER TWO-WAY-STREAM-FUNCTION OP
					       (CAR ARGS) (CDR ARGS)))
		      ((EQ OP ':WHICH-OPERATIONS) WHICH-OPERATIONS)
		      ((EQ OP ':SEND-IF-HANDLES)
		       (AND (MEMQ (CAR ARGS) WHICH-OPERATIONS)
			    (LEXPR-SEND TWO-WAY-STREAM-FUNCTION ARGS)))
		      ((EQ OP ':OPERATION-HANDLED-P)
		       (NOT (NULL (MEMQ (CAR ARGS) WHICH-OPERATIONS))))
		      (T
		       (LEXPR-SEND TWO-WAY-OUTPUT-STREAM OP ARGS)))))))

(DEFUN STREAM-DEFAULT-HANDLER (FCTN OP ARG1 ARGS &AUX TEM)
  "Subroutine which provides default definition of certain stream operations.
If a stream does not recognize an operation, it may call this function
to have the operation handled.  The stream should return whatever
this function returns to it.  OP should be the operation, FCTN should
be the stream which received the operation, and ARG1 and ARGS should be
the arguments that came with the operation."
  (SELECTQ OP
    ((:TYIPEEK :LISTEN)
     (COND ((SETQ TEM (SEND FCTN ':TYI NIL))
	    (SEND FCTN ':UNTYI TEM)
	    TEM)))
    ((:ANY-TYI :TYI-NO-HANG)
     (SEND FCTN ':TYI ARG1))
    (:ANY-TYI-NO-HANG
     (SEND FCTN ':ANY-TYI ARG1))
    ((:CLEAR-OUTPUT :CLEAR-INPUT :FORCE-OUTPUT :FINISH :CLOSE :EOF)
     NIL)
    (:FRESH-LINE
     (SEND FCTN ':TYO #/CR)
     T)
    ((:STRING-OUT :LINE-OUT)
     (SETQ TEM (STRING ARG1))
     (DO ((LEN (COND ((SECOND ARGS))
		     (T (STRING-LENGTH TEM))))
	  (I (COND ((FIRST ARGS)) (T 0))
	     (1+ I)))
	 ((>= I LEN) NIL)
       (SEND FCTN ':TYO (AREF TEM I)))
     (AND (EQ OP ':LINE-OUT)
	  (SEND FCTN ':TYO #/CR)))
    (:LINE-IN
     (LET ((BUF (MAKE-ARRAY 100 ':TYPE ART-STRING
			    	':LEADER-LENGTH (IF (NUMBERP ARG1) ARG1 1))))
       (SETF (FILL-POINTER BUFF) 0)
       (VALUES BUF
	       (DO ((TEM (SEND FCTN ':TYI NIL) (SEND FCTN ':TYI NIL)))
		   ((OR (NULL TEM) (= TEM #/CR) (= TEM #/END))
		    (ADJUST-ARRAY-SIZE BUF (ARRAY-ACTIVE-LENGTH BUF))
		    (NULL TEM))
		 (ARRAY-PUSH-EXTEND BUF TEM)))))
    (:STRING-IN
     ;; ARG1 = EOF, (CAR ARGS) = STRING
     (LOOP WITH START = (OR (CADR ARGS) 0)
	   AND END = (OR (CADDR ARGS) (ARRAY-LENGTH (CAR ARGS)))
	   WHILE (< START END)
	   AS CH = (SEND FCTN ':TYI)
	   WHILE CH
	   DO (ASET CH (CAR ARGS) (PROG1 START (INCF START)))
	   FINALLY (AND (ARRAY-HAS-LEADER-P (CAR ARGS))
			(STORE-ARRAY-LEADER START (CAR ARGS) 0))
		   (AND (NULL CH) ARG1 (FERROR 'END-OF-FILE-1 "End of file on ~S." FCTN))
		   (RETURN (VALUES START (NULL CH)))))
    (:STRING-LINE-IN
     ;; ARG1 = EOF, (CAR ARGS) = STRING
     (LOOP WITH START = (OR (CADR ARGS) 0)
	   AND END = (OR (CADDR ARGS) (ARRAY-LENGTH (CAR ARGS)))
	   WHILE (< START END)
	   AS CH = (SEND FCTN ':TYI)
	   WHILE (AND CH (NEQ CH #/RETURN))
	   DO (ASET CH (CAR ARGS) (PROG1 START (INCF START)))
	   FINALLY (AND (ARRAY-HAS-LEADER-P (CAR ARGS))
			(STORE-ARRAY-LEADER START (CAR ARGS) 0))
		   (AND (NULL CH) ARG1 (FERROR 'END-OF-FILE-1 "End of file on ~S." FCTN))
		   (RETURN (VALUES START (NULL CH) (NEQ CH #/RETURN)))))
    (:OPERATION-HANDLED-P (MEMQ ARG1 (SEND FCTN ':WHICH-OPERATIONS)))
    (:CHARACTERS T)
    (:ELEMENT-TYPE
     (IF (SEND FCTN ':CHARACTERS) 'CHARACTER
       (LET ((VALUE (SEND FCTN ':SEND-IF-HANDLES ':BYTE-SIZE)))
	 (IF VALUE `(UNSIGNED-BYTE ,VALUE) 'FIXNUM))))
    (:DIRECTION
     (LET ((OPS (SEND FCTN ':WHICH-OPERATIONS)))
       (IF (MEMQ ':TYI OPS)
	   (IF (MEMQ ':TYO OPS) ':BIDIRECTIONAL ':INPUT)
	 (IF (MEMQ ':TYO OPS) ':OUTPUT NIL))))
    (:SEND-IF-HANDLES
     (IF (MEMQ ARG1 (SEND FCTN ':WHICH-OPERATIONS))
	 (LEXPR-SEND FCTN ARG1 ARGS)))
    (OTHERWISE
     (FERROR ':UNCLAIMED-MESSAGE "The stream operation ~S is not supported by ~S"
	     OP FCTN))))

(DEFMACRO SELECTQ-WITH-WHICH-OPERATIONS (THING &BODY CLAUSES)
  "Like SELECTQ, but automatically recognizes :WHICH-OPERATIONS.
:WHICH-OPERATIONS is handled by returning a list of all the
keywords which are tested for in the clauses."
  (LET (OTHERWISE)
    (COND ((STRING-EQUAL (CAAR (LAST CLAUSES)) 'OTHERWISE)
	   (SETQ OTHERWISE (LAST CLAUSES)
		 CLAUSES (BUTLAST CLAUSES))))
    `(SELECTQ ,THING
       ,@CLAUSES
       (:WHICH-OPERATIONS ',(LOOP FOR CLAUSE IN CLAUSES
				  APPENDING (IF (LISTP (CAR CLAUSE))
						(CAR CLAUSE)
					      (LIST (CAR CLAUSE)))))
       . ,OTHERWISE)))

(DEFPROP NULL-STREAM T IO-STREAM-P)
(DEFUN NULL-STREAM (OP &REST ARGS &AUX TEM)
  "An I//O stream which ignores output and gives instant end-of-file on input."
  (SELECTQ-WITH-WHICH-OPERATIONS OP
    ;; These operations signal EOF.
    ((:TYI :TYI-NO-HANG :TYIPEEK :GET-INPUT-BUFFER :READ-INPUT-BUFFER
	   :ANY-TYI :ANY-TYI-NO-HANG)
     (AND (FIRST ARGS) (FERROR 'READ-END-OF-FILE "End of file on SI:NULL-STREAM.")))
    ;; Signals EOF differently.
    (:STRING-IN
     (AND (FIRST ARGS) (FERROR 'READ-END-OF-FILE "End of file on SI:NULL-STREAM."))
     (VALUES (THIRD ARGS) T))
    ;; Signals EOF still differently.
    (:LINE-IN
      (SETQ TEM (MAKE-ARRAY 0 ':TYPE 'ART-STRING
			      ':LEADER-LENGTH (AND (NUMBERP (FIRST ARGS)) (FIRST ARGS))))
      (AND (NUMBERP (FIRST ARGS))
	   (PLUSP (FIRST ARGS))
	   (SETF (FILL-POINTER TEM) 0))
      (VALUES TEM T))
    ;; These operations should all return their argument.
    ((:TYO :STRING-OUT :LINE-OUT :UNTYI)
     (FIRST ARGS))
    ((:INCREMENT-CURSORPOS :FINISH :FORCE-OUTPUT :CLEAR-OUTPUT :CLEAR-INPUT :LISTEN)
     NIL)
    ;; These operations should always return T.
    ((:CHARACTERS :BEEP :FRESH-LINE) T)
    ;; Supports nothing in both directions.
    (:DIRECTION ':BIDIRECTIONAL)
    ;; Handle obscure operations.
    (OTHERWISE (STREAM-DEFAULT-HANDLER 'NULL-STREAM OP (FIRST ARGS) (REST1 ARGS)))))

(DEFVAR *IOLST :UNBOUND "String or list of data to read, in READLIST or READ-FROM-STRING.")

(DEFVAR *IOCH :UNBOUND "Character position in *IOLST, in READ-FROM-STRING.")

(DEFVAR *IOEND :UNBOUND "Character position to stop at, in READ-FROM-STRING.")

(DEFUN READLIST (CHARLIST &AUX (*IOCH NIL) (*IOLST CHARLIST))
  "Read an expression from the list of characters CHARLIST."
  (READ 'READLIST-STREAM))

(DEFPROP READLIST-STREAM T IO-STREAM-P)

(DEFUN READLIST-STREAM (OPERATION &OPTIONAL ARG1 &REST REST)
  (COND ((OR (EQ OPERATION ':ANY-TYI)
	     (MEMQ OPERATION '(:TYI :TYI-NO-HANG :ANY-TYI-NO-HANG)))
	 (COND ((EQ *IOCH T)
		(FERROR NIL "EOF in middle of READLIST"))
	       ((NOT (NULL *IOCH))
		(PROG2 NIL *IOCH (SETQ *IOCH NIL)))
	       ((NULL *IOLST)
		(SETQ *IOCH T)
		40)
	       (T (PROG1 (CHARACTER (CAR *IOLST))
			 (SETQ *IOLST (CDR *IOLST))))))
	((EQ OPERATION ':UNTYI)
	 (SETQ *IOCH ARG1))
	((EQ OPERATION ':WHICH-OPERATIONS)
	 '(:TYI :UNTYI))
	(T (STREAM-DEFAULT-HANDLER 'READLIST-STREAM OPERATION ARG1 REST))))

(DEFUN CLI:READ-FROM-STRING (STRING &OPTIONAL (EOF-ERRORP T) EOF-VALUE
			     &KEY &OPTIONAL (START 0) END PRESERVE-WHITESPACE)
  "Read an expression out of the characters in STRING.
START and END are indices which specify a substring of STRING to be used.
 START defaults to 0 and END to NIL (which means the end of STRING).
Reaching the end of STRING or the specified substring constitutes EOF.
EOF-ERRORP and EOF-VALUE are passed to the READ function,
 and PRESERVE-WHITESPACE non-NIL causes READ-PRESERVING-WHITESPACE to be used.
Only one object is read.  The first value is that object (or perhaps
 EOF-VALUE) and the second value is the index in STRING at which reading stopped."
  (DECLARE (RETURN-LIST CONTENTS END-CHAR-POSITION))
  (LET ((*IOLST STRING) (*IOCH START) (*IOEND (OR END (STRING-LENGTH STRING))))
    (VALUES (INTERNAL-READ 'READ-FROM-STRING-STREAM EOF-ERRORP EOF-VALUE
			   NIL PRESERVE-WHITESPACE)
	    *IOCH)))

(DEFUN READ-FROM-STRING (STRING &OPTIONAL (EOF-OPTION 'NO-EOF-OPTION)
			 (START 0)
			 END
			 &AUX (*IOLST STRING) (*IOCH START)
			 (*IOEND (OR END (STRING-LENGTH STRING))))
  "Read an expression out of the characters in STRING.
If EOF-OPTION is non-NIL, it is returned on end of file;
otherwise, end of file is an error.  START (default 0)
is the position in STRING to start reading at; END is where to stop.

The second value is the index in the string at which reading stopped.
It stops after the first object, even if not all the input is used."
  (DECLARE (RETURN-LIST CONTENTS END-CHAR-POSITION))
  (VALUES (READ 'READ-FROM-STRING-STREAM EOF-OPTION) *IOCH))

(DEFPROP READ-FROM-STRING-STREAM T IO-STREAM-P)

(DEFUN MAKE-STRING-INPUT-STREAM (STRING &OPTIONAL (START 0) END)
  "Return a stream from which one can read the characters of STRING, or some substring of it.
START and END are indices specifying a substring of STRING;
they default to 0 and NIL (NIL for END means the end of STRING)."
  (SETQ STRING (STRING STRING))
  (LET-CLOSED ((*IOCH START)
	       (*IOEND (OR END (LENGTH STRING)))
	       (*IOLST STRING))
    'READ-FROM-STRING-STREAM))
    
(DEFUN READ-FROM-STRING-STREAM (OPERATION &OPTIONAL ARG1 &REST REST)
  (COND ((OR (EQ OPERATION ':TYI) (EQ OPERATION ':ANY-TYI))
	 (IF (= *IOCH *IOEND)
	     NIL
	   (PROG1 (AREF *IOLST *IOCH)
		  (INCF *IOCH))))
	((EQ OPERATION ':UNTYI)
	 (WHEN ARG1
	   (SETQ *IOCH (1- *IOCH))))
	((EQ OPERATION ':GET-STRING-INDEX)
	 *IOCH)
	((EQ OPERATION ':WHICH-OPERATIONS)
	 '(:TYI :UNTYI :GET-STRING-INDEX))
	(T (STREAM-DEFAULT-HANDLER 'READ-FROM-STRING-STREAM OPERATION ARG1 REST))))

(DEFUN FLATSIZE (X &AUX (*IOCH 0))
  "Return the number of characters it takes to print X with quoting."
  (PRIN1 X (FUNCTION FLATSIZE-STREAM))
  *IOCH)

(DEFUN FLATC (X &AUX (*IOCH 0))
  "Return the number of characters it takes to print X with no quoting."
  (PRINC X (FUNCTION FLATSIZE-STREAM))
  *IOCH)

(DEFPROP FLATSIZE-STREAM T IO-STREAM-P)

(DEFUN FLATSIZE-STREAM (OPERATION &OPTIONAL ARG1 &REST REST)
  (COND ((EQ OPERATION ':TYO)
	 (SETQ *IOCH (1+ *IOCH)))
	((EQ OPERATION ':WHICH-OPERATIONS)
	 '(:TYO))
	(T (STREAM-DEFAULT-HANDLER 'FLATSIZE-STREAM OPERATION ARG1 REST))))

(DEFUN READ-LINE (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) EOF-VALUE RECURSIVE-P
		  				      OPTIONS)
  "Read a line from STREAM and return it as a string.
The string does not include the final Newline character, and is empty if nothing was read.
The second value is T if the line was terminated by EOF.
EOF-ERROR-P says whether an error should be signalled if eof occurs at the start of
 the line. If it is NIL and eof occurs at the start of the line, we return EOF-VALUE and T
RECURSIVE-P is ignored.
If the stream supports the :RUBOUT-HANDLER operation, we use it.
OPTIONS is a list of rubout handler options, passed to WITH-INPUT-EDITING if it is used."
  (DECLARE (VALUES LINE EOF-FLAG))
  RECURSIVE-P
  (MULTIPLE-VALUE-BIND (STRING EOF-FLAG)
      (READ-DELIMITED-STRING '(#/RETURN #/END)
			     STREAM
			     EOF-ERROR-P
			     OPTIONS)
    (IF (AND EOF-FLAG (ZEROP (LENGTH STRING)))
	(VALUES EOF-VALUE T)
      (VALUES STRING EOF-FLAG))))

(DEFUN READLINE (&REST READ-ARGS)
  "Read a line from STREAM and return it as a string.
The string does not include a Return character, and is empty for a blank line.
If EOF-OPTION is non-NIL, it is returned on end of file at beginning of line;
 otherwise, end of file with no text first is an error.
End of file after reading some text is never an error.

If the stream supports the :RUBOUT-HANDLER operation, we use it.
OPTIONS is a list of rubout handler options, passed to WITH-INPUT-EDITING if it is used.

The second value is EOF-OPTION if we exit due to end of file.

The third value is the delimiter which ended the input, or NIL if
it ended due to EOF."
  (DECLARE (ARGLIST &OPTIONAL STREAM EOF-OPTION OPTIONS)
	   (VALUES STRING-OR-EOF-OPTION EOF-FLAG DELIMITER))
  (LET ((OPTIONS NIL))
    ;; This kludge is to let us take a third, optional argument.
    (COND ((> (LENGTH READ-ARGS) 2)
	   (SETQ OPTIONS (THIRD READ-ARGS))
	   (SETQ READ-ARGS (LIST (FIRST READ-ARGS) (SECOND READ-ARGS)))))
    (MULTIPLE-VALUE-BIND (STREAM EOF-OPTION)
	(DECODE-READ-ARGS READ-ARGS)
      (MULTIPLE-VALUE-BIND (STRING EOF TERMINATOR)
	  (READ-DELIMITED-STRING '(#/RETURN #/END) STREAM
				 (EQ EOF-OPTION 'NO-EOF-OPTION) OPTIONS)
	(VALUES STRING (IF EOF EOF-OPTION) TERMINATOR)))))

(DEFUN READLINE-TRIM (&REST READ-ARGS)
  "Read a line from STREAM and return it as a string, sans leading and trailing whitespace.
The string does not include a Return character, and is empty for a blank line.
If EOF-OPTION is non-NIL, it is returned on end of file at beginning of line;
 otherwise, end of file with no text first is an error.
End of file after reading some text is never an error.

If the stream supports the :RUBOUT-HANDLER operation, we use it.
OPTIONS is a list of rubout handler options, passed to WITH-INPUT-EDITING if it is used.

The second value is T if we exit due to end of file."
  (DECLARE (ARGLIST &OPTIONAL STREAM EOF-OPTION OPTIONS)
	   (VALUES STRING EOF))
  (MULTIPLE-VALUE-BIND (STRING EOF)
      (APPLY 'READLINE READ-ARGS)
    (VALUES
      (IF EOF
	  STRING
	(STRING-TRIM '(#/SPACE #/TAB) STRING))
      EOF)))

(DEFUN READLINE-OR-NIL (&REST READ-ARGS)
  "Read a line from STREAM and return it as a string, or return NIL if line is empty.
The string does not include a Return character.
If EOF-OPTION is non-NIL, it is returned on end of file at beginning of line;
 otherwise, end of file with no text first is an error.
End of file after reading some text is never an error.

If the stream supports the :RUBOUT-HANDLER operation, we use it.
OPTIONS is a list of rubout handler options, passed to WITH-INPUT-EDITING if it is used.

The second value is T if we exit due to end of file."
  (DECLARE (ARGLIST &OPTIONAL STREAM EOF-OPTION OPTIONS)
	   (VALUES STRING-OR-NIL EOF))
  (MULTIPLE-VALUE-BIND (STRING EOF)
      (APPLY 'READLINE READ-ARGS)
    (VALUES
      (IF EOF
	  STRING
	(SETQ STRING (STRING-TRIM '(#/SPACE #/TAB) STRING))
	(IF (EQUAL STRING "") NIL STRING))
      EOF)))

(DEFUN READ-DELIMITED-STRING (&OPTIONAL (DELIMITER #/END) (STREAM *STANDARD-INPUT*)
			      EOF RH-OPTIONS (BUFFER-SIZE 100.))
  "Reads input from STREAM until DELIMITER is found; returns a string.
Uses the rubout handler if STREAM supports that.
DELIMITER is either a character or a list of characters.
 (Characters may be fixnums or character objects).
Values are:
 The string of characters read, not including the delimiter
 T if input ended due to end of file
 The delimiter character read (as a fixnum), or NIL if ended at EOF.
EOF if non-NIL means get error on end of file before any input is got.
RH-OPTIONS are passed to WITH-INPUT-EDITING.
BUFFER-SIZE is the size to make the buffer string, initially."
  (DECLARE (VALUES STRING EOF-FLAG DELIMITER))
  (setq stream (decode-read-arg stream))
  (with-stack-list (activation ':activation
			       (if (consp delimiter) 'memq 'eq)
			       delimiter)
    (with-stack-list* (options activation rh-options)
      (with-input-editing (stream options)
	(DO ((BUFFER (MAKE-ARRAY BUFFER-SIZE ':TYPE ART-STRING ':FILL-POINTER 0)))
	    (())
	  (LET ((CH (SEND STREAM (IF RUBOUT-HANDLER ':ANY-TYI ':TYI)
			  (AND (ZEROP (LENGTH BUFFER)) EOF))))
	    (COND ((NULL CH)
		   (RETURN BUFFER T))
		  ((CONSP CH)
		   (WHEN (EQ (CAR CH) ':ACTIVATION)
		     (SEND STREAM ':TYO (CADR CH))
		     (RETURN BUFFER NIL (CADR CH))))
		  ((AND (NOT RUBOUT-HANDLER)
			(IF (CONSP DELIMITER) (MEMQ CH DELIMITER) (EQ CH DELIMITER)))
		   (RETURN BUFFER NIL CH))
		  (T
		   (VECTOR-PUSH-EXTEND CH BUFFER)))))))))

(DEFVAR PROMPT-AND-READ-FORMAT-STRING :UNBOUND
  "Within PROMPT-AND-READ, holds the FORMAT-STRING argument.")

(DEFVAR PROMPT-AND-READ-FORMAT-ARGS :UNBOUND
  "Within PROMPT-AND-READ, holds the FORMAT-ARGS arguments.")

(DEFUN PROMPT-AND-READ (OPTION FORMAT-STRING &REST FORMAT-ARGS)
  "Read an object from *QUERY-IO* according to OPTION,
     prompting using FORMAT-STRING and -ARGS.
OPTION says how to read the object and what its syntax is.  It can be:
 :READ -- use READ to read the object.
 :EVAL-READ -- read an s-expression and evaluate it.  Return the value.
 :EVAL-READ-OR-END -- Like :EVAL-READ, but user can also type just End,
   in which case we return NIL as first value and :END as second.
 (:EVAL-READ :DEFAULT <DEFAULT>) -- Like :EVAL-READ, but user can
   also type just Space to use the default.  Second value is :DEFAULT then.
 (:EVAL-READ-OR-END :DEFAULT <DEFAULT>) -- Analogous.
 :NUMBER -- read a number, terminated by Return or End.
 (:NUMBER :INPUT-RADIX <RADIX> :OR-NIL <BOOLEAN>) -- read using <RADIX> for IBASE,
   and if <BOOLEAN> is non-NIL it allows you to type just Return and returns NIL.
 :CHARACTER -- read one character and return it as a fixnum.
 :DATE -- read a date and return in universal time format.
 (:DATE :PAST-P <PAST-P> :NEVER-P <NEVER-P>) -- read a date.
   The value is in universal time format.
   If <NEVER-P> is non-NIL, /"never/" is accepted, meaning return NIL.
   If <PAST-P> is non-NIL, the date is required to be before the present.
 :STRING -- read a string, terminated by Return.
 :STRING-TRIM -- read a string, terminated by Return.
   Discard leading and trailing whitespace.
 :STRING-OR-NIL -- read a string, terminated by Return.
   Discard leading and trailing whitespace.  If string is empty, return NIL.
 :PATHNAME -- read a pathname and default it.
 (:PATHNAME :DEFAULTS <DEFAULTS-LIST> :VERSION <VERSION-DEFAULT>) --
   read a pathname and default it using the defaults list specified.
   <VERSION-DEFAULT> is passed as the fourth arg to FS:MERGE-PATHNAME-DEFAULTS.
 :PATHNAME-OR-NIL -- like :PATHNAME but if user types just End then NIL is returned.
 (:DELIMITED-STRING :DELIMITER <DELIM> :BUFFER-SIZE <SIZE>) --
   read a string terminated by <DELIM>, which should be a character or a list of them.
   <SIZE> specifies the size of string to allocate initially.
 :DELIMITED-STRING-OR-NIL -- like :DELIMITED-STRING but if user types
   an empty string then NIL is returned.
 (:FQUERY . FQUERY-OPTIONS) -- calls FQUERY with the options."
  (OR (LEXPR-SEND *QUERY-IO* ':SEND-IF-HANDLES ':PROMPT-AND-READ
		  OPTION FORMAT-STRING FORMAT-ARGS)
      (LET* ((OPTION-TYPE (IF (CONSP OPTION) (CAR OPTION) OPTION))
	     (FUNCTION (GET OPTION-TYPE 'PROMPT-AND-READ-FUNCTION))
	     (PROMPT-AND-READ-FORMAT-STRING FORMAT-STRING)
	     (PROMPT-AND-READ-FORMAT-ARGS FORMAT-ARGS))
	(COND ((GET OPTION-TYPE 'PROMPT-AND-READ-NO-RUBOUT-FUNCTION)
	       (FUNCALL (GET OPTION-TYPE 'PROMPT-AND-READ-NO-RUBOUT-FUNCTION)
			OPTION *QUERY-IO*))
	      ((NULL FUNCTION)
	       (FERROR NIL "~S is not a known PROMPT-AND-READ option keyword." OPTION-TYPE))
	      ((SEND *QUERY-IO* ':OPERATION-HANDLED-P ':RUBOUT-HANDLER)
	       (SEND *QUERY-IO* ':RUBOUT-HANDLER
		     (GET OPTION-TYPE 'PROMPT-AND-READ-RUBOUT-OPTIONS
			  '((:PROMPT PROMPT-AND-READ-PROMPT-FUNCTION)
			    (:ACTIVATION MEMQ (#/END #/RETURN))))
		     FUNCTION OPTION *QUERY-IO*))
	      (T
	       (FUNCALL FUNCTION OPTION *QUERY-IO*))))))

(DEFUN PROMPT-AND-READ-PROMPT-FUNCTION (STREAM IGNORE)
  (APPLY 'FORMAT STREAM PROMPT-AND-READ-FORMAT-STRING PROMPT-AND-READ-FORMAT-ARGS))

(DEFCONST EVAL-READ-PRINLEVEL 2)
(DEFCONST EVAL-READ-PRINLENGTH 4)

(DEFPROP :EVAL-READ EVAL-READ-PROMPT-AND-READ PROMPT-AND-READ-NO-RUBOUT-FUNCTION)
(DEFPROP :EVAL-SEXP EVAL-READ-PROMPT-AND-READ PROMPT-AND-READ-NO-RUBOUT-FUNCTION)
(DEFPROP :EVAL-FORM EVAL-READ-PROMPT-AND-READ PROMPT-AND-READ-NO-RUBOUT-FUNCTION)
(DEFUN EVAL-READ-PROMPT-AND-READ (OPTION STREAM)
  (DO (VALUE FORM FLAG)
      (())
    (ERROR-RESTART (ERROR "Try again to type this input.")
      (MULTIPLE-VALUE (FORM FLAG)
	(WITH-INPUT-EDITING (STREAM
			      '((:PROMPT PROMPT-AND-READ-PROMPT-FUNCTION)
				(:ACTIVATION = #/END)))
	  (LET ((CH (SEND STREAM ':TYI)))
	    (COND ((AND (CONSP OPTION) (GET-LOCATION-OR-NIL OPTION ':DEFAULT)
			(EQ CH #/SPACE))
		   (VALUES (GET OPTION ':DEFAULT) ':DEFAULT))
		  (T (SEND STREAM ':UNTYI CH)
		     (VALUES (READ STREAM)))))))
      (IF FLAG (RETURN FORM FLAG)
	(SETQ VALUE (EVAL-ABORT-TRIVIAL-ERRORS FORM))))
    ;; If FORM was not trivial, ask for confirmation of the value it returned.
    (WHEN (OR (TRIVIAL-FORM-P FORM)
	      (LET ((PRINLEVEL EVAL-READ-PRINLEVEL)
		    (PRINLENGTH EVAL-READ-PRINLENGTH))
		(FQUERY '(:LIST-CHOICES NIL) "The object is ~S, ok? " VALUE)))
      (RETURN VALUE))
    (TERPRI STREAM)))

(DEFUN TRIVIAL-FORM-P (FORM)
  "T if what FORM evaluates to is inherent in its appearance."
  (COND ((SYMBOLP FORM)
	 (OR (EQ FORM 'T) (NULL FORM)))
	((CONSP FORM) (EQ (CAR FORM) 'QUOTE))
	((NUMBERP FORM) T)
	((STRINGP FORM) T)))

(DEFPROP :EVAL-READ-OR-END EVAL-READ-OR-END-PROMPT-AND-READ
	 PROMPT-AND-READ-NO-RUBOUT-FUNCTION)
(DEFPROP :EVAL-SEXP-OR-END EVAL-READ-OR-END-PROMPT-AND-READ
	 PROMPT-AND-READ-NO-RUBOUT-FUNCTION)
(DEFPROP :EVAL-FORM-OR-END EVAL-READ-OR-END-PROMPT-AND-READ
	 PROMPT-AND-READ-NO-RUBOUT-FUNCTION)
(DEFUN EVAL-READ-OR-END-PROMPT-AND-READ (OPTION STREAM)
  (DO (VALUE FORM FLAG)
      (())
    (ERROR-RESTART (ERROR "Try again to type this input.")
      (MULTIPLE-VALUE (FORM FLAG)
	(WITH-INPUT-EDITING (STREAM
			      '((:PROMPT PROMPT-AND-READ-PROMPT-FUNCTION)
				(:ACTIVATION = #/END)))
	  (LET ((CH (SEND STREAM ':ANY-TYI)))
	    (COND ((AND (CONSP OPTION) (GET-LOCATION-OR-NIL OPTION ':DEFAULT)
			(EQ CH #/SPACE))
		   (VALUES (GET OPTION ':DEFAULT) ':DEFAULT))
		  ((AND (CONSP CH)
			(EQ (CAR CH) ':ACTIVATION))
		   (SEND STREAM ':TYO (CADR CH))
		   (VALUES NIL ':END))
		  ((EQ CH #/END) (VALUES NIL ':END))
		  (T (UNLESS (CONSP CH) (SEND STREAM ':UNTYI CH))
		     (VALUES (READ STREAM)))))))
      (IF FLAG (RETURN FORM FLAG)
	(SETQ VALUE (EVAL-ABORT-TRIVIAL-ERRORS FORM))))
    ;; If FORM was not trivial, ask for confirmation of the value it returned.
    (WHEN (OR (TRIVIAL-FORM-P FORM)
	      (LET ((PRINLEVEL EVAL-READ-PRINLEVEL)
		    (PRINLENGTH EVAL-READ-PRINLENGTH))
		(FQUERY '(:LIST-CHOICES NIL) "The object is ~S, ok? " VALUE)))
      (RETURN VALUE))
    (TERPRI STREAM)))

(DEFPROP :READ READ-PROMPT-AND-READ PROMPT-AND-READ-FUNCTION)
(DEFPROP :EXPRESSION READ-PROMPT-AND-READ PROMPT-AND-READ-FUNCTION)
(DEFUN READ-PROMPT-AND-READ (IGNORE STREAM)
  (VALUES (READ STREAM)))

(DEFPROP :READ ((:PROMPT PROMPT-AND-READ-PROMPT-FUNCTION)
		(:ACTIVATION = #/END))
	 PROMPT-AND-READ-RUBOUT-OPTIONS)

(DEFPROP :EXPRESSION ((:PROMPT PROMPT-AND-READ-PROMPT-FUNCTION)
		      (:ACTIVATION = #/END))
	 PROMPT-AND-READ-RUBOUT-OPTIONS)

(DEFPROP :EXPRESSION-OR-END EXPRESSION-OR-END-PROMPT-AND-READ PROMPT-AND-READ-FUNCTION)
(DEFPROP :EXPRESSION-OR-END ((:PROMPT PROMPT-AND-READ-PROMPT-FUNCTION)
			     (:ACTIVATION = #/END))
	 PROMPT-AND-READ-RUBOUT-OPTIONS)
(DEFUN EXPRESSION-OR-END-PROMPT-AND-READ (IGNORE STREAM)
  (LET ((CH (SEND STREAM ':ANY-TYI)))
    (IF (OR (AND (CONSP CH) (EQ (CAR CH) ':ACTIVATION))
	    (AND (NOT RUBOUT-HANDLER) (EQ CH #/END)))
	(PROGN
	  (IF (CONSP CH)
	      (SEND STREAM ':TYO (CADR CH)))
	  (VALUES NIL ':END))
      (WHEN (ATOM CH) (SEND STREAM ':UNTYI CH))
      (VALUES (READ STREAM)))))

(DEFUN (:CHARACTER PROMPT-AND-READ-NO-RUBOUT-FUNCTION) (OPTION STREAM)
  (PROMPT-AND-READ-PROMPT-FUNCTION STREAM NIL)
  (LET ((CHAR (SEND STREAM ':TYI))
	(*STANDARD-OUTPUT* STREAM))
    (IF (AND (CONSP OPTION) (GET OPTION ':OR-NIL)
	     (= CHAR #/CLEAR-INPUT))
	(PROGN (PRINC "none") NIL)
      (FORMAT:OCHAR CHAR ':EDITOR)
      CHAR)))

(DEFUN (:CHARACTER-LIST PROMPT-AND-READ-FUNCTION) (IGNORE STREAM)
  (CONCATENATE 'LIST (READLINE STREAM)))

(DEFUN (:NUMBER PROMPT-AND-READ-FUNCTION) (OPTION STREAM)
  (LET ((IBASE (OR (AND (CONSP OPTION) (GET OPTION ':INPUT-RADIX)) IBASE))
	(STRING (READLINE-TRIM STREAM)))
    (IF (AND (CONSP OPTION) (GET OPTION ':OR-NIL)
	     (EQUAL STRING ""))
	NIL
      (CONDITION-CASE ()
	  (LET* ((NUMBER (READ-FROM-STRING STRING)))
	    (IF (NUMBERP NUMBER) NUMBER
	      (FERROR 'READ-ERROR-1 "That is not a number.")))
	(END-OF-FILE (FERROR 'READ-ERROR-1 "That is not a number."))))))

(DEFUN (:INTEGER PROMPT-AND-READ-FUNCTION) (OPTION STREAM)
  (LET ((IBASE (OR (AND (CONSP OPTION) (GET OPTION ':INPUT-RADIX)) IBASE))
	(STRING (READLINE-TRIM STREAM)))
    (IF (AND (CONSP OPTION) (GET OPTION ':OR-NIL)
	     (EQUAL STRING ""))
	NIL
      (CONDITION-CASE ()
	  (LET* ((NUMBER (READ-FROM-STRING STRING)))
	    (IF (AND (NUMBERP NUMBER) (INTEGERP NUMBER)) NUMBER
	      (FERROR 'READ-ERROR-1 "That is not an integer.")))
	(END-OF-FILE (FERROR 'READ-ERROR-1 "That is not an integer."))))))

(DEFUN (:SMALL-FRACTION PROMPT-AND-READ-FUNCTION) (OPTION STREAM)
  (LET ((STRING (READLINE-TRIM STREAM)))
    (IF (AND (CONSP OPTION) (GET OPTION ':OR-NIL)
	     (EQUAL STRING ""))
	NIL
      (CONDITION-CASE ()
	  (LET* ((NUMBER (READ-FROM-STRING STRING)))
	    (IF (AND (NUMBERP NUMBER) (REALP NUMBER) ( 0.0 NUMBER 1.0))
		(FLOAT NUMBER)
	      (FERROR 'READ-ERROR-1 "That is not a fraction between 0 and 1.")))
	(END-OF-FILE (FERROR 'READ-ERROR-1 "That is not a fraction between 0 and 1."))))))

(DEFUN (:DATE PROMPT-AND-READ-FUNCTION) (OPTION STREAM)
  (LET ((STRING (READLINE-TRIM STREAM)))
    (IF (EQUALP STRING "never")
	(IF (AND (CONSP OPTION)
		 (GET OPTION ':NEVER-P))
	    NIL
	  (FERROR 'READ-ERROR-1 "Never is not allowed here."))
      (LET* ((PAST-P (AND (CONSP OPTION) (GET OPTION ':PAST-P)))
	     (DATE (CONDITION-CASE (ERROR)
		       (TIME:PARSE-UNIVERSAL-TIME STRING 0 NIL (NOT PAST-P))
		     (TIME:PARSE-ERROR
		      (FERROR 'READ-ERROR-1 "~A" (SEND ERROR ':REPORT-STRING))))))
	(AND PAST-P (> DATE (GET-UNIVERSAL-TIME))
	     (FERROR 'READ-ERROR-1 "~A is not in the past."
		     (TIME:PRINT-UNIVERSAL-TIME DATE NIL)))
	DATE))))

(DEFUN (:STRING-OR-NIL PROMPT-AND-READ-FUNCTION) (IGNORE STREAM)
  (READLINE-OR-NIL STREAM))

(DEFUN (:STRING PROMPT-AND-READ-FUNCTION) (IGNORE STREAM)
  (READLINE STREAM))

(DEFUN (:STRING-TRIM PROMPT-AND-READ-FUNCTION) (IGNORE STREAM)
  (READLINE-TRIM STREAM))

(DEFUN (:STRING-LIST PROMPT-AND-READ-FUNCTION) (IGNORE STREAM)
  (LET ((STR1 (READLINE STREAM))
	J ACCUM)
    (DO ((I 0))
	(())
      (SETQ J (STRING-SEARCH-CHAR #/, STR1 I))
      (LET ((STR2 (STRING-TRIM " " (SUBSTRING STR1 I J))))
	(UNLESS (EQUAL STR2 "")
	  (PUSH STR2 ACCUM)))
      (UNLESS J (RETURN (NREVERSE ACCUM)))
      (SETQ I (1+ J)))))

(DEFUN (:PATHNAME PROMPT-AND-READ-FUNCTION) (OPTION STREAM)
  (LET ((DEFAULTS (IF (CONSP OPTION) (GET OPTION ':DEFAULTS) *DEFAULT-PATHNAME-DEFAULTS*))
	(STRING (READLINE STREAM)))
    (FS:MERGE-PATHNAME-DEFAULTS STRING DEFAULTS
				FS:*NAME-SPECIFIED-DEFAULT-TYPE*
				(OR (AND (CONSP OPTION) (GET OPTION ':DEFAULT-VERSION))
				    ':NEWEST))))

(DEFUN (:PATHNAME-OR-END PROMPT-AND-READ-FUNCTION) (OPTION STREAM)
  (LET ((DEFAULTS (IF (CONSP OPTION) (GET OPTION ':DEFAULTS) *DEFAULT-PATHNAME-DEFAULTS*)))
    (MULTIPLE-VALUE-BIND (STRING NIL TERMINATOR)
	(READLINE STREAM)
      (IF (AND (EQUAL STRING "") (EQ TERMINATOR #/END))
	  #/END
	(FS:MERGE-PATHNAME-DEFAULTS STRING DEFAULTS
				    FS:*NAME-SPECIFIED-DEFAULT-TYPE*
				    (OR (AND (CONSP OPTION) (GET OPTION ':DEFAULT-VERSION))
					':NEWEST))))))

(DEFUN (:PATHNAME-OR-NIL PROMPT-AND-READ-FUNCTION) (OPTION STREAM)
  (LET ((DEFAULTS (IF (CONSP OPTION) (GET OPTION ':DEFAULTS) *DEFAULT-PATHNAME-DEFAULTS*)))
    (MULTIPLE-VALUE-BIND (STRING NIL TERMINATOR)
	(READLINE STREAM)
      (UNLESS (AND (EQUAL STRING "") (EQ TERMINATOR #/END))
	(FS:MERGE-PATHNAME-DEFAULTS STRING DEFAULTS
				    FS:*NAME-SPECIFIED-DEFAULT-TYPE*
				    (OR (AND (CONSP OPTION) (GET OPTION ':DEFAULT-VERSION))
					':NEWEST))))))

(DEFUN (:FQUERY PROMPT-AND-READ-NO-RUBOUT-FUNCTION) (OPTION *QUERY-IO*)
  (APPLY 'FQUERY (IF (LISTP OPTION) (CDR OPTION))
		 PROMPT-AND-READ-FORMAT-STRING PROMPT-AND-READ-FORMAT-ARGS))

;Obsolete.
(DEFUN (FQUERY PROMPT-AND-READ-NO-RUBOUT-FUNCTION) (OPTION *QUERY-IO*)
  (APPLY 'FQUERY (IF (LISTP OPTION) (CDR OPTION))
		 PROMPT-AND-READ-FORMAT-STRING PROMPT-AND-READ-FORMAT-ARGS))

(DEFUN (:DELIMITED-STRING PROMPT-AND-READ-NO-RUBOUT-FUNCTION) (OPTION STREAM)
  (READ-DELIMITED-STRING (OR (AND (CONSP OPTION) (GET OPTION ':DELIMITER)) #/END)
			 STREAM NIL '((:PROMPT PROMPT-AND-READ-PROMPT-FUNCTION))
			 (OR (AND (CONSP OPTION) (GET OPTION ':BUFFER-SIZE)) 100)))

(DEFUN (:DELIMITED-STRING-OR-NIL PROMPT-AND-READ-NO-RUBOUT-FUNCTION) (OPTION STREAM)
  (LET ((STRING
	  (READ-DELIMITED-STRING (OR (AND (CONSP OPTION) (GET OPTION ':DELIMITER)) #/END)
				 STREAM NIL '((:PROMPT PROMPT-AND-READ-PROMPT-FUNCTION))
				 (OR (AND (CONSP OPTION) (GET OPTION ':BUFFER-SIZE)) 100))))
    (IF (EQUAL STRING "") NIL STRING)))

(DEFUN (:CHOOSE PROMPT-AND-READ-NO-RUBOUT-FUNCTION) (OPTION *QUERY-IO*)
  (LET ((CHOICES (GET OPTION ':CHOICES)))
    (WITH-INPUT-EDITING (*QUERY-IO*
			  `((:PROMPT ,#'(LAMBDA (&REST ARGS)
					  (APPLY 'PROMPT-AND-READ-PROMPT-FUNCTION ARGS)
					  (FRESH-LINE QUERY-IO)
					  (DO ((CHOICES CHOICES (CDR CHOICES))
					       (I 0 (1+ I)))
					      ((NULL CHOICES))
					    (FORMAT *QUERY-IO* "~& Type ~D for ~S"
						    I (CAR CHOICES)))
					  (TERPRI *QUERY-IO*)))
			    (:ACTIVATION MEMQ (#/END #/RETURN))))
      (NTH (READ *QUERY-IO*)
	   CHOICES))))

(DEFUN (:ASSOC PROMPT-AND-READ-NO-RUBOUT-FUNCTION) (OPTION *QUERY-IO*)
  (LET ((CHOICES (GET OPTION ':CHOICES)))
    (WITH-INPUT-EDITING (*QUERY-IO*
			  `((:PROMPT ,#'(LAMBDA (&REST ARGS)
					  (APPLY 'PROMPT-AND-READ-PROMPT-FUNCTION ARGS)
					  (FRESH-LINE *QUERY-IO*)
					  (DO ((CHOICES CHOICES (CDR CHOICES))
					       (I 0 (1+ I)))
					      ((NULL CHOICES))
					    (FORMAT *QUERY-IO* "~& Type ~D for ~S"
						    I (CAAR CHOICES)))
					  (TERPRI *QUERY-IO*)))
			    (:ACTIVATION MEMQ (#/END #/RETURN))))
      (CDR (NTH (READ *QUERY-IO*)
		CHOICES)))))

(DEFUN (:BOOLEAN PROMPT-AND-READ-NO-RUBOUT-FUNCTION) (IGNORE *QUERY-IO*)
  (APPLY 'Y-OR-N-P PROMPT-AND-READ-FORMAT-STRING PROMPT-AND-READ-FORMAT-ARGS))


