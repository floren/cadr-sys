;-*- Mode:LISP; Package:FILE-SYSTEM; Base:8. -*-
;;;; ITS support
;;; An FN2 can be either a version, if it is all numbers, or a type otherwise.
(DEFFLAVOR ITS-PATHNAME-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME))

;; These messages are careful to cons only the actual string in PATHNAME-AREA.
;; See comment by PATHNAME-AREA.

(DEFMETHOD (ITS-PATHNAME-MIXIN :STRING-FOR-HOST) ()
  (LET ((DIR (STRING-OR-WILD DIRECTORY))
	(XDEV (ITS-DEVICE-STRING T))
	(FN1 (ITS-FN1-STRING))
	(FN2 (ITS-FN2-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A: ~A; ~A ~A"
	    XDEV DIR FN1 FN2)))

(DEFMETHOD (ITS-PATHNAME-MIXIN :STRING-FOR-PRINTING) ()
  (LET ((DEV (ITS-DEVICE-STRING))
	(DIR (STRING-OR-WILD DIRECTORY))
	(FN1 (ITS-FN1-STRING))
	(FN2 (ITS-FN2-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A: ~:[~A;~:[ ~]~;~2*~]~@[~A~]~@[ ~A~]"
	    DEV (MEMQ DIRECTORY '(NIL :UNSPECIFIC)) 
	    DIR (AND (MEMQ NAME '(NIL :UNSPECIFIC))
		     (MEMQ TYPE '(NIL :UNSPECIFIC))
		     (MEMQ VERSION '(NIL :UNSPECIFIC)))
	    FN1 FN2)))

(DEFMETHOD (ITS-PATHNAME-MIXIN :STRING-FOR-EDITOR) ()
  (LET ((FN1 (ITS-FN1-STRING))
	(FN2 (ITS-FN2-STRING))
	(DIR (STRING-OR-WILD DIRECTORY))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A ~:[~A ~;~*~]~:[~A: ~;~*~]~A; ~A:"
	    FN1
	    ;; Do we really have a significant type or version worth printing?
	    (NOT (OR (AND TYPE (NEQ TYPE ':UNSPECIFIC))
		     (AND VERSION (NEQ VERSION ':UNSPECIFIC))))
	    FN2
	    (OR (MEMBER DEVICE '("DSK" NIL :UNSPECIFIC))
		(EQUAL DEVICE (FUNCALL HOST ':NAME-AS-FILE-COMPUTER)))
	    DEVICE DIR
	    (FUNCALL HOST ':NAME-AS-FILE-COMPUTER))))

(DEFMETHOD (ITS-PATHNAME-MIXIN :STRING-FOR-DIRECTORY) ()
  (LET ((DIR (STRING-OR-WILD DIRECTORY))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~:[~A: ~;~*~]~A;"
	    (MEMBER DEVICE '("DSK" NIL :UNSPECIFIC))
	    DEVICE DIR)))

(DEFMETHOD (ITS-PATHNAME-MIXIN :STRING-FOR-DIRED) ()
  (LET ((FN1 (ITS-FN1-STRING T))
	(FN2 (ITS-FN2-STRING T))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~6A ~A" FN1 FN2)))

(DEFMETHOD (ITS-PATHNAME-MIXIN :FN1) ()
  (ITS-FN1-STRING T T))

(DEFMETHOD (ITS-PATHNAME-MIXIN :FN2) ()
  (ITS-FN2-STRING T T))

;;; If the device is DSK, avoid printing it.
(DEFUN ITS-DEVICE-STRING (&OPTIONAL OMIT-HOST &AUX HOSTS PRINT-HOSTS)
  (DECLARE (:SELF-FLAVOR ITS-PATHNAME-MIXIN))
  (SETQ HOSTS (FUNCALL HOST ':NAME-AS-FILE-COMPUTER))
  (SETQ PRINT-HOSTS (IF OMIT-HOST "DSK" HOSTS))
  (IF (OR (MEMBER DEVICE '("DSK" NIL :UNSPECIFIC))
	  (EQUAL DEVICE HOSTS))
      PRINT-HOSTS
      (STRING-APPEND PRINT-HOSTS ": " DEVICE)))

;;; If name is a list, its first component is the FN1 and second is FN2
;;; If only FN2 is present, FN1 is placeholder ""
(DEFUN ITS-FN1-STRING (&OPTIONAL NO-QUOTE-P NO-PLACEHOLDER)
  (DECLARE (:SELF-FLAVOR PATHNAME))
  (COND	((NULL NAME)
	 (IF NO-PLACEHOLDER
	     NIL ""))
	((EQ NAME ':UNSPECIFIC) NIL)  ;Should this ever happen?
	((LISTP NAME) (IF NO-QUOTE-P (CAR NAME)
			  (QUOTE-COMPONENT-STRING (CAR NAME))))
	(T (STRING-OR-WILD NAME NO-QUOTE-P))))

(DEFUN ITS-FN2-STRING (&OPTIONAL NO-QUOTE-P NO-PLACEHOLDER)
  (DECLARE (:SELF-FLAVOR ITS-PATHNAME-MIXIN))
  (COND ((AND (LISTP NAME) (CDR NAME))
	 (IF NO-QUOTE-P (CADR NAME) (QUOTE-COMPONENT-STRING (CADR NAME))))
	((AND (NULL TYPE) (NULL VERSION))
	 (IF NO-PLACEHOLDER NIL ""))
	((AND (MEMQ TYPE '(NIL :UNSPECIFIC))
	      (MEMQ VERSION '(NIL :UNSPECIFIC)))
	 NIL)
	((EQ VERSION ':OLDEST) "<")
	((EQ VERSION ':WILD) "*")
	((OR (EQ VERSION ':UNSPECIFIC) (NOT (MEMBER TYPE *ITS-UNINTERESTING-TYPES*)))
	 (STRING-OR-WILD TYPE NO-QUOTE-P))
	((NOT (MEMQ VERSION '(NIL :UNSPECIFIC :NEWEST))) (FORMAT NIL "~D" VERSION))
	(T ">")))

(DEFUN STRING-OR-WILD (FIELD &OPTIONAL NO-QUOTE-P SPECIALS REPLACED-BY)
  "Convert FIELD, a pathname component, to a string to appear in a printed representation.
NO-QUOTE-P inhibits insertion of quoting characters;
otherwise, quote characters are inserted and some characters translated:
SPECIALS is a list of characters to be translated,
and REPLACED-BY is an equally-long list of characters to translate them to."
  (COND ((EQ FIELD ':WILD) "*")
	(NO-QUOTE-P (STRING FIELD))
	((QUOTE-COMPONENT-STRING FIELD SPECIALS REPLACED-BY))))

(DEFUN QUOTE-COMPONENT-STRING (STRING &OPTIONAL SPECIALS REPLACED-BY &AUX LENGTH)
  "Put a quote character before each character of STRING that needs one.
Copies STRING if it has to be changed.  Any instance of a char in SPECIALS
is replaced by the corresponding char in REPLACED-BY, not quoted."
  (SETQ STRING (STRING STRING)
	LENGTH (STRING-LENGTH STRING))
  (DO ((NSTRING NIL)
       (QUOTE-IDX 0 NQUOTE-IDX)
       (NQUOTE-IDX -1))
      (NIL)
    (SETQ NQUOTE-IDX
	  (DO ((I (1+ NQUOTE-IDX) (1+ I)))
	      (( I LENGTH))
	    (AND (NOT (MEMQ (AREF STRING I) SPECIALS))
		 (FUNCALL-SELF ':CHARACTER-NEEDS-QUOTING-P (AREF STRING I))
		 (RETURN I))))
    (AND (OR NQUOTE-IDX NSTRING)
	 (SETQ NSTRING (IF NSTRING
			   (STRING-APPEND NSTRING
					  (FUNCALL-SELF ':QUOTE-CHARACTER)
					  (SUBSTRING STRING QUOTE-IDX NQUOTE-IDX))
			   (SUBSTRING STRING QUOTE-IDX NQUOTE-IDX))))
    (OR NQUOTE-IDX
	(PROGN
	  (DO-FOREVER
	    (LET ((I (STRING-SEARCH-SET SPECIALS (OR NSTRING STRING))))
	      (OR I (RETURN))
	      (OR NSTRING
		  (SETQ NSTRING (STRING-APPEND STRING)))
	      (SETF (AREF NSTRING I)
		    (NTH (FIND-POSITION-IN-LIST (AREF NSTRING I) SPECIALS) REPLACED-BY))))
	  (RETURN (OR NSTRING STRING))))))

(DEFMETHOD (ITS-PATHNAME-MIXIN :QUOTE-CHARACTER) () #/)

(DEFMETHOD (ITS-PATHNAME-MIXIN :CHARACTER-NEEDS-QUOTING-P) (CH)
  (MEMQ CH '(#/; #/: #\SP)))

(DEFVAR *ITS-UNINTERESTING-TYPES* '("LISP" "TEXT" NIL :UNSPECIFIC))

;; Differs from the default method in that if both type and version are specified
;; we clobber one of them to :UNSPECIFIC.
;; If only one is specified, we clobber the other to :UNSPECIFIC.
;; Exception: if either of them is :WILD, both of them are :WILD.
(DEFMETHOD (ITS-PATHNAME-MIXIN :NEW-PATHNAME)
	   (&REST OPTIONS
	    &KEY &OPTIONAL STARTING-PATHNAME
	    ((:VERSION -VERSION-) NIL VERSION-P)
	    &ALLOW-OTHER-KEYS
	    &AUX -TYPE- TYPE-P)
  (SETQ -TYPE- (CADR (GETL (LOCF OPTIONS) '(:TYPE :CANONICAL-TYPE))))
  (COND ((EQ -TYPE- ':WILD)
	 (SETQ -VERSION- ':WILD VERSION-P T))
	((EQ -VERSION- ':WILD)
	 (SETQ -TYPE- ':WILD TYPE-P T))
	((AND (NOT (MEMQ -TYPE- '(NIL :UNSPECIFIC)))
	      (NOT (MEMQ -VERSION- '(NIL :UNSPECIFIC))))
	 (IF (MEM 'STRING-EQUAL -TYPE- *ITS-UNINTERESTING-TYPES*)
	     (SETQ -TYPE- ':UNSPECIFIC TYPE-P T)
	   (SETQ -VERSION- ':UNSPECIFIC VERSION-P T)))
	((NOT (MEMQ -TYPE- '(NIL :UNSPECIFIC)))
	 (SETQ -VERSION- ':UNSPECIFIC VERSION-P T))
	((NOT (MEMQ -VERSION- '(NIL :UNSPECIFIC)))
	 (SETQ -TYPE- ':UNSPECIFIC TYPE-P T)))
  (LEXPR-FUNCALL #'MAKE-PATHNAME-1
		 (IF TYPE-P ':TYPE) -TYPE-
		 (IF VERSION-P ':VERSION) -VERSION-
		 ':STARTING-PATHNAME (OR STARTING-PATHNAME SELF)
		 ':PARSING-PATHNAME SELF
		 OPTIONS))

(DEFMETHOD (ITS-PATHNAME-MIXIN :AFTER :INIT) (IGNORE)
  (AND (NOT (MEMQ TYPE '(NIL :UNSPECIFIC)))
       (NOT (MEMQ VERSION '(NIL :UNSPECIFIC)))
       (NOT (AND (EQ TYPE ':WILD) (EQ VERSION ':WILD)))
       (FERROR NIL "ITS-PATHNAME created with type ~S and version ~S." TYPE VERSION)))

;;; For most components, just upcase the string
(DEFMETHOD (ITS-PATHNAME-MIXIN :PARSE-COMPONENT-SPEC) (SPEC)
  (COND ((CONSP SPEC) (MAPCAR #'(LAMBDA (X)
				  (FUNCALL-SELF ':PARSE-COMPONENT-SPEC X))
			      SPEC))
	((STRINGP SPEC) (SIX-SIXBIT-CHARACTERS SPEC))
	(T SPEC)))

(DEFMETHOD (ITS-PATHNAME-MIXIN :PARSE-NAME-SPEC) (SPEC)
  (COND ((STRINGP SPEC) (FUNCALL-SELF ':PARSE-COMPONENT-SPEC SPEC))
	((AND (CONSP SPEC)
	      (STRINGP (CAR SPEC))
	      (CONSP (CDR SPEC))
	      (STRINGP (CADR SPEC))
	      (NULL (CDDR SPEC)))
	 ;; Allow list of length two as name component.
	 (FUNCALL-SELF ':PARSE-COMPONENT-SPEC SPEC))
	((AND (CONSP SPEC)
	      (STRINGP (CAR SPEC))
	      (NULL (CDR SPEC)))
	 (FUNCALL-SELF ':PARSE-COMPONENT-SPEC (CAR SPEC)))
	((MEMQ SPEC '(NIL :UNSPECIFIC :WILD)) SPEC)
	(T "FOO")))

(DEFMETHOD (ITS-PATHNAME-MIXIN :PARSE-VERSION-SPEC) (SPEC)
  (IF (OR (AND (FIXNUMP SPEC) (> SPEC 0))
	  (MEMQ SPEC '(NIL :UNSPECIFIC :WILD :NEWEST :OLDEST)))
      SPEC ':NEWEST))

;;; Parse an its pathname string.   and  are quoting characters.
(DEFMETHOD (ITS-PATHNAME-MIXIN :PARSE-NAMESTRING) (HOST-SPECIFIED NAMESTRING
					     &OPTIONAL (START 0) END)
  (OR END (SETQ END (STRING-LENGTH NAMESTRING)))
  (DO ((I START)
       (J START (1+ J))
       (CH) (TEM)
       (DEV (AND HOST-SPECIFIED "DSK"))
       (DIR) (FN1) (FN1P) (FN2)
       (TYP) (VERS))
      ((> J END)
       (COND ((NULL FN2))
	     ((SETQ TEM (NUMERIC-P FN2))
	      (SETQ VERS TEM TYP ':UNSPECIFIC))
	     ((EQUAL FN2 ">")
	      (SETQ VERS ':NEWEST TYP ':UNSPECIFIC))
	     ((EQUAL FN2 "<")
	      (SETQ VERS ':OLDEST TYP ':UNSPECIFIC))
	     ((EQUAL FN2 "*")
	      (SETQ TYP ':WILD VERS ':WILD))
;	     ((MEMBER FN2 *ITS-UNINTERESTING-TYPES*)
;	      (SETQ TYP FN2 VERS ':UNSPECIFIC))
	     (T
	      ;; Used to use :NEWEST here.
	      (SETQ TYP FN2 VERS ':UNSPECIFIC)))
       (VALUES DEV DIR FN1 TYP VERS))
    (SETQ CH (IF (= J END) #\SP (AREF NAMESTRING J)))
    (COND ((MEMQ CH '(#/ #/))
	   (SETQ J (1+ J)))
	  ((MEMQ CH '(#/: #/; #/ #\SP #\TAB))
	   (COND (( I J)
		  (SETQ TEM (SIX-SIXBIT-CHARACTERS NAMESTRING T I J))
		  (SELECTQ CH
		    (#/: (SETQ DEV TEM))
		    (#/; (SETQ DIR TEM))
		    (OTHERWISE
		     (COND (FN2)
			   (FN1P (SETQ FN2 TEM))
			   (T (SETQ FN1 TEM FN1P T)))))))
	   (IF (EQ CH #/) (SETQ FN1P T))
	   (SETQ I (1+ J))))))

;;; Truncate to six characters
(DEFUN SIX-SIXBIT-CHARACTERS (STRING &OPTIONAL QUOTE-P (START 0) (END (STRING-LENGTH STRING)))
  "Truncate STRING to six characters and make sure they are all SIXBIT characters.
START and END specify the part of STRING to use (default is all).
QUOTE-P non-NIL says insert quoting characters where appropriate."
  (DO ((I START (1+ I))
       (NCH 0) (CH)
       (NEED-COPY NIL))
      ((OR ( I END) (= NCH 6))
       (COND ((AND (= START 0) (= I (STRING-LENGTH STRING)) (NOT NEED-COPY))
	      STRING)				;To avoid consing
	     ((NOT NEED-COPY)
	      (SUBSTRING STRING START I))
	     (T
	      (DO ((NSTRING (MAKE-ARRAY NCH ':TYPE 'ART-STRING))
		   (J 0)
		   (K START (1+ K))
		   (CH))
		  (( K I) NSTRING)
		(SETQ CH (AREF STRING K))
		(COND ((NOT (AND QUOTE-P (MEMQ CH '(#/ #/))))
		       (SETQ CH (COND ((< CH 40) (+ CH 40))
				      ((< CH 140) CH)
				      (T (- CH 40))))
		       (ASET CH NSTRING J)
		       (SETQ J (1+ J))))))))
    (SETQ CH (AREF STRING I))
    (IF (AND QUOTE-P (MEMQ CH '(#/ #/)))
	(SETQ NEED-COPY T)
	(SETQ NCH (1+ NCH)))
    (OR (AND ( CH #\SP) ( CH #/_))		;Already legal SIXBIT
	(SETQ NEED-COPY T))))

(DEFUN NUMERIC-P (STRING &OPTIONAL PARTIAL-OK SIGN-OK)
  "If STRING is a printed representation of a number, return the number, else NIL.
PARTIAL-OK non-NIL says, if the number is not the whole of STRING,
 still return the number that there is (normally, NIL is returned)
 with a second value which is the index of the character after the number.
SIGN-OK non-NIL says a sign at the front is allowed."
  (AND (STRINGP STRING)
       (DO ((I 0 (1+ I))
	    (LEN (STRING-LENGTH STRING))
	    (NUM NIL)
	    (SIGN 1)
	    (CH))
	   (( I LEN)
	    (AND NUM (* NUM SIGN)))
	 (SETQ CH (AREF STRING I))
	 (COND ((AND SIGN-OK
		     (ZEROP I)
		     (MEMQ CH '(#/+ #/-)))
		(IF (EQ CH #/+)
		    (SETQ SIGN 1)
		  (SETQ SIGN -1)))
	       ((AND ( #/9 CH)
		     ( CH #/0))
		(SETQ NUM (+ (- CH #/0) (IF NUM (* NUM 10.) 0))))
	       (PARTIAL-OK
		(RETURN (AND NUM (* NUM SIGN)) I))
	       (T (RETURN NIL))))))

(DEFMETHOD (ITS-PATHNAME-MIXIN :INIT-FILE) (PROGRAM-NAME)
  (FUNCALL-SELF ':NEW-PATHNAME ':NAME USER-ID
			       ':TYPE PROGRAM-NAME))

;;; These are for things like the microcode files that need to compact both a name and a type
;;; into one pathname.
(DEFMETHOD (ITS-PATHNAME-MIXIN :NEW-TYPE-AND-VERSION) (NEW-TYPE NEW-VERSION)
  (FUNCALL-SELF ':NEW-PATHNAME ':TYPE (SIX-SIXBIT-CHARACTERS (FORMAT NIL "~D~A"
								     (\ NEW-VERSION 1000.)
								     NEW-TYPE))))

(DEFMETHOD (ITS-PATHNAME-MIXIN :TYPE-AND-VERSION) (&AUX TYP VERS I)
  (COND ((STRINGP TYPE)
	 (MULTIPLE-VALUE (VERS I) (NUMERIC-P TYPE T))
	 (AND I (SETQ TYP (SUBSTRING TYPE I)))
	 (VALUES TYP VERS))
	(T (VALUES TYPE TYPE))))

;;; Patch system interface, more kludges for only six character filenames
(DEFMETHOD (ITS-PATHNAME-MIXIN :PATCH-FILE-PATHNAME) (NAM SAME-DIRECTORY-P PATOM TYP
						      &REST ARGS)
  (SELECTQ TYP
    (:SYSTEM-DIRECTORY
     (FUNCALL-SELF ':NEW-PATHNAME ':NAME (IF SAME-DIRECTORY-P PATOM NAM)
		   ':TYPE "(PDIR)"))
    (:VERSION-DIRECTORY
     (FUNCALL-SELF ':NEW-PATHNAME ':NAME (WITH-OUTPUT-TO-STRING (STREAM)
					   (LET ((SNAME (IF SAME-DIRECTORY-P PATOM
							  (SI:SYSTEM-SHORT-NAME NAM))))
					     (DOTIMES (I (MIN (STRING-LENGTH SNAME) 3))
					       (FUNCALL STREAM ':TYO (AREF SNAME I))))
					   (LET ((BASE 10.) (*NOPOINT T))
					     (PRIN1 (\ (CAR ARGS) 1000.) STREAM)))
		   ':TYPE "(PDIR)"))
    (:PATCH-FILE
     (FUNCALL-SELF ':NEW-PATHNAME ':NAME (FORMAT NIL "~:[~*~;~C~]~D.~D"
						 SAME-DIRECTORY-P PATOM
						 (\ (CAR ARGS) 100.)
						 (\ (CADR ARGS)
						    (IF SAME-DIRECTORY-P 100. 1000.)))
		   ':TYPE (CADDR ARGS)))))
  
;;;  Various TENEX-family pathnames:  TOPS20, TENEX, VMS

(DEFFLAVOR TENEX-FAMILY-PATHNAME-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME)
  (:REQUIRED-METHODS :SUPPRESSED-DEVICE-NAMES
   :QUOTE-CHARACTER))

(DEFCONST *TENEX-WILD-CHARACTERS* '(#/* #/%))
(DEFCONST *TENEX-INTERNAL-WILD-CHARACTERS* '(#\BREAK #\RESUME))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :INTERNAL-WILD-CHARACTERS) ()
  (VALUES-LIST *TENEX-INTERNAL-WILD-CHARACTERS*))

;; These messages are careful about consing in PATHNAME-AREA
;; See comment by PATHNAME-AREA

;; Changed 7/19/83 so that NIL as type and NIL as version produce no output.
;; This is for the sake of completion of logical pathnames
;; that translate into these.
(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :STRING-FOR-HOST) ()
  (LET ((DIR-DELIM (CAR (FUNCALL-SELF ':DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD DEVICE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(DIR (TENEX-FAMILY-DIRECTORY-NAME))
	(NAM (STRING-OR-WILD NAME NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(TYP (STRING-OR-WILD TYPE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(VER (IF VERSION (TENEX-FAMILY-VERSION-STRING) ""))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A:~C~A~C~A~:[.~]~:[~A~;~*~]~@[~A~]"
	    DEV (CAR DIR-DELIM) DIR (CDR DIR-DELIM)
	    NAM (NOT (OR TYPE VERSION))
	    (MEMQ TYPE '(NIL :UNSPECIFIC)) TYP VER)))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :STRING-FOR-PRINTING) ()
  (LET ((DIR-DELIM (CAR (FUNCALL-SELF ':DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD DEVICE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(DIR (TENEX-FAMILY-DIRECTORY-NAME))
	(NAM (STRING-OR-WILD NAME NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(TYP (STRING-OR-WILD TYPE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(VER (TENEX-FAMILY-VERSION-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT:OUTPUT NIL
      (PRINC (FUNCALL HOST ':NAME-AS-FILE-COMPUTER))
      ":"
      ;; Maybe print the device and a colon.
      (OR (MEMBER DEVICE (FUNCALL-SELF ':SUPPRESSED-DEVICE-NAMES))
	  (PROGN (PRINC DEV) (TYO #/:)))
      ;; Maybe print the directory in delimiters.
      (COND (DIR
	     (TYO (CAR DIR-DELIM))
	     (PRINC DIR)
	     (TYO (CDR DIR-DELIM))))
      ;; Maybe print the filename.
      (WHEN (OR NAME TYPE VERSION)
	(SELECTQ NAME
	  ((NIL)
	   (PRINC ""))
	  (:UNSPECIFIC NIL)
	  (T (PRINC NAM)))
	;; Print "." and the type.
	(COND ((OR TYPE VER)
	       (TYO #/.)
	       (SELECTQ TYPE
		 ((NIL) (PRINC ""))
		 (:UNSPECIFIC NIL)
		 (T (PRINC TYP)))))
	(IF VER (PRINC VER))))))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :STRING-FOR-WHOLINE) (&OPTIONAL (LENGTH 10000))
  (LET* ((DIR-DELIM (CAR (FUNCALL-SELF ':DIRECTORY-DELIMITERS)))
	 (HOST-NAME (FUNCALL HOST ':NAME-AS-FILE-COMPUTER))
	 (DEV (STRING-OR-WILD DEVICE NIL
			      *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	 (DIR (TENEX-FAMILY-DIRECTORY-NAME))
	 (NAM (STRING-OR-WILD NAME NIL
			      *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	 (TYP (STRING-OR-WILD TYPE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	 (VER (TENEX-FAMILY-VERSION-STRING))
	 (DEFAULT-CONS-AREA PATHNAME-AREA)
	 (DEV-LENGTH (COND ((MEMBER DEVICE (FUNCALL-SELF ':SUPPRESSED-DEVICE-NAMES))
			    0)
			   (T (1+ (LENGTH DEV)))))
	 (TYPE-VER-LENGTH (+ (COND ((NULL TYPE) 0)
				   ((EQ TYPE ':WILD) 2)
				   ((EQ TYPE ':UNSPECIFIC) 1)
				   (T (1+ (LENGTH TYP))))
			     (LENGTH VER))))
    (FORMAT:OUTPUT NIL
      (PRINC HOST-NAME)
      ":"
      ;; Maybe print the device and a colon.
      (OR (MEMBER DEVICE (FUNCALL-SELF ':SUPPRESSED-DEVICE-NAMES))
	  (PROGN (PRINC DEV) (TYO #/:)))
      ;; Maybe print the directory in delimiters.
      (COND (DIR
	     (TYO (CAR DIR-DELIM))
	     (COND ((>= LENGTH (+ (LENGTH HOST-NAME) 1
				  DEV-LENGTH (LENGTH DIR) 2
				  (COND ((MEMQ NAME '(NIL :UNSPECIFIC)) 0)
					(T (LENGTH NAM)))
				  TYPE-VER-LENGTH))
		    (PRINC DIR))
		   (T (SEND STANDARD-OUTPUT ':STRING-OUT
			    DIR 0 (MAX 0
				       (- LENGTH
					  (+ (LENGTH HOST-NAME) 1
					     DEV-LENGTH 3
					     (COND ((MEMQ NAME '(NIL :UNSPECIFIC)) 0)
						   (T (LENGTH NAM)))
					     TYPE-VER-LENGTH))))
		      (TYO #/ )))
	     (TYO (CDR DIR-DELIM))))
      ;; Maybe print the filename.
      (OR (MEMQ NAME '(NIL :UNSPECIFIC))
	  (PRINC NAM))
      ;; Print "." and the type.
      (COND (TYPE
	     (TYO #/.)
	     (OR (EQ TYPE ':UNSPECIFIC)
		 (PRINC TYP))))
      (IF VER (PRINC VER)))))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :STRING-FOR-EDITOR) ()
  (LET ((DIR-DELIM (CAR (FUNCALL-SELF ':DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD DEVICE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(DIR (TENEX-FAMILY-DIRECTORY-NAME))
	(NAM (STRING-OR-WILD NAME NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(TYP (STRING-OR-WILD TYPE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(VER (TENEX-FAMILY-VERSION-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~:[~A~;~*~].~:[~A~;~*~]~@[~A~] ~:[~A~;~*~]:~@[~C~A~C~] ~A:"
	    (MEMQ NAME '(NIL :UNSPECIFIC)) NAM
	    (MEMQ TYPE '(NIL :UNSPECIFIC)) TYP
	    VER
	    (MEMQ DEVICE '(NIL :UNSPECIFIC)) DEV
	    (CAR DIR-DELIM) DIR (CDR DIR-DELIM)
	    (FUNCALL HOST ':NAME-AS-FILE-COMPUTER))))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :STRING-FOR-DIRED) ()
  (LET ((NAM (STRING-OR-WILD NAME NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(TYP (STRING-OR-WILD TYPE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(VER (TENEX-FAMILY-VERSION-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~:[~A~;~*~].~:[~A~;~*~]~@[~A~]"
	    (MEMQ NAME '(NIL :UNSPECIFIC)) NAM
	    (MEMQ TYPE '(NIL :UNSPECIFIC)) TYP
	    VER)))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :STRING-FOR-DIRECTORY) ()
  (LET ((DIR-DELIM (CAR (FUNCALL-SELF ':DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD DEVICE NIL
			     *TENEX-INTERNAL-WILD-CHARACTERS* *TENEX-WILD-CHARACTERS*))
	(DIR (TENEX-FAMILY-DIRECTORY-NAME)))
    (FORMAT NIL "~:[~A:~;~*~]~@[~C~A~C~]"
	  (MEMBER DEVICE (FUNCALL-SELF ':SUPPRESSED-DEVICE-NAMES)) DEV
	  (CAR DIR-DELIM) DIR (CDR DIR-DELIM))))

(DEFUN TENEX-FAMILY-DIRECTORY-NAME ()
  (DECLARE (:SELF-FLAVOR TENEX-FAMILY-PATHNAME-MIXIN))
  (COND ((MEMQ DIRECTORY '(NIL :UNSPECIFIED)) NIL)
	((NLISTP DIRECTORY) (STRING-OR-WILD DIRECTORY NIL
					    *TENEX-INTERNAL-WILD-CHARACTERS*
					    *TENEX-WILD-CHARACTERS*))
	(T (FORMAT NIL "~{~A~^.~}"
		   (LOOP FOR ELT IN DIRECTORY
			 COLLECT
			 (STRING-OR-WILD ELT NIL
					 *TENEX-INTERNAL-WILD-CHARACTERS*
					 *TENEX-WILD-CHARACTERS*))))))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :WILD-P) ()
  ;; Note: method-combination type is :OR.
  (IF (OR (STRING-SEARCH-SET *TENEX-INTERNAL-WILD-CHARACTERS* NAME)
	  (STRING-SEARCH-SET *TENEX-INTERNAL-WILD-CHARACTERS* TYPE)
	  (IF (STRINGP DIRECTORY)
	      (STRING-SEARCH-SET *TENEX-INTERNAL-WILD-CHARACTERS* DIRECTORY)
	    (IF (LISTP DIRECTORY)
		(DOLIST (DC DIRECTORY)
		  (IF (OR (EQ DC ':WILD)
			  (STRING-SEARCH-SET *TENEX-INTERNAL-WILD-CHARACTERS* DC))
		      (RETURN T))))))
      T))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :DIRECTORY-WILD-P) ()
  (OR (EQ DIRECTORY ':WILD)
      (IF (STRINGP DIRECTORY)
	  (STRING-SEARCH-SET *TENEX-INTERNAL-WILD-CHARACTERS* DIRECTORY)
	(IF (LISTP DIRECTORY)
	    (DOLIST (DC DIRECTORY)
	      (IF (OR (EQ DC ':WILD)
		      (STRING-SEARCH-SET *TENEX-INTERNAL-WILD-CHARACTERS* DC))
		  (RETURN T)))))))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :NAME-WILD-P) ()
  (OR (EQ NAME ':WILD)
      (STRING-SEARCH-SET *TENEX-INTERNAL-WILD-CHARACTERS* NAME)))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :TYPE-WILD-P) ()
  (OR (EQ TYPE ':WILD)
      (STRING-SEARCH-SET *TENEX-INTERNAL-WILD-CHARACTERS* TYPE)))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :VERSION-DELIMITER) () #/.)
(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :DIRECTORY-DELIMITERS) () '((#/< . #/>)))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :INIT-FILE) (PROGRAM-NAME)
  (FUNCALL-SELF ':NEW-PATHNAME ':NAME (STRING-UPCASE PROGRAM-NAME)
			       ':TYPE "INIT"
			       ':VERSION ':NEWEST))

(DEFUN TENEX-FAMILY-VERSION-STRING ()
  (DECLARE (:SELF-FLAVOR TENEX-FAMILY-PATHNAME-MIXIN))
  (SELECTQ VERSION
    (:NEWEST NIL)
    ((NIL) ".")
    (:UNSPECIFIC
     (STRING (FUNCALL-SELF ':VERSION-DELIMITER)))
    (T
     (FORMAT NIL "~C~D"
	     (FUNCALL-SELF ':VERSION-DELIMITER)
	     (SELECTQ VERSION
	       (:OLDEST -2)
	       (:WILD "*")
	       (OTHERWISE VERSION))))))

(comment  ;I think it's a no-op, let's see (3/30/83)
(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :PARSE-COMPONENT-SPEC) (SPEC)
  (COND ((CONSP SPEC) (MAPCAR #'(LAMBDA (X)
				  (FUNCALL-SELF ':PARSE-COMPONENT-SPEC X))
			      SPEC))
	((STRINGP SPEC)
;	 ;; Convert wild characters to their internal form.
;This doesn't do that!
	 (TENEX-FAMILY-STRING-UNTIL-DELIM SPEC NIL 0 NIL T))
	(T SPEC))))  

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :PARSE-VERSION-SPEC) (SPEC)
  (IF (OR (AND (FIXNUMP SPEC) ( SPEC 0))
	  (MEMQ SPEC '(NIL :UNSPECIFIC :WILD :NEWEST :OLDEST)))
      SPEC ':NEWEST))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :PARSE-DIRECTORY-SPEC) (SPEC)
  (COND ((STRINGP SPEC) (SEND SELF ':PARSE-COMPONENT-SPEC SPEC))
	;; Canonicalize list of length 1 into a single string.
	((AND (CONSP SPEC)
	      (STRINGP (CAR SPEC))
	      (NULL (CDR SPEC)))
	 (FUNCALL-SELF ':PARSE-COMPONENT-SPEC (CAR SPEC)))
	;; A list of strings is also a structured directory.
	((AND (CONSP SPEC)
	      (LOOP FOR ELT IN SPEC ALWAYS (STRINGP ELT)))
	 (MAPCAR SELF (CIRCULAR-LIST ':PARSE-COMPONENT-SPEC) SPEC))
	((MEMQ SPEC '(NIL :UNSPECIFIC :WILD)) SPEC)
	(T (PATHNAME-DIRECTORY (QUIET-USER-HOMEDIR HOST)))))

;;; Parse a TENEX-family pathname string.
(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :PARSE-NAMESTRING)
	   (HOST-SPECIFIED NAMESTRING &OPTIONAL (START 0) END)
  (OR END (SETQ END (STRING-LENGTH NAMESTRING)))
  (LET* ((DIR-DELIM-ALIST (FUNCALL-SELF ':DIRECTORY-DELIMITERS))
	 (ALL-DELIMS (NCONC (MAPCAR #'CAR DIR-DELIM-ALIST) '(#/: #/. #/; #\SP))))
    (DO ((IDX (OR (STRING-SEARCH-NOT-CHAR #\SP NAMESTRING START END) END))
	 (TEM) (TEM1) (DELIM)
	 (DIR-DELIM)
	 (DEV)
	 (DIR) (NAM) (TYP) (VERS)
	 NAME-SPECD TYPE-SPECD VERS-SPECD)
	(( IDX END)
	 (IF (EQUAL TYP "") (SETQ TYP ':UNSPECIFIC))
	 (VALUES (OR DEV (AND HOST-SPECIFIED (FUNCALL-SELF ':PRIMARY-DEVICE)))
		 DIR (AND (NOT (EQUAL NAM "")) NAM)
		 TYP VERS))
      (COND ((SETQ DIR-DELIM (CDR (ASSOC (AREF NAMESTRING IDX) DIR-DELIM-ALIST)))
	     (AND DIR
		  (PATHNAME-ERROR IDX "Directory occurs twice in ~A" NAMESTRING))
	     (SETQ IDX (1+ IDX))
	     (DO () (NIL)
	       (MULTIPLE-VALUE (TEM IDX DELIM)
		 (TENEX-FAMILY-STRING-UNTIL-DELIM NAMESTRING (LIST #/. DIR-DELIM) IDX END NIL T))
	       (SETQ DIR (IF (AND (= DELIM DIR-DELIM) (NULL DIR))
			     TEM
			     (NCONC DIR (NCONS TEM))))
	       (AND (= DELIM DIR-DELIM) (RETURN))))
	    (T
	     (MULTIPLE-VALUE (TEM IDX DELIM)
	       (TENEX-FAMILY-STRING-UNTIL-DELIM NAMESTRING ALL-DELIMS IDX END T T))
	     (COND ((ASSQ DELIM DIR-DELIM-ALIST)
		    (SETQ IDX (1- IDX)))
		   ((AND (= DELIM #/;) VERS)	;Attribute like protection
		    (SETQ IDX END)))
	     (IF (MEMBER TEM '("*" "201")) (SETQ TEM ':WILD))
	     (COND ((= DELIM #/:)
		    (AND DEV
			 (PATHNAME-ERROR IDX
				 "Device occurs twice in ~A" NAMESTRING))
		    (SETQ DEV TEM))
		   ((NULL NAME-SPECD)
		    (SETQ NAM TEM NAME-SPECD T)
		    (IF (= DELIM #/.) (SETQ TYP ':UNSPECIFIC)))
		   ((NULL TYPE-SPECD)
		    (SETQ TYP TEM TYPE-SPECD T)
		    (IF (= DELIM #/.) (SETQ VERS ':UNSPECIFIC)))
		   ((NULL VERS-SPECD)
		    (SETQ VERS-SPECD T)
		    (COND ((NULL TEM)
			   (SETQ VERS NIL))
			  ((EQUAL TEM "")
			   (SETQ VERS ':UNSPECIFIC))
			  ((SETQ TEM1 (NUMERIC-P TEM))
			   (SETQ VERS TEM1))
			  ((EQ TEM ':WILD)
			   (SETQ VERS ':WILD))
			  ((FUNCALL-SELF ':OLDEST-CHECK TEM)
			   (SETQ VERS ':OLDEST))
			  (T (PATHNAME-ERROR IDX
				     "Version must be numeric in ~A" NAMESTRING))))))))))

;;; Internal parsing function, read the next atom from string to one of delims
;;; EOS-OK means it is alright to fall off the end of the string, that is treated
;;; as a delimiter and -1 is returned for the third value.
;;; QUOTE-P says look for quoting characters (and remove them in the result).
(DEFUN TENEX-FAMILY-STRING-UNTIL-DELIM (STRING DELIMS &OPTIONAL (START 0) END EOS-OK QUOTE-P
					&AUX IDX DELIM (NCH 0) (NEED-COPY NIL))
  (DECLARE (RETURN-LIST SUBSTRING END DELIM))
  (OR END (SETQ END (STRING-LENGTH STRING)))
  (DO ((I START (1+ I))
       (CHAR))
      (( I END)
       (OR EOS-OK (PATHNAME-ERROR I "Illegal end of string in ~A" STRING))
       (SETQ IDX END DELIM -1))
    (SETQ CHAR (AREF STRING I))
    (COND (( #/A CHAR #/Z))
	  ((AND QUOTE-P (= CHAR #/))
	   ;; TOPS-20 quoting character
	   (AND ( (SETQ I (1+ I)) END)
		(PATHNAME-ERROR I
				"End of string after quote character in ~A" STRING))
	   (SETQ NEED-COPY T
		 NCH (1+ NCH)))
	  ((MEMQ CHAR DELIMS)
	   (SETQ IDX I DELIM CHAR)
	   (RETURN))
	  (QUOTE-P
	   (IF (MEMQ CHAR '(#/* #/%))
	       (SETQ NEED-COPY T))
	   (AND ( CHAR #/a) ( CHAR #/z)
		(SETQ NEED-COPY T)))))
  ;; NCH is number of characters that we will discard.
  ;; NEED-COPY is T if either we will discard some chars or we must upcase some.
  (VALUES (COND ((AND QUOTE-P (= IDX (1+ START))
		      (STRING-EQUAL STRING "" START 0 IDX 1))
		 NIL)
		((AND (= START 0) (= IDX (STRING-LENGTH STRING)) (NOT NEED-COPY))
		 STRING)			;Avoid consing
		((NOT NEED-COPY)
		 (SUBSTRING STRING START IDX))
		(T
		 (DO ((SUBSTRING (MAKE-ARRAY (- IDX START NCH) ':TYPE 'ART-STRING))
		      (I 0)
		      (J START (1+ J))
		      (QUOTE-P NIL)
		      (CHAR))
		     (( J IDX)
		      SUBSTRING)
		   (SETQ CHAR (LOGAND 177 (AREF STRING J)))
		   (IF (AND (NOT QUOTE-P)
			    (MEMQ CHAR '(#/% #/*)))
		       (SETQ CHAR (IF (= CHAR #/%) #\RESUME #\BREAK)))
		   (IF (AND (NOT QUOTE-P) (= CHAR #/))
		       (SETQ QUOTE-P T)
		     (IF QUOTE-P
			 (SETQ QUOTE-P NIL)
		       (SETQ CHAR (CHAR-UPCASE CHAR)))
		     (SETF (AREF SUBSTRING I) CHAR)
		     (SETQ I (1+ I))))))
	  (1+ IDX) DELIM))

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :DIRECTORY-FILE-TYPE) ()
  "DIRECTORY")

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :DIRECTORY-PATHNAME-AS-FILE)
	   DEFAULT-DIRECTORY-PATHNAME-AS-FILE)

(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :UNDELETABLE-P) () T)

;;;; TOPS-20 support
(DEFFLAVOR TOPS20-PATHNAME-MIXIN () (HIERARCHICAL-DIRECTORY-MIXIN TENEX-FAMILY-PATHNAME-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

;Differs from the standard one in that we replace "DSK" with "PS".
(DEFMETHOD (TOPS20-PATHNAME-MIXIN :NEW-PATHNAME) (&REST OPTIONS
						  &KEY &OPTIONAL STARTING-PATHNAME
						  ((:DEVICE DEV))
						  &ALLOW-OTHER-KEYS)
  (COND ((EQ DEV ':UNSPECIFIC)
	 (LEXPR-FUNCALL #'MAKE-PATHNAME-1
			':STARTING-PATHNAME (OR STARTING-PATHNAME SELF)
			':PARSING-PATHNAME SELF
			':DEVICE (FUNCALL HOST ':PRIMARY-DEVICE)
			OPTIONS))
	(T
	 (LEXPR-FUNCALL #'MAKE-PATHNAME-1
			':STARTING-PATHNAME (OR STARTING-PATHNAME SELF)
			':PARSING-PATHNAME SELF
			OPTIONS))))

(DEFMETHOD (TOPS20-PATHNAME-MIXIN :SUPPRESSED-DEVICE-NAMES) () '(NIL :UNSPECIFIC))

(DEFMETHOD (TOPS20-PATHNAME-MIXIN :QUOTE-CHARACTER) () #/)

(DEFMETHOD (TOPS20-PATHNAME-MIXIN :CHARACTER-NEEDS-QUOTING-P) (CH)
  (NOT (OR (AND ( CH #/A) ( CH #/Z))
	   (AND ( CH #/0) ( CH #/9))
	   (MEMQ CH '(#/# #/$ #/_ #/-)))))

(DEFMETHOD (TOPS20-PATHNAME-MIXIN :OLDEST-CHECK) (STRING)
  (STRING-EQUAL STRING "-2"))

(DEFUN DEFAULT-DIRECTORY-PATHNAME-AS-FILE (IGNORE &AUX DIR NAM)
  (DECLARE (:SELF-FLAVOR PATHNAME))
  (COND ((EQ DIRECTORY ':ROOT)
	 (FERROR 'PATHNAME-PARSE-ERROR "There is no pathname for the root as a file"))
	((OR (ATOM DIRECTORY) (NULL (CDR DIRECTORY)))
	 (SETQ DIR ':ROOT
	       NAM (IF (LISTP DIRECTORY) (CAR DIRECTORY) DIRECTORY)))
	(T
	 (LET ((LAST (LAST DIRECTORY)))
	   (SETQ DIR (LDIFF DIRECTORY LAST)
		 NAM (CAR LAST)))))
  (FUNCALL-SELF ':NEW-PATHNAME ':RAW-DIRECTORY DIR ':RAW-NAME NAM
		':TYPE (FUNCALL-SELF ':DIRECTORY-FILE-TYPE)))

;;;; Tenex support
(DEFFLAVOR TENEX-PATHNAME-MIXIN () (TENEX-FAMILY-PATHNAME-MIXIN))

(DEFMETHOD (TENEX-PATHNAME-MIXIN :VERSION-DELIMITER) () #/;)

(DEFMETHOD (TENEX-PATHNAME-MIXIN :SUPPRESSED-DEVICE-NAMES) () '(NIL :UNSPECIFIC "DSK"))

(DEFMETHOD (TENEX-PATHNAME-MIXIN :CHARACTER-NEEDS-QUOTING-P) (CH)
  (NOT (OR (AND ( CH #/A) ( CH #/Z))
	   (AND ( CH #/0) ( CH #/9))
	   (AND ( CH #/!) ( CH #/$))
	   (AND ( CH #/&) ( CH #/)))
	   (MEMQ CH '(#/+ #// #/= #/-))
	   (AND ( CH #/[) ( CH #/^)))))

(DEFMETHOD (TENEX-PATHNAME-MIXIN :OLDEST-CHECK) (STRING)
  (STRING-EQUAL STRING "-2"))

(DEFMETHOD (TENEX-PATHNAME-MIXIN :QUOTE-CHARACTER) ()
  #/)

;;;; VMS support
(DEFFLAVOR VMS-PATHNAME-MIXIN () (MEANINGFUL-ROOT-MIXIN HIERARCHICAL-DIRECTORY-MIXIN
				  TENEX-FAMILY-PATHNAME-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (VMS-PATHNAME-MIXIN :OLDEST-CHECK) (IGNORE) NIL)	;Maybe make the server simulate?
(DEFMETHOD (VMS-PATHNAME-MIXIN :VERSION-DELIMITER) () #/;)

(DEFMETHOD (VMS-PATHNAME-MIXIN :SUPPRESSED-DEVICE-NAMES) () '(NIL :UNSPECIFIC))

;;; Let the TOPS-20 parser do the work.  Then take the
;;; result, check it against the more limited VMS constraints.

(DEFWRAPPER (VMS-PATHNAME-MIXIN :PARSE-NAMESTRING) (ARGLIST . BODY)
  `(PROGN (IF (STRING-SEARCH-CHAR #/ (NTH 1 ARGLIST))
	      (FERROR 'PATHNAME-PARSE-ERROR "Illegal chararacter in ~A" (NTH 1 ARGLIST)))
	  (MULTIPLE-VALUE-BIND (DEV DIR NAM TYP VRS) (PROGN ,@BODY)
	    (IF (EQUAL DIR "000000")
		(SETQ DIR ':ROOT))
	    (VALUES DEV DIR NAM TYP VRS))))

;;; There are no quoting characters possible, sigh.
(DEFMETHOD (VMS-PATHNAME-MIXIN :QUOTE-CHARACTER) () ())
(DEFMETHOD (VMS-PATHNAME-MIXIN :CHARACTER-NEEDS-QUOTING-P) (IGNORE) ())
(DEFMETHOD (VMS-PATHNAME-MIXIN :DIRECTORY-DELIMITERS) ()
  '((#/[ . #/]) (#/< . #/>)))

;;; The VMS character set is absurdly limited.  devname:<dir.dir.dir>name.typ,
;;; where devname can be alphanumerics plus $ and _, and the rest can be alphanumerics.

(DEFVAR VMS-DEVNAME-CHARSET "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_")
(DEFVAR VMS-FILENAME-CHARSET "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")

(DEFMETHOD (VMS-PATHNAME-MIXIN :DIRECTORY-FILE-TYPE) ()
  "DIR")

(DEFMETHOD (VMS-PATHNAME-MIXIN :PARSE-COMPONENT-SPEC) (SPEC)
  (IF (STRINGP SPEC) (STRING-UPCASE SPEC) SPEC))

(DEFMACRO VMS-PARSE-PATHNAME-COMPONENT (OPERATION COMPONENT SIZE CHARSET DEFAULT)
  `(COND ((MEMQ ,COMPONENT '(NIL :UNSPECIFIC :WILD)) ,COMPONENT)
	 ((STRINGP ,COMPONENT)
	  (LET ((SPEC1 (IF (< (LENGTH ,COMPONENT) ,SIZE)
			   ,COMPONENT
			 (SUBSTRING ,COMPONENT 0 ,SIZE))))
	    (IF (STRING-SEARCH-NOT-SET ,CHARSET SPEC1)
		,DEFAULT
	      SPEC1)))
	((AND (CONSP ,COMPONENT)
	      (STRINGP (CAR ,COMPONENT))
	      (NULL (CDR ,COMPONENT)))
	 (FUNCALL-SELF ',OPERATION (CAR ,COMPONENT)))
	(T ,DEFAULT)))

(DEFMETHOD (VMS-PATHNAME-MIXIN :PARSE-DEVICE-SPEC) (SPEC)
  (VMS-PARSE-PATHNAME-COMPONENT :PARSE-DEVICE-SPEC SPEC 64. VMS-DEVNAME-CHARSET
				(PATHNAME-DEVICE (QUIET-USER-HOMEDIR HOST))))

(DEFMETHOD (VMS-PATHNAME-MIXIN :PARSE-NAME-SPEC) (SPEC)
  (VMS-PARSE-PATHNAME-COMPONENT :PARSE-NAME-SPEC SPEC 9 VMS-FILENAME-CHARSET "FOO"))

(DEFMETHOD (VMS-PATHNAME-MIXIN :PARSE-TYPE-SPEC) (SPEC)
  (VMS-PARSE-PATHNAME-COMPONENT :PARSE-NAME-SPEC SPEC 3 VMS-FILENAME-CHARSET "LSP"))

(DEFMETHOD (VMS-PATHNAME-MIXIN :AROUND :PARSE-DIRECTORY-SPEC) (CONT MT ARGS IGNORE)
  (LET ((PARSED-SPEC (AROUND-METHOD-CONTINUE CONT MT ARGS)))
    (COND ((STRINGP PARSED-SPEC)
	   (VMS-PARSE-PATHNAME-COMPONENT NIL PARSED-SPEC 9. VMS-FILENAME-CHARSET
					 (PATHNAME-DIRECTORY (QUIET-USER-HOMEDIR HOST))))
	  ((CONSP PARSED-SPEC)
	   (SETQ PARSED-SPEC
		 (LOOP FOR ELT IN PARSED-SPEC
		       COLLECT
		       (VMS-PARSE-PATHNAME-COMPONENT NIL ELT 9. VMS-FILENAME-CHARSET
						     T)))
	   (IF (MEMQ T PARSED-SPEC)
	       (PATHNAME-DIRECTORY (QUIET-USER-HOMEDIR HOST))
	     PARSED-SPEC))
	  (T PARSED-SPEC))))

(COMMENT

(DEFMETHOD (VMS-PATHNAME-MIXIN :VALID-NAME-P) (NAM)
  (VMS-DEFAULT-PATHNAME-COMPONENT-TEST NAM 9.))

(DEFUN VMS-DEFAULT-PATHNAME-COMPONENT-TEST (COMPONENT SIZE)
  (OR (MEMQ COMPONENT '(NIL :UNSPECIFIC :WILD))
      (AND (STRINGP COMPONENT)
	   (NOT (STRING-SEARCH-NOT-SET VMS-FILENAME-CHARSET COMPONENT))
	   (<= (STRING-LENGTH COMPONENT) SIZE))))

(DEFMETHOD (VMS-PATHNAME-MIXIN :VALID-TYPE) (TYP)
  (IF (VMS-DEFAULT-PATHNAME-COMPONENT-TEST TYP 3.)
      TYP "TXT"))

(DEFMETHOD (VMS-PATHNAME-MIXIN :VALID-TYPE-P) (TYP)
  (VMS-DEFAULT-PATHNAME-COMPONENT-TEST TYP 3))

(DEFMETHOD (VMS-PATHNAME-MIXIN :VALID-VERSION-P) (VERS)
  (OR (MEMQ VERSION '(:WILD :NEWEST))
      (NULL VERS)
      (AND (FIXNUMP VERS) (< 0 VERS 65536))))

(DEFMETHOD (VMS-PATHNAME-MIXIN :VALID-VERSION) (VERS)
  (IF (FUNCALL-SELF ':VALID-VERSION-P VERS) VERS
    ':NEWEST)))

;;; Patch system interface, more kludges for only 9 character VMS filenames
(DEFMETHOD (VMS-PATHNAME-MIXIN :PATCH-FILE-PATHNAME) (NAM SAME-DIRECTORY-P PATOM TYP
						      &REST ARGS)
  (SELECTQ TYP
    (:SYSTEM-DIRECTORY
     (FUNCALL-SELF ':NEW-PATHNAME ':NAME (IF SAME-DIRECTORY-P PATOM NAM)
		   ':TYPE ':PATCH-DIRECTORY ':VERSION ':NEWEST))
    (:VERSION-DIRECTORY
     (FUNCALL-SELF ':NEW-PATHNAME ':NAME (WITH-OUTPUT-TO-STRING (STREAM)
					   (LET ((SNAME (IF SAME-DIRECTORY-P PATOM
							  (SI:SYSTEM-SHORT-NAME NAM))))
					     (DOTIMES (I (MIN (STRING-LENGTH SNAME) 6))
					       (FUNCALL STREAM ':TYO (AREF SNAME I))))
					   (LET ((BASE 10.) (*NOPOINT T))
					     (PRIN1 (\ (CAR ARGS) 1000.) STREAM)))
		   ':TYPE ':PATCH-DIRECTORY ':VERSION ':NEWEST))
    (:PATCH-FILE
     (FUNCALL-SELF ':NEW-PATHNAME ':NAME (FORMAT NIL "~:[~*~;~C~]~DX~D"
						 SAME-DIRECTORY-P PATOM
						 (\ (CAR ARGS) 100.)
						 (\ (CADR ARGS)
						    (IF SAME-DIRECTORY-P 100. 1000.)))
		   ':TYPE (CADDR ARGS) ':VERSION ':NEWEST))))

(DEFMETHOD (VMS-PATHNAME-MIXIN :UNDELETABLE-P) () NIL)

;;;; Unix and Multics support

(DEFFLAVOR UNIX-PATHNAME-MIXIN () (HIERARCHICAL-DIRECTORY-MIXIN MEANINGFUL-ROOT-MIXIN
				   PATHNAME-NORMALLY-LOWERCASE-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (UNIX-PATHNAME-MIXIN :CHARACTER-NEEDS-QUOTING-P) (IGNORE) ())

(DEFMETHOD (UNIX-PATHNAME-MIXIN :UNSPECIFIC-TYPE-IS-DEFAULT) () T)

(DEFMETHOD (UNIX-PATHNAME-MIXIN :DIRECTORY-PATHNAME-AS-FILE) 
	   DEFAULT-DIRECTORY-PATHNAME-AS-FILE)

(DEFMETHOD (UNIX-PATHNAME-MIXIN :DIRECTORY-FILE-TYPE) ()
  ':UNSPECIFIC)

(DEFMETHOD (UNIX-PATHNAME-MIXIN :DIRECTORY-DELIMITER-CHARACTER) () #//)

(DEFMETHOD (UNIX-PATHNAME-MIXIN :DIRECTORY-UP-DELIMITER) () "..")

(DEFUN UNIX-FILENAME (NAME TYPE &AUX (NEW-TYPE (IF TYPE TYPE "'")))
  (IF (EQ NAME ':UNSPECIFIC) (SETQ NAME ""))
  (IF (EQ NAME ':WILD)
      (IF (MEMQ TYPE '(:WILD :UNSPECIFIC)) "*"	;Both wild, just *
	(STRING-APPEND "*." NEW-TYPE))
    (IF (AND (NULL NAME) (MEMQ TYPE '(NIL :UNSPECIFIC)))
	""
      (OR NAME (SETQ NAME "'"))
      (COND ((EQ TYPE ':WILD)
	     (FORMAT NIL "~A.*" NAME))
	    ((EQ TYPE ':UNSPECIFIC)
	     NAME)
	    (T
	     (STRING-APPEND NAME "." NEW-TYPE))))))

(DEFMETHOD (UNIX-PATHNAME-MIXIN :STRING-FOR-HOST) ()
  (FORMAT NIL "~@[~A~]~A" (UNIX-DIRECTORY-STRING) (UNIX-FILENAME NAME TYPE)))

(DEFMETHOD (UNIX-PATHNAME-MIXIN :STRING-FOR-EDITOR) ()
  (FORMAT NIL "~A ~A ~A:"
	  (UNIX-FILENAME NAME TYPE) (UNIX-DIRECTORY-STRING)
	  (FUNCALL HOST ':NAME-AS-FILE-COMPUTER)))

(DEFMETHOD (UNIX-PATHNAME-MIXIN :STRING-FOR-DIRED) ()
  (UNIX-FILENAME NAME TYPE))

(DEFUN UNIX-DIRECTORY-STRING ()
  (DECLARE (:SELF-FLAVOR UNIX-PATHNAME-MIXIN))
  (IF (MEMQ DIRECTORY '(NIL :UNSPECIFIC)) NIL
      (LET ((DIRECT DIRECTORY)
	    (SUPPRESS-DELIM NIL))
	(STRING-APPEND (COND ((EQ DIRECT ':ROOT) "")
			     ((AND (LISTP DIRECT) (EQ (CAR DIRECT) ':RELATIVE))
			      (POP DIRECT)
			      "")
			     (T
			      (FUNCALL-SELF ':DIRECTORY-DELIMITER-CHARACTER)))
		       (COND ((EQ DIRECT ':ROOT) "")
			     ((ATOM DIRECT) (UNIX-DIRECTORY-COMPONENT DIRECT))
			     ((NULL (CDR DIRECT))
			      (LET (STRING)
				(MULTIPLE-VALUE (STRING SUPPRESS-DELIM)
				  (UNIX-DIRECTORY-COMPONENT (CAR DIRECT)))
				STRING))
			     (T (LOOP FOR SUBDIR IN DIRECT
				      WITH STRING = (MAKE-ARRAY 20. ':TYPE 'ART-STRING
								':LEADER-LIST '(0))
				      AS DELIM-P = NIL THEN T
				      DO (AND DELIM-P (NOT SUPPRESS-DELIM)
					      (ARRAY-PUSH-EXTEND
						STRING
						(FUNCALL-SELF
						  ':DIRECTORY-DELIMITER-CHARACTER)))
					 (LET (SUBSTR)
					   (MULTIPLE-VALUE (SUBSTR SUPPRESS-DELIM)
					     (UNIX-DIRECTORY-COMPONENT SUBDIR))
					   (SETQ STRING (STRING-NCONC STRING SUBSTR)))
				      FINALLY (RETURN STRING))))
		     (COND (SUPPRESS-DELIM "")
			   (T (FUNCALL-SELF ':DIRECTORY-DELIMITER-CHARACTER)))))))

(DEFUN UNIX-DIRECTORY-COMPONENT (STRING)
  (SELECTQ STRING
    (:WILD "*")
    (:UP (LET ((DELIM (FUNCALL-SELF ':DIRECTORY-UP-DELIMITER)))
	   (IF (STRINGP DELIM) DELIM (VALUES (STRING DELIM) T))))
    (OTHERWISE (STRING STRING))))

(DEFMETHOD (UNIX-PATHNAME-MIXIN :PARSE-NAMESTRING) (IGNORE NAMESTRING
						      &OPTIONAL (START 0) END
						      &AUX DIR NAM TYP DELIM-CHAR)
  (OR END (SETQ END (STRING-LENGTH NAMESTRING)))
  (SETQ START (OR (STRING-SEARCH-NOT-CHAR #\SP NAMESTRING START END) END))
  (SETQ DELIM-CHAR (FUNCALL-SELF ':DIRECTORY-DELIMITER-CHARACTER)
	DIR (STRING-REVERSE-SEARCH-CHAR DELIM-CHAR NAMESTRING END START)
	TYP (STRING-REVERSE-SEARCH-CHAR #/. NAMESTRING END (OR DIR START)))
  (COND (DIR
	 (PSETQ START (1+ DIR)
		DIR (LET ((RELATIVE-P T)
			  (DIR-START START)
			  (UP (FUNCALL-SELF ':DIRECTORY-UP-DELIMITER))
			  (NUP NIL)
			  (STRS NIL))
		      (COND ((= (AREF NAMESTRING DIR-START) DELIM-CHAR)
			     (SETQ RELATIVE-P NIL)
			     (SETQ DIR-START (STRING-SEARCH-NOT-CHAR
					       DELIM-CHAR NAMESTRING DIR-START))))
		      (AND DIR-START (> DIR DIR-START)
			   (SETQ STRS (LOOP FOR IDX = DIR-START THEN JDX
					    AS JDX = (STRING-SEARCH-CHAR
						       DELIM-CHAR NAMESTRING IDX DIR)
					    COLLECT (SUBSTRING NAMESTRING IDX (OR JDX DIR))
					    WHILE
					      (AND JDX
						   (SETQ JDX
							 (STRING-SEARCH-NOT-CHAR
							   DELIM-CHAR NAMESTRING JDX DIR))))))
		      (AND (STRINGP UP)
			   (DO L STRS (CDR L) (NULL L)
			     (AND (STRING-EQUAL (CAR L) UP)
				  (RPLACA L ':UP))))
		      (AND NUP (SETQ STRS (NCONC NUP STRS)))
		      (COND (RELATIVE-P (CONS ':RELATIVE STRS))
			    ((NULL STRS) ':ROOT)
			    ((NULL (CDR STRS)) (CAR STRS))
			    (T STRS))))))
  (IF (EQ TYP START) (SETQ TYP NIL))		;Initial . is part of NAM
  (IF TYP (PSETQ END TYP
		 TYP (SUBSTRING NAMESTRING (1+ TYP) END)))
  (SETQ NAM (AND ( START END) (SUBSTRING NAMESTRING START END)))
  (COND ((EQUAL NAM "'") (SETQ NAM NIL))
	((EQUAL NAM "*") (SETQ NAM ':WILD)))
  (COND ((NULL TYP) (SETQ TYP (AND NAM ':UNSPECIFIC)))
	((EQUAL TYP "'") (SETQ TYP NIL))
	((EQUAL TYP "*") (SETQ TYP ':WILD)))
  (VALUES ':UNSPECIFIC DIR NAM TYP ':UNSPECIFIC))

(DEFMETHOD (UNIX-PATHNAME-MIXIN :PARSE-DIRECTORY-SPEC) (SPEC)
  (COND ((STRINGP SPEC) (LIST (FUNCALL-SELF ':PARSE-COMPONENT-SPEC SPEC)))
	((AND (CONSP SPEC)
	      (LOOP FOR ELT IN SPEC
		    ALWAYS (OR (MEMQ ELT '(:UP :WILD :RELATIVE))
			       (STRINGP ELT)))
	      (NOT (MEMQ ':RELATIVE (CDR SPEC))))
	 (LOOP FOR ELT IN SPEC
	       COLLECT (IF (SYMBOLP ELT) ELT
			 (FUNCALL-SELF ':PARSE-COMPONENT-SPEC ELT))))
	((MEMQ SPEC '(NIL :UNSPECIFIC :WILD)) SPEC)
	(T (PATHNAME-DIRECTORY (QUIET-USER-HOMEDIR HOST)))))

;; This completely prevents any Unix pathname from having a non-:UNSPECIFIC version.
(DEFMETHOD (UNIX-PATHNAME-MIXIN :PARSE-VERSION-SPEC) (SPEC)
  (IGNORE SPEC)
  ':UNSPECIFIC)

;;; Patch system interface, more kludges for only 14 character UNIX filenames
(DEFMETHOD (UNIX-PATHNAME-MIXIN :PATCH-FILE-PATHNAME) (NAM SAME-DIRECTORY-P PATOM TYP	
					      &REST ARGS)
   (LET ((SNAME (IF SAME-DIRECTORY-P PATOM (SI:SYSTEM-SHORT-NAME NAM))))
     (IF (> (STRING-LENGTH SNAME) 6)
	 (SETQ SNAME (SUBSTRING SNAME 0 6)))
     (SELECTQ TYP
       (:SYSTEM-DIRECTORY
	(FUNCALL-SELF ':NEW-PATHNAME ':NAME SNAME ':TYPE ':PATCH-DIRECTORY
		      ':VERSION ':NEWEST))
       (:VERSION-DIRECTORY
	(FUNCALL-SELF ':NEW-PATHNAME ':NAME (FORMAT NIL "~A-~D" SNAME (\ (CAR ARGS) 10000.))
		      ':TYPE ':PATCH-DIRECTORY ':VERSION ':NEWEST))
       (:PATCH-FILE
	(FUNCALL-SELF ':NEW-PATHNAME
		      ':NAME (FORMAT NIL "~A-~D-~D"
				     (SUBSTRING SNAME 0 (MIN 3 (STRING-LENGTH SNAME)))
				     (\ (CAR ARGS) 1000.)
				     (\ (CADR ARGS) 1000.))
		      ':TYPE (CADDR ARGS) ':VERSION ':NEWEST)))))

(DEFFLAVOR MULTICS-PATHNAME-MIXIN () (UNIX-PATHNAME-MIXIN))

(DEFMETHOD (MULTICS-PATHNAME-MIXIN :DIRECTORY-DELIMITER-CHARACTER) () #/>)

(DEFMETHOD (MULTICS-PATHNAME-MIXIN :DIRECTORY-UP-DELIMITER) () #/<)

(comment
(DEFMETHOD (MULTICS-PATHNAME-MIXIN :INIT-FILE) (PROGRAM-NAME)
  (FUNCALL-SELF ':NEW-PATHNAME ':NAME PROGRAM-NAME
			       ':TYPE "INIT")))

(DEFFLAVOR LMFS-PATHNAME-MIXIN () (UNIX-PATHNAME-MIXIN))

(DEFMETHOD (LMFS-PATHNAME-MIXIN :DIRECTORY-DELIMITER-CHARACTER) () #/>)

(DEFMETHOD (LMFS-PATHNAME-MIXIN :DIRECTORY-UP-DELIMITER) () #/<)

(DEFMETHOD (LMFS-PATHNAME-MIXIN :CONVERT-TYPE-FOR-HOST) (-TYPE-)
  (STRING-OR-WILD -TYPE-))

;;;  (undefmethod (lmfs-pathname-mixin :directory))
			    

;;;; Logical pathnames

(DEFUN TRANSLATED-PATHNAME (PATHNAME)
  "Return translated pathname made from PATHNAME.
If PATHNAME refers to a logical host, the result will refer to the
corresponding physical host."
  (SEND (PATHNAME PATHNAME) ':TRANSLATED-PATHNAME))

(DEFUN BACK-TRANSLATED-PATHNAME (LOGICAL-PATHNAME ACTUAL-PATHNAME)
  "Try to untranslate ACTUAL-PATHNAME for the host of LOGICAL-PATHNAME.
If LOGICAL-PATHNAME indeed refers to a logical host, and ACTUAL-PATHNAME
is a pathname that could be produced by translation of some logical pathname
on that host, then said logical pathname is returned.
Otherwise, ACTUAL-PATHNAME is returned."
  (SEND (PATHNAME LOGICAL-PATHNAME) ':BACK-TRANSLATED-PATHNAME (PATHNAME ACTUAL-PATHNAME)))

(DEFFLAVOR LOGICAL-PATHNAME () (PATHNAME))
 
(DEFMETHOD (LOGICAL-PATHNAME :STRING-FOR-PRINTING) ()
  (LET ((DIR (STRING-OR-WILD DIRECTORY))
	(DEV (LOGICAL-DEVICE-STRING))
	(NAM (LOGICAL-NAME-STRING))
	(TYP (LOGICAL-TYPE-STRING))
	(VER (LOGICAL-VERSION-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A: ~@[~A: ~]~:[~A; ~;~*~]~@[~A~]~@[ ~A~]~@[ ~D~]"
	    (FUNCALL HOST ':NAME-AS-FILE-COMPUTER)
	    DEV
	    (MEMQ DIRECTORY '(NIL :UNSPECIFIC))
	    DIR NAM TYP VER)))

(DEFMETHOD (LOGICAL-PATHNAME :STRING-FOR-DIRECTORY) ()
  (LET ((DIR (STRING-OR-WILD DIRECTORY))
	(DEV (LOGICAL-DEVICE-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~@[~A: ~]~:[~A;~]"
	    DEV
	    (MEMQ DIRECTORY '(NIL :UNSPECIFIC))
	    DIR)))

(DEFF LOGICAL-NAME-STRING 'ITS-FN1-STRING)

(DEFUN LOGICAL-DEVICE-STRING ()
  (DECLARE (:SELF-FLAVOR LOGICAL-PATHNAME))
  (IF (MEMQ DEVICE '(NIL :UNSPECIFIC))
      NIL
    (STRING-OR-WILD DEVICE)))

(DEFUN LOGICAL-TYPE-STRING (&OPTIONAL NO-PLACEHOLDER)
  (DECLARE (:SELF-FLAVOR LOGICAL-PATHNAME))
  (COND ((EQ TYPE ':UNSPECIFIC) "")
	((NULL TYPE)
	 (AND (NOT NO-PLACEHOLDER)
	      VERSION
	      ""))
	(T
	 (STRING-OR-WILD TYPE))))

;Contrary to its name, this can also return NIL and decimal integers as well as strings
(DEFUN LOGICAL-VERSION-STRING ()
  (DECLARE (:SELF-FLAVOR LOGICAL-PATHNAME))
  (SELECTQ VERSION
    (:UNSPECIFIC "")
    (NIL NIL)
    (:NEWEST ">")
    (:OLDEST "<")
    (:WILD "*")
    (OTHERWISE VERSION)))

(DEFMETHOD (LOGICAL-PATHNAME :PARSE-NAMESTRING) (IGNORE NAMESTRING &OPTIONAL (START 0) END)
  (OR END (SETQ END (STRING-LENGTH NAMESTRING)))
  (DO ((I START)
       (J START (1+ J))
       (CH) (TEM)
       (DIR)
       (NAM) (NAMP)
       (TYP) (TYPP)
       (VERS))
      ((> J END)
       (AND TYP (STRING-EQUAL TYP "*")
	    (SETQ TYP ':WILD))
       (AND NAM (STRING-EQUAL NAM "*")
	    (SETQ NAM ':WILD))
       (AND DIR (STRING-EQUAL DIR "*")
	    (SETQ DIR ':WILD))
       (VALUES ':UNSPECIFIC DIR NAM TYP VERS))
    (SETQ CH (IF (= J END) #\SP (AREF NAMESTRING J)))
    (COND ((= CH '#/)
	   (SETQ J (1+ J)))
	  ((MEMQ CH '(#/; #/: #/ #/ #\SP #\TAB #/.))
	   (COND ((OR ( I J) (= CH #/) (= CH #/))
		  (AND (MEMQ CH '(#/ #/))
		       (OR ( I J)
			   (AND ( (1+ J) END)
				( (AREF NAMESTRING (1+ J)) #\SP)))
		       (PATHNAME-ERROR J
			       "An unquoted ~C must be a component unto itself." CH))
		  (SETQ TEM
			(SELECTQ CH
			  (#/ ':UNSPECIFIC)
			  (#/ NIL)
			  (T (UNQUOTE-LOGICAL-STRING NAMESTRING I J))))
		  (SELECTQ CH
		    (#/: NIL)   ;IGNORE "DEVICES"
		    (#/; (SETQ DIR TEM))
		    (OTHERWISE
		     (COND (VERS)
			   (TYPP (SETQ VERS (COND ((EQ TEM ':UNSPECIFIC) TEM)
						  ((STRING-EQUAL TEM ">") ':NEWEST)
						  ((STRING-EQUAL TEM "<") ':OLDEST)
						  ((STRING-EQUAL TEM "*") ':WILD)
						  ((NUMERIC-P TEM))
						  (T (PATHNAME-ERROR J
							     "Version not numeric")))))
			   (NAMP (SETQ TYP TEM TYPP T))
			   (T (SETQ NAM TEM NAMP T)))))))
	   (SETQ I (1+ J))))))

(DEFMETHOD (LOGICAL-PATHNAME :QUOTE-CHARACTER) () #/)

(DEFMETHOD (LOGICAL-PATHNAME :CHARACTER-NEEDS-QUOTING-P) (CH)
  (OR ( #/a CH #/z)
      (MEMQ CH '(#/: #/; #/ #/ #\SP #\TAB))))

(DEFUN UNQUOTE-LOGICAL-STRING (STRING &OPTIONAL (START 0) (END (STRING-LENGTH STRING)))
  (DO ((I START (1+ I))
       (NCH 0) (CH)
       (NEED-COPY NIL))
      (( I END)
       (COND ((AND (= START 0) (= I (STRING-LENGTH STRING)) (NOT NEED-COPY))
	      STRING)				;To avoid consing
	     ((NOT NEED-COPY)
	      (SUBSTRING STRING START I))
	     (T
	      (DO ((NSTRING (MAKE-ARRAY NCH ':TYPE 'ART-STRING))
		   (J 0)
		   (K START (1+ K))
		   CHAR-QUOTED
		   (CH))
		  (( K I) NSTRING)
		(SETQ CH (AREF STRING K))
		(COND (( CH #/)
		       (ASET (IF CHAR-QUOTED CH (CHAR-UPCASE CH))
			     NSTRING J)
		       (SETQ CHAR-QUOTED NIL)
		       (SETQ J (1+ J)))
		      (T (SETQ CHAR-QUOTED T)))))))
    (SETQ CH (AREF STRING I))
    (IF (= CH #/)
	(SETQ NEED-COPY T)
      (IF ( #/a CH #/z) (SETQ NEED-COPY T))
      (SETQ NCH (1+ NCH)))))

(DEFMETHOD (LOGICAL-PATHNAME :COMPLETE-STRING) (STRING OPTIONS &AUX STRING1)
  (LET ((TRANSLATED (FUNCALL (PARSE-PATHNAME STRING HOST) ':TRANSLATED-PATHNAME)))
    (SETQ STRING1 (SEND TRANSLATED ':STRING-FOR-HOST))
;    ;; This used to be just :STRING-FOR-PRINTING,
;    ;; but we want to get rid of the 's that NIL components would make.
;    (SETQ STRING1
;	  (IF (NOT (MEMQ (SEND TRANSLATED ':VERSION) '(NIL :UNSPECIFIC)))
;	      (SEND TRANSLATED ':STRING-FOR-PRINTING)
;	    (IF (SEND TRANSLATED ':TYPE)
;		(SEND (SEND TRANSLATED ':NEW-VERSION ':NEWEST) ':STRING-FOR-PRINTING)
;	      (STRING-APPEND (SEND (SEND TRANSLATED ':NEW-PATHNAME
;					 ':NAME NIL ':TYPE NIL)
;				   ':STRING-FOR-PRINTING)
;			     (SEND TRANSLATED ':NAME)))))
;    (SETQ STRING1 (SUBSTRING STRING1 (1+ (STRING-SEARCH-CHAR #/: STRING1))))
    )
  ;; What STRING1 is will match the :STRING-FOR-HOST for many kinds of pathname,
  ;; but not for all.
  (LET (BASE-PATHNAME)
    (CONDITION-CASE ()
	(SETQ BASE-PATHNAME (FUNCALL-SELF ':TRANSLATED-PATHNAME))
      (UNKNOWN-LOGICAL-DIRECTORY
       (SETQ BASE-PATHNAME
	     (FUNCALL (FUNCALL (FUNCALL-SELF ':NEW-DIRECTORY NIL) ':TRANSLATED-PATHNAME)
		      ':NEW-DIRECTORY (FUNCALL-SELF ':DIRECTORY)))))
    (FUNCALL
      (FUNCALL-SELF ':BACK-TRANSLATED-PATHNAME
		    (PARSE-PATHNAME
		      (FUNCALL BASE-PATHNAME
			       ':COMPLETE-STRING
			       STRING1
			       OPTIONS)))
      ':STRING-FOR-PRINTING)))

(DEFMETHOD (LOGICAL-PATHNAME :STRING-FOR-HOST) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :STRING-FOR-WHOLINE) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :STRING-FOR-EDITOR) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :CHANGE-PROPERTIES) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :EXPUNGE) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :OPEN) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :OPEN-CANONICAL-TYPE) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :DELETE) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :UNDELETE) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :RENAME) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :UNDELETABLE-P) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :HOMEDIR) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :MULTIPLE-FILE-PLISTS) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :PARSE-TRUENAME) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :DIRECTORY-LIST) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :DIRECTORY-LIST-STREAM) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :STRING-FOR-DIRED) LOGICAL-PATHNAME-PASS-ON)

;;; These need to be passed on since otherwise the information on how they were created
;;; will be lost.
(DEFMETHOD (LOGICAL-PATHNAME :PATCH-FILE-PATHNAME) LOGICAL-PATHNAME-PASS-ON)
(DEFMETHOD (LOGICAL-PATHNAME :NEW-TYPE-AND-VERSION) LOGICAL-PATHNAME-PASS-ON)

(DEFUN LOGICAL-PATHNAME-PASS-ON (&REST REST)
  (APPLY (FUNCALL-SELF ':TRANSLATED-PATHNAME) REST))

(DEFFLAVOR LOGICAL-HOST
	(NAME					;Logical device name
	 HOST					;Host that turns into
	 DEFAULT-DEVICE				;When not otherwise specified
	 TRANSLATIONS)				;The actual translations

  ; NON-DEFAULT-DEVICE-LIST  would record devices other than default-device for
  ; which GENERIC-PATHNAMES have been created for this host.  See discussion
  ; in PATHNM. Not implemented.  For now, if it would need this it just bombs
  ; in (method pathname :generic-pathname).
	(SI:BASIC-HOST)
  (:SETTABLE-INSTANCE-VARIABLES))

(DEFMETHOD (LOGICAL-HOST :PATHNAME-FLAVOR) () 'LOGICAL-PATHNAME)

(DEFMETHOD (LOGICAL-HOST :SYSTEM-TYPE) ()
  ':LOGICAL)

;These characteristics of a logical host are the same as those of the physical host
(DEFMETHOD (LOGICAL-HOST :NETWORK-TYPE) ()
  (FUNCALL HOST ':NETWORK-TYPE))

(DEFMETHOD (LOGICAL-HOST :NETWORK-TYPEP) (TYPE)
  (FUNCALL HOST ':NETWORK-TYPEP TYPE))

(DEFMETHOD (LOGICAL-HOST :ENABLE-CAPABILITIES) (&REST CAPABILITIES)
  (LEXPR-FUNCALL HOST ':ENABLE-CAPABILITIES CAPABILITIES))

(DEFMETHOD (LOGICAL-HOST :DISABLE-CAPABILITIES) (&REST CAPABILITIES)
  (LEXPR-FUNCALL HOST ':DISABLE-CAPABILITIES CAPABILITIES))

(DEFSTRUCT (LOGICAL-PATHNAME-TRANSLATION :LIST (:CONC-NAME TRANSLATION-))
  LOGICAL-DIRECTORY
  PHYSICAL-DEVICE
  PHYSICAL-DIRECTORY)

(COMMENT  ;This used to cause the default for a logical pathname directory
;to always be something that it knows how to translate.
;That may be a reasonable idea, but not clear it fits into new scheme of things.
(DEFMETHOD (LOGICAL-PATHNAME :VALID-DIRECTORY) (NEW-DIR)
  (LET ((TRANSLATIONS (SEND HOST ':TRANSLATIONS)))
    (COND ((ASSOC NEW-DIR TRANSLATIONS)
	   NEW-DIR)
	  ((DOLIST (TR TRANSLATIONS)
	     (IF (EQUAL NEW-DIR (TRANSLATION-PHYSICAL-DIRECTORY TR))
		 (RETURN (TRANSLATION-LOGICAL-DIRECTORY TR)))))
	  (T NIL)))))

(DEFMETHOD (LOGICAL-HOST :LOGICALLY-BACKTRANSLATE-HOST-DEV-DIR)
	   (PHYSICAL-HOST PHYSICAL-DEVICE PHYSICAL-DIRECTORY)
  (IF (OR (EQ PHYSICAL-HOST HOST)
	  (EQ PHYSICAL-HOST SELF))	;SYS:LISPM; sort of things.
      (LOOP FOR TRANS IN TRANSLATIONS 
	    DO (COND ((AND (OR (MEMQ PHYSICAL-DEVICE '(NIL :UNSPECIFIC))
			       (OR (EQUAL PHYSICAL-DEVICE
					  (TRANSLATION-PHYSICAL-DEVICE TRANS))
				   (EQUAL PHYSICAL-DEVICE
					  DEFAULT-DEVICE))
;Should be this, but preceding eases transition.
;			       (STRING-EQUAL PHYSICAL-DEVICE
;					     (OR (TRANSLATION-PHYSICAL-DEVICE TRANS)
;						 DEFAULT-DEVICE))
			       )
			   (EQUAL PHYSICAL-DIRECTORY
				  (TRANSLATION-PHYSICAL-DIRECTORY TRANS)))
		      (RETURN (VALUES SELF
				      ':UNSPECIFIC
				      (TRANSLATION-LOGICAL-DIRECTORY TRANS)))))
	    FINALLY (RETURN
		      (IF (AND (EQ PHYSICAL-HOST SELF)
			       (NOT (ASSOC PHYSICAL-DIRECTORY TRANSLATIONS)))
			  ;; SYS:RG; should backtranslate to AI:DSK:RG;
			  (VALUES HOST
				  (COND ((MEMQ PHYSICAL-DEVICE '(NIL :UNSPECIFIC))
					 DEFAULT-DEVICE)
					(T PHYSICAL-DEVICE))
				  PHYSICAL-DIRECTORY))))))

(DEFUN BACKTRANSLATE-HOST-DIRECTORY (PHYSICAL-HOST PHYSICAL-DEVICE PHYSICAL-DIRECTORY)
  (DO ((HE *PATHNAME-HOST-LIST* (CDR HE))
       TRANS-HOST TRANS-DEVICE TRANS-DIRECTORY)
      ((NULL HE))
    (MULTIPLE-VALUE (TRANS-HOST TRANS-DEVICE TRANS-DIRECTORY)
      (FUNCALL (CAR HE) ':LOGICALLY-BACKTRANSLATE-HOST-DEV-DIR
	       PHYSICAL-HOST PHYSICAL-DEVICE PHYSICAL-DIRECTORY))
    (IF TRANS-HOST
	(RETURN (VALUES TRANS-HOST TRANS-DEVICE TRANS-DIRECTORY)))))

(DEFFLAVOR UNKNOWN-LOGICAL-DIRECTORY-ERROR () (PATHNAME-ERROR))

(DEFSIGNAL UNKNOWN-LOGICAL-DIRECTORY UNKNOWN-LOGICAL-DIRECTORY-ERROR (LOGICAL-DIRECTORY)
  "Used when a logical pathname's directory is not recognized for that host.")

(DEFMETHOD (UNKNOWN-LOGICAL-DIRECTORY-ERROR :CASE :PROCEED-ASKING-USER :NEW-LOGICAL-DIRECTORY)
	   (PROCEED-FUN READ-OBJECT-FUN)
  "Proceed, reading a logical directory to use instead this time."
  (FUNCALL PROCEED-FUN ':NEW-LOGICAL-DIRECTORY
	   (FUNCALL READ-OBJECT-FUN ':STRING
		    "Logical directory to use instead: ")))

(DEFMETHOD (UNKNOWN-LOGICAL-DIRECTORY-ERROR :CASE :PROCEED-ASKING-USER :NEW-DIRECTORY)
	   (PROCEED-FUN READ-OBJECT-FUN)
  "Proceed, reading a physical device//directory to use this time."
  (FUNCALL PROCEED-FUN ':NEW-DIRECTORY
	   (FUNCALL READ-OBJECT-FUN ':STRING
		    "Physical device//directory to use: ")))

(DEFMETHOD (UNKNOWN-LOGICAL-DIRECTORY-ERROR :CASE :PROCEED-ASKING-USER :NEW-TRANSLATION)
	   (PROCEED-FUN READ-OBJECT-FUN)
  "Proceed, reading a physical device//directory to translate this to, permanently."
  (FUNCALL PROCEED-FUN ':NEW-TRANSLATION
	   (FUNCALL READ-OBJECT-FUN ':STRING
		    "Device//directory to translate ~A to, permanently: "
		    (SEND SELF ':LOGICAL-DIRECTORY))))

(COMPILE-FLAVOR-METHODS UNKNOWN-LOGICAL-DIRECTORY-ERROR)

(DEFMETHOD (LOGICAL-PATHNAME :TRANSLATED-PATHNAME) (&AUX TRANS NEW-HOST DEV DIR PATH)
  (SETQ NEW-HOST (FUNCALL HOST ':HOST))
  (IF (NULL DIRECTORY)
      (SEND SELF ':NEW-PATHNAME ':HOST NEW-HOST ':DEVICE NIL)
    (DO ()
	((SETQ TRANS (ASSOC DIRECTORY (FUNCALL HOST ':TRANSLATIONS)))
	 (SETQ DEV (OR (TRANSLATION-PHYSICAL-DEVICE TRANS)
		       (FUNCALL HOST ':DEFAULT-DEVICE))
	       DIR (TRANSLATION-PHYSICAL-DIRECTORY TRANS))
	 (SETQ PATH (MAKE-PATHNAME ':HOST NEW-HOST ':DEVICE DEV ':DIRECTORY DIR
				   ':NAME NAME
				   ':TYPE (SEND SELF ':CANONICAL-TYPE)
				   ':VERSION VERSION)))
      (SIGNAL-PROCEED-CASE ((NEWDIR)
			    'UNKNOWN-LOGICAL-DIRECTORY
			    "No translation for directory ~A on host ~A."
			    DIRECTORY (SEND HOST ':NAME))
	(:NEW-LOGICAL-DIRECTORY
	 (SETQ DIRECTORY NEWDIR))
	(:NEW-DIRECTORY
	 (LET ((PN (PARSE-PATHNAME NEWDIR NEW-HOST)))
	   (RETURN (SEND PN ':NEW-PATHNAME
			 ':DEVICE (OR (SEND PN ':DEVICE) (SEND HOST ':DEFAULT-DEVICE))
			 ':NAME NAME ':TYPE (SEND SELF ':CANONICAL-TYPE) ':VERSION VERSION))))
	(:NEW-TRANSLATION
	 (CHANGE-LOGICAL-PATHNAME-DIRECTORY HOST DIRECTORY NEWDIR))))))

(DEFMETHOD (LOGICAL-PATHNAME :DIRECTORY-TRANSLATABLE-P) (&AUX TRANS)
  (SETQ TRANS (ASSOC DIRECTORY (FUNCALL HOST ':TRANSLATIONS)))
  (IF TRANS
      (VALUES
	(TRANSLATION-PHYSICAL-DIRECTORY TRANS)
	(TRANSLATION-PHYSICAL-DEVICE TRANS))))

(DEFMETHOD (LOGICAL-PATHNAME :BACK-TRANSLATED-PATHNAME) (PATHNAME &AUX DEV DIR DEFDEV)
  (SETQ DEV (FUNCALL PATHNAME ':DEVICE)
	DIR (FUNCALL PATHNAME ':DIRECTORY)
	DEFDEV (FUNCALL HOST ':DEFAULT-DEVICE))
  (DOLIST (TRANS (FUNCALL HOST ':TRANSLATIONS))
    (AND (EQUAL (OR (TRANSLATION-PHYSICAL-DEVICE TRANS) DEFDEV) DEV)
	 (EQUAL (TRANSLATION-PHYSICAL-DIRECTORY TRANS) DIR)
	 (RETURN (SETQ DEV ':UNSPECIFIC
		       DIR (TRANSLATION-LOGICAL-DIRECTORY TRANS)))))
  (FUNCALL PATHNAME ':NEW-PATHNAME ':HOST HOST ':DEVICE DEV ':DIRECTORY DIR
	   ':TYPE (SEND PATHNAME ':CANONICAL-TYPE)))

(DEFUN ADD-LOGICAL-PATHNAME-HOST (LOGICAL-HOST PHYSICAL-HOST TRANSLATIONS
				  &OPTIONAL DEFAULT-DEVICE
				  &AUX LOG OLD DEFDEV)
  "Define a logical host named LOGICAL-HOST, which translates to PHYSICAL-HOST.
TRANSLATIONS specifies the directory translations to use: each element looks like
 (logical-dir physical-dir), where logical-dir is just a string containing the
 directory name to translate, and physical-dir contains a directory and optionally
 a device, complete with delimiters as appropriate for PHYSICAL-HOST to parse.
An element in TRANSLATIONS that has NIL instead of a logical-dir specifies
the default device, to be used as the device when translating directories
that are not mentioned in TRANSLATIONS.
DEFAULT-DEVICE can be used to override the default device found in the translations."
  (IF (SETQ LOG (GET-PATHNAME-HOST LOGICAL-HOST T))
      (SETQ OLD T)
      (PUSH (SETQ LOG (MAKE-INSTANCE 'LOGICAL-HOST ':NAME LOGICAL-HOST))
	    *PATHNAME-HOST-LIST*))
  (SETQ PHYSICAL-HOST (OR (GET-PATHNAME-HOST PHYSICAL-HOST T) (SI:PARSE-HOST PHYSICAL-HOST)))
  ;; Here is a bit of a kludge for SI:SET-SITE.  If the physical host is not defined yet,
  ;; add it now.
  (OR (MEMQ PHYSICAL-HOST *PATHNAME-HOST-LIST*)
      (PUSH PHYSICAL-HOST *PATHNAME-HOST-LIST*))
  (FUNCALL LOG ':SET-HOST PHYSICAL-HOST)
  (IF TRANSLATIONS
      (FUNCALL LOG ':SET-TRANSLATIONS
	       (LOOP FOR (LOGICAL-DIRECTORY PHYSICAL-DIRECTORY) IN TRANSLATIONS
		     WITH DEVICE AND DIRECTORY
		     DO (LET ((PN (PARSE-PATHNAME PHYSICAL-DIRECTORY PHYSICAL-HOST)))
			  (SETQ DIRECTORY (PATHNAME-DIRECTORY PN))
			  (SETQ DEVICE (PATHNAME-DEVICE PN)))
		     WHEN (AND LOGICAL-DIRECTORY (MEMQ DIRECTORY '(NIL :UNSPECIFIC)))
		     DO (FERROR NIL
	"No directory specified in ~A, you probably forgot some delimiter characters."
				PHYSICAL-DIRECTORY)
		     ;; A translation for logical directory NIL specifies the default device.
		     WHEN (NULL LOGICAL-DIRECTORY)
		     DO (SETQ DEFDEV DEVICE)
		     ;; Default the default directory to the host's primary device.
		     WHEN (NULL DEFDEV)
		     DO (SETQ DEFDEV
			      (FUNCALL (SAMPLE-PATHNAME PHYSICAL-HOST) ':PRIMARY-DEVICE))
		     WHEN LOGICAL-DIRECTORY
		     COLLECT (MAKE-LOGICAL-PATHNAME-TRANSLATION
			       LOGICAL-DIRECTORY LOGICAL-DIRECTORY
			       PHYSICAL-DEVICE DEVICE
			       PHYSICAL-DIRECTORY DIRECTORY))))
  (FUNCALL LOG ':SET-DEFAULT-DEVICE (OR DEFAULT-DEVICE DEFDEV))
  LOG)

(COMMENT
(DEFUN CHANGE-LOGICAL-PATHNAME-HOST (LOGICAL-HOST PHYSICAL-HOST &AUX LOG)
  ;; Get the host instances for the logical and physical hosts.  They are both
  ;; pathname hosts, except that in the case of the physical host we may not
  ;; have learned that yet.
  (SETQ LOG (GET-PATHNAME-HOST LOGICAL-HOST))
  (SETQ PHYSICAL-HOST (OR (GET-PATHNAME-HOST PHYSICAL-HOST T) (SI:PARSE-HOST PHYSICAL-HOST)))
  (FUNCALL LOG ':SET-HOST PHYSICAL-HOST)
  ;; Here is a bit of a kludge for SI:SET-SITE.  If the physical host is not defined yet,
  ;; add it now.
  (OR (MEMQ PHYSICAL-HOST *PATHNAME-HOST-LIST*)
      (PUSH PHYSICAL-HOST *PATHNAME-HOST-LIST*))))

(DEFUN CHANGE-LOGICAL-PATHNAME-DIRECTORY (LOGICAL-HOST LOGICAL-DIRECTORY PHYSICAL-DIRECTORY
					  &AUX LOG PHYSICAL-HOST DEVICE DIRECTORY TRAN)
  (SETQ LOGICAL-DIRECTORY (STRING-UPCASE LOGICAL-DIRECTORY))
  (SETQ LOG (GET-PATHNAME-HOST LOGICAL-HOST))
  (SETQ PHYSICAL-HOST (FUNCALL LOG ':HOST))
  (LET ((PN (PARSE-PATHNAME PHYSICAL-DIRECTORY PHYSICAL-HOST)))
    (SETQ DIRECTORY (PATHNAME-DIRECTORY PN))
    (SETQ DEVICE (PATHNAME-DEVICE PN)))
  (AND (MEMQ DIRECTORY '(NIL :UNSPECIFIC))
       (FERROR NIL
  "No directory specified in ~A, you probably forgot some delimiter characters."
	       PHYSICAL-DIRECTORY))
  (IF (NULL (SETQ TRAN (ASSOC LOGICAL-DIRECTORY (FUNCALL LOG ':TRANSLATIONS))))
      (PUSH (MAKE-LOGICAL-PATHNAME-TRANSLATION
	      LOGICAL-DIRECTORY LOGICAL-DIRECTORY
	      PHYSICAL-DEVICE DEVICE
	      PHYSICAL-DIRECTORY DIRECTORY)
	    (FUNCALL LOG ':TRANSLATIONS))
      (SETF (TRANSLATION-PHYSICAL-DEVICE TRAN) DEVICE)
      (SETF (TRANSLATION-PHYSICAL-DIRECTORY TRAN) DIRECTORY)))

;;;; Kludges for bootstrapping from a world without flavors loaded.
(DEFUN CANONICALIZE-COLD-LOAD-PATHNAMES (&AUX SYS-PATHNAME PHYS-PATHNAME)
  (DECLARE (SPECIAL SYS-PATHNAME PHYS-PATHNAME))
  ;; Get someone who can do the translations
  (SETQ SYS-PATHNAME (SAMPLE-PATHNAME "SYS")
	PHYS-PATHNAME (FUNCALL SYS-PATHNAME ':TRANSLATED-PATHNAME))
  ;; Make pathnames for all files initially loaded, and setup their properties
  (DOLIST (ELEM SI:*COLD-LOADED-FILE-PROPERTY-LISTS*)
    (LET* ((PATHNAME (FUNCALL SYS-PATHNAME ':BACK-TRANSLATED-PATHNAME
			      (MERGE-PATHNAME-DEFAULTS (CAR ELEM) PHYS-PATHNAME)))
	   (GENERIC-PATHNAME (FUNCALL PATHNAME ':GENERIC-PATHNAME)))
      (DO L (CDR ELEM) (CDDR L) (NULL L)
	(LET ((PROP (INTERN (CAR L) ""))
	      (VAL (CADR L)))
	  ;;Cold load generator does not know how to put in instances, it makes
	  ;;strings instead.  Also, during MINI loading, calls to MAKE-PATHNAME-INTERNAL
	  ;;are saved just as lists.  Note: we do not back translate this pathname, so
	  ;;that we really remember the machine it was compiled on.
	  (COND ((EQ PROP ':QFASL-SOURCE-FILE-UNIQUE-ID)
		 (COND ((STRINGP VAL)
			(SETQ VAL (PARSE-PATHNAME VAL)))
		       ((CONSP VAL)
			;; Don't bomb out if host isn't defined.
			(SETF (CAR VAL)
			      (OR (GET-PATHNAME-HOST (CAR VAL) T)
				  (FUNCALL SYS-PATHNAME ':HOST)))
			;; Symbols like UNSPECIFIC may be in the wrong package
			(DO L (CDR VAL) (CDR L) (NULL L)
			    (AND (SYMBOLP (CAR L))
				 (SETF (CAR L) (INTERN (GET-PNAME (CAR L)) ""))))
			(SETQ VAL (APPLY #'MAKE-PATHNAME-INTERNAL VAL)))))
		((EQ PROP ':FILE-ID-PACKAGE-ALIST)
		 ;; Kludge, built before there are packages
		 (SETF (CAAR VAL) (PKG-FIND-PACKAGE
				    (OR (CAAR VAL)
					SI:PKG-SYSTEM-INTERNALS-PACKAGE)))
		 ;; And before there are truenames
		 (LET ((INFO (CADAR VAL)))
		   (AND (STRINGP (CAR INFO))
			(RPLACA INFO (MERGE-PATHNAME-DEFAULTS (CAR INFO) PHYS-PATHNAME)))))
		((EQ PROP ':DEFINITIONS)
		 (COND ((OR (NULL VAL)
			    (SYMBOLP (CAR VAL)))
			;; The cold load maker doesn't put anything in saying what package,
			;; so just cons on SI.
			(SETQ VAL (LIST (CONS SI:PKG-SYSTEM-INTERNALS-PACKAGE (CADR L)))))
		       (T
			;; Kludge, built before there are packages
			(SETF (CAAR VAL)
			      (PKG-FIND-PACKAGE (OR (CAAR VAL)
						    SI:PKG-SYSTEM-INTERNALS-PACKAGE)))))))
	  (FUNCALL GENERIC-PATHNAME ':PUTPROP VAL PROP)))))
  ;; Replace all strings saved on symbols with pathnames
  (DOLIST (PKG *ALL-PACKAGES*)
    (MAPATOMS #'(LAMBDA (SYMBOL &AUX NAME)
		  (AND (SETQ NAME (GET SYMBOL ':SOURCE-FILE-NAME))
		       (NOT (TYPEP NAME 'PATHNAME))
		       (PUTPROP SYMBOL (CANONICALIZE-SOURCE-FILE-NAME-PROPERTY NAME)
				':SOURCE-FILE-NAME))
		  (AND (SETQ NAME (GET SYMBOL 'SPECIAL))
		       (STRINGP NAME)
		       (PUTPROP SYMBOL (CANONICALIZE-SOURCE-FILE-NAME-PROPERTY-1 NAME)
				'SPECIAL))
		  (AND (GET SYMBOL 'SI:INITIALIZATION-LIST)
		       (DOLIST (INIT (SYMEVAL SYMBOL))
			 (AND (SI:INIT-SOURCE-FILE INIT)
			      (SETF (SI:INIT-SOURCE-FILE INIT)
				    (CANONICALIZE-SOURCE-FILE-NAME-PROPERTY-1
				      (SI:INIT-SOURCE-FILE INIT)))))))
	      PKG NIL))
  ;; Store source file names from the cold load
  (SETQ SI:FUNCTION-SPEC-HASH-TABLE (MAKE-EQUAL-HASH-TABLE))
  (DOLIST (ELEM SI:COLD-LOAD-FUNCTION-PROPERTY-LISTS)
    (SI:FUNCTION-SPEC-PUTPROP (FIRST ELEM)
			      (IF (EQ (SECOND ELEM) ':SOURCE-FILE-NAME)
				  (CANONICALIZE-SOURCE-FILE-NAME-PROPERTY (THIRD ELEM))
				  (THIRD ELEM))
			      (SECOND ELEM)))
  (DOLIST (FLAVOR SI:*ALL-FLAVOR-NAMES*)
    (LET ((FL (GET FLAVOR 'SI:FLAVOR)))
      (LOOP FOR METH IN (SI:FLAVOR-METHOD-TABLE FL)
	    DO (LOOP FOR METH1 IN (CDDDR METH)
		     AS PL = (CADDR METH1)
		     AS X = (GETL (LOCF PL) '(:SOURCE-FILE-NAME))
		     WHEN X
		     DO (SETF (CADR X) (CANONICALIZE-SOURCE-FILE-NAME-PROPERTY (CADR X)))))
      (LET ((PROP (GETL (LOCF (SI:FLAVOR-PLIST FL)
			      )
			'(:COMPILE-FLAVOR-METHODS))))
	(AND PROP (STRINGP (CADR PROP))
	     (SETF (CADR PROP) (CANONICALIZE-SOURCE-FILE-NAME-PROPERTY-1 (CADR PROP)))))))
  )

(DEFUN PATHNAME-FROM-COLD-LOAD-PATHLIST (PATHLIST)
  ;; Don't bomb out if host isn't defined.
  (SETF (CAR PATHLIST)
	(OR (GET-PATHNAME-HOST (CAR PATHLIST) T)
	    (FUNCALL (SAMPLE-PATHNAME "SYS") ':HOST)))
  ;; Symbols like UNSPECIFIC may be in the wrong package
  (DO L (CDR PATHLIST) (CDR L) (NULL L)
      (AND (SYMBOLP (CAR L))
	   (SETF (CAR L) (INTERN (GET-PNAME (CAR L)) ""))))
  (APPLY #'MAKE-PATHNAME-INTERNAL PATHLIST))


(DEFUN CANONICALIZE-SOURCE-FILE-NAME-PROPERTY (PROPERTY)
  (IF (ATOM PROPERTY)
      (CANONICALIZE-SOURCE-FILE-NAME-PROPERTY-1 PROPERTY)
      (DOLIST (TYPE PROPERTY)
	(DO L (CDR TYPE) (CDR L) (NULL L)
	  (RPLACA L (CANONICALIZE-SOURCE-FILE-NAME-PROPERTY-1 (CAR L)))))
      PROPERTY))

(DEFUN CANONICALIZE-SOURCE-FILE-NAME-PROPERTY-1 (NAME)
  (DECLARE (SPECIAL SYS-PATHNAME PHYS-PATHNAME))
  (FUNCALL (FUNCALL SYS-PATHNAME ':BACK-TRANSLATED-PATHNAME
		    (MERGE-PATHNAME-DEFAULTS NAME PHYS-PATHNAME))
	   ':GENERIC-PATHNAME))

;;; Called when the time parser comes in, canonicalize times made before then
(DEFUN CANONICALIZE-COLD-LOADED-TIMES ()
  (MAPHASH-EQUAL #'(LAMBDA (IGNORE VAL &AUX ALIST)
		     (AND (SETQ ALIST (GET-FROM-ALTERNATING-LIST (PATHNAME-PROPERTY-LIST VAL)
					   ':FILE-ID-PACKAGE-ALIST))
			  (DOLIST (ID ALIST)
			    (LET ((INFO (CADR ID)))
			      (AND (STRINGP (CDR INFO))
				   (RPLACD INFO
					   (PARSE-DIRECTORY-DATE-PROPERTY (CDR INFO) 0)))))))
		 *PATHNAME-HASH-TABLE*))


;;;; Initializations

(COMPILE-FLAVOR-METHODS LOGICAL-PATHNAME LOGICAL-HOST)

;;; This would be an initialization, except that this file is loaded too early.
;;; It is called from RESET-NON-SITE-HOSTS, which is an initialization.
(DEFUN DEFINE-SYS-LOGICAL-DEVICE (&OPTIONAL (SYS-HOST-NAME (SI:GET-SITE-OPTION ':SYS-HOST))
				  DEFAULT-DIRECTORY)
  (LET ((SYS-HOST (ADD-LOGICAL-PATHNAME-HOST
		    "SYS" SYS-HOST-NAME
		    (LET ((TRANSL-ALIST (SI:GET-SITE-OPTION ':SYS-HOST-TRANSLATION-ALIST)))
		      ;; Does this particular sys-host have a specified set of translations?
		      (OR (DOLIST (ELT TRANSL-ALIST)
			    (IF (EQ (GET-PATHNAME-HOST (CAR ELT) T)
				    (GET-PATHNAME-HOST SYS-HOST-NAME T))
				(RETURN (SYMEVAL (CDR ELT)))))
			  ;; This is the default for random hosts.
			  (SYMEVAL (CDR (ASSQ NIL TRANSL-ALIST)))))
		    DEFAULT-DIRECTORY)))
    (FUNCALL (FUNCALL SYS-HOST ':HOST) ':SEND-IF-HANDLES ':SET-SITE SI:SITE-NAME)))

;; Partially special-case hack for converting all the :file-id-package-alist pathnames
;; when the system directories are moved.

(defvar fix-loaded-pathnames-old-translations)

(defvar fix-loaded-pathnames-host)

(defun fix-loaded-pathnames (fix-loaded-pathnames-host old-translation-alist)
  (setq fix-loaded-pathnames-host (get-pathname-host fix-loaded-pathnames-host))
  (setq fix-loaded-pathnames-old-translations
	(mapcar #'(lambda (transl) (cons (car transl)
					 (substring (cadr transl) 1
						    (1- (string-length (cadr transl))))))
		old-translation-alist))
  (maphash 'fix-loaded-pathnames-1 *pathname-hash-table*))

(defun fix-loaded-pathnames-1 (ignore pathname)
  (let ((prop (send pathname ':get ':file-id-package-alist)))
    (dolist (elt prop)
      (if (eq (send (caadr elt) ':host) fix-loaded-pathnames-host)
	  (let ((new-dir (rassoc (send (caadr elt) ':directory)
				 fix-loaded-pathnames-old-translations)))
	    (if new-dir
		(setf (caadr elt)
		      (send (caadr elt) ':new-pathname
			    ':device "SRC"
			    ':directory
			    (list "L" (car new-dir))))))))))

