;;-*- Mode:LISP; Package:SYSTEM-INTERNALS; Base:8 -*-
;	** (c) Copyright 1980 Massachusetts Institute of Technology **

;; NOTE: These macros make no attempt to preserve order of evaluation,
;; or number of times evaluation, in the reference being expanded.
;; The caller should not depend on such things.

(DEFUN SETF MACRO (X)
       "Set the value specified by ACCESSOR to VALUE.
That is, executing ACCESSOR after this is done will return VALUE.
For example, (SETF (CAR A) 5) would store 5 in the car of A's value."
       (DECLARE (ARGLIST ACCESSOR VALUE &REST ACCESSOR-VALUE-PAIRS))
       (SETF-1 X))

(DEFUN SETF-1 (X)
    (OR (oddp (length x)) ;(= (LENGTH X) 3)
	(ERROR "SETF called with wrong number of arguments" X))
    (DO ((ARGLIST (CDR X) (CDDR ARGLIST))
	 (RESULT NIL))
	((NULL ARGLIST)
	 (IF (= (LENGTH RESULT) 1) (CAR RESULT)
	   (CONS 'PROGN (NREVERSE RESULT))))
      (SETQ RESULT
	    (CONS
	      (DO ((REF (CAR ARGLIST)) (VAL (CADR ARGLIST)) (FCN)) (NIL)
		(COND ((SYMBOLP REF)		;SPECIAL CASE NEEDED.
		       (RETURN (LIST 'SETQ REF VAL)))
		      ((NOT (SYMBOLP (CAR REF)))
		       (FERROR NIL "~S non-symbolic function in SETF" (CAR REF)))
		      ((SETQ FCN (GETDECL (CAR REF) 'SETF))
		       (RETURN (LOCF-APPLY FCN REF T VAL)))
		      ((SETQ FCN (GETDECL (CAR REF) 'SETF-EXPANDER))
		       (SETQ REF (LOCF-APPLY FCN REF NIL NIL)))
		      #Q ((IF-FOR-LISPM (AND (FBOUNDP (CAR REF))
					     (ARRAYP (FSYMEVAL (CAR REF)))))
			  (RETURN `(STORE ,REF ,VAL)));IF-FOR-LISPM prevents compiler warning
		      #Q ((IF-FOR-LISPM (AND (FBOUNDP (CAR REF))
					     (SYMBOLP (FSYMEVAL (CAR REF)))))
			  (RETURN `(SETF (,(FSYMEVAL (CAR REF)) . ,(CDR REF)) ,VAL)))
		      ((NOT (EQ REF (SETQ REF (LEXPR-FUNCALL 'MACROEXPAND-1 REF
							     *MACROEXPAND-ENVIRONMENT*)))))
		      (T (SETF-ERROR (CAR arglist) 'SYS:UNKNOWN-SETF-REFERENCE
				     "No SETF property found for"))))
	      RESULT))))

(IF-IN-LISPM
(DEFPROP SETF-ERROR T :ERROR-REPORTER)

(DEFUN SETF-ERROR (FORM CONDITION ERROR-MESSAGE)
  (ERROR CONDITION "~1G~A ~0G~S" FORM ERROR-MESSAGE)))

(IF-IN-MACLISP
(DEFUN SETF-ERROR (FORM CONDITION ERROR-MESSAGE)
  (ERROR ERROR-MESSAGE FORM)))

(DEFUN LOCF MACRO (X)
       "Return a locative pointer to the place where ACCESSOR's value is stored."
       (DECLARE (ARGLIST ACCESSOR))
       (LOCF-1 X))

(DEFUN LOCF-1 (X)
    (OR (= (LENGTH X) 2)
	(ERROR "LOCF called with wrong number of arguments" X))
    (DO ((REF (CADR X)) (FCN)) (NIL)
       (COND ((SYMBOLP REF)			;SPECIAL CASE NEEDED.
	      (RETURN `(VARIABLE-LOCATION ,REF)))
	     ((NOT (SYMBOLP (CAR REF)))
	      (FERROR NIL "~S non-symbolic function in LOCF" (CAR REF)))
	     ((SETQ FCN (GETDECL (CAR REF) 'LOCF))
	      (RETURN (LOCF-APPLY FCN REF NIL NIL)))
	     ((SETQ FCN (GETDECL (CAR REF) 'SETF-EXPANDER))
	      (SETQ REF (LOCF-APPLY FCN REF NIL NIL)))
	  #Q ((IF-FOR-LISPM (AND (FBOUNDP (CAR REF)) (ARRAYP (FSYMEVAL (CAR REF)))))
	      (RETURN `(ALOC #',(CAR REF) . ,(CDR REF)))) ;IF-FOR-LISPM prevents warning
	  #Q ((IF-FOR-LISPM (AND (FBOUNDP (CAR REF)) (SYMBOLP (FSYMEVAL (CAR REF)))))
	      (RETURN `(LOCF (,(FSYMEVAL (CAR REF)) . ,(CDR REF)))))
	     ((NOT (EQ REF (SETQ REF (LEXPR-FUNCALL 'MACROEXPAND-1 REF
						    *MACROEXPAND-ENVIRONMENT*)))))
	     (T (SETF-ERROR X 'SYS:UNKNOWN-LOCF-REFERENCE
			    "No LOCF property found, can't work.")))))

(DEFUN LOCF-APPLY (FCN REF VAL-P VAL)
    (COND ((OR (ATOM FCN) (MEMQ (CAR FCN) FUNCTION-START-SYMBOLS))
	   (COND (VAL-P (FUNCALL FCN REF VAL))
		 (T (FUNCALL FCN REF))))
	  (T (DO ((PATTERN (CDAR FCN) (CDR PATTERN))
		  (REF (CDR REF) (CDR REF))
		  (SUBS
		     (AND VAL-P (LIST (CONS 'VAL VAL)))
		     (CONS (CONS (CAR PATTERN) (CAR REF)) SUBS)))
		 ((OR (ATOM PATTERN) (ATOM REF))
		  (COND ((AND (ATOM PATTERN) (NOT (NULL PATTERN)))
			 (PUSH (CONS PATTERN REF) SUBS))
			((OR PATTERN REF)
			 (ERROR "Reference not same length as pattern - LOCF or SETF" REF)))
		  (SUBLIS SUBS (CDR FCN)))))))

;(GET-LIST-POINTER-INTO-STRUCT (element pntr))

(DEFUN GET-LIST-POINTER-INTO-STRUCT MACRO (X)
  (PROG (REF)
    (SETQ REF (LEXPR-FUNCALL 'MACROEXPAND (CADR X)	;EXPAND MACROS LOOKING AT BAG-BITING MACRO LIST
			     *MACROEXPAND-ENVIRONMENT*))
    (COND ((EQ (CAR REF) 'AR-1)
	   (RETURN (LIST 'GET-LIST-POINTER-INTO-ARRAY
			 (LIST 'FUNCALL (CADR REF) (CADDR REF)))))
	  ((ERROR "LOSES - GET-LIST-POINTER-INTO-STRUCT" X)))))

(DEFMACRO INCF (REFERENCE &OPTIONAL AMOUNT)
  "Increment the value of REFERENCE by AMOUNT.
The value of REFERENCE is changed.  (INCF (CAR X) 4) modifies the car of X."
  (IF (NULL AMOUNT)
      `(SETF ,REFERENCE (1+ ,REFERENCE))
      `(SETF ,REFERENCE (+ ,REFERENCE ,AMOUNT))))

(DEFMACRO DECF (REFERENCE &OPTIONAL AMOUNT)
  "Decrement the value of REFERENCE by AMOUNT.
The value of REFERENCE is changed.  (DECF (CAR X) 4) modifies the car of X."
  (IF (NULL AMOUNT)
      `(SETF ,REFERENCE (1- ,REFERENCE))
      `(SETF ,REFERENCE (- ,REFERENCE ,AMOUNT))))

(DEFMACRO SWAPF (A B)
  `(SETF ,A (PROG1 ,B (SETF ,B ,A))))

(DEFUN UNSETFABLE (REF VAL)
  (SETF-ERROR REF 'SYS:UNKNOWN-SETF-REFERENCE
	      "SETF is explicitly forbidden on "))

(DEFUN UNLOCFABLE (REF)
  (SETF-ERROR REF 'SYS:UNKNOWN-LOCF-REFERENCE
	      "LOCF is explicitly forbidden on "))

;Load time defprops for SETF and LOCF.
;Value of the SETF property is either an symbol which is a function
; which is applied to two arguments: the reference and the value 
; to be stored into it, or it is CONS of a 1-level pattern to
; match against REF and a form in which substitutions
; are made for the symbol VAL and the pattern atoms.
;The value of the LOCF property is very similar; if it is
;a symbol then it is a function to be applied to one argument,
;the reference.  Otherwise it is a pattern as in SETF, except
;that the symbol VAL is not special.

;A SETF-EXPANDER property looks like a LOCF property,
;but instead of telling how to get the location of the value
;it gives another expression for the same value.
;The idea is that that expression will be amenable to SETF/LOCF.

;;; (DEFPROP AREF ((AREF ARRAY . SUBSCRIPTS)
;;;                 ASET VAL ARRAY . SUBSCRIPTS) SETF)
;;; (DEFPROP AREF ((AREF ARRAY . SUBSCRIPTS)
;;;                 ALOC ARRAY . SUBSCRIPTS) LOCF)

(DEFPROP AREF AREF-SETF SETF)
(DEFUN AREF-SETF (REF VAL)
    `(SET-AREF ,@(CDR REF) ,VAL))
(DEFPROP AREF AREF-LOCF LOCF)
(DEFUN AREF-LOCF (REF)
    `(ALOC . ,(CDR REF)))

(DEFPROP AR-1 ((AR-1 ARRAY INDEX)
	       SET-AR-1 ARRAY INDEX VAL) SETF)
(DEFPROP AR-1 ((AR-1 ARRAY INDEX)
	       AP-1 ARRAY INDEX) LOCF)

(DEFPROP AR-1-FORCE ((AR-1-FORCE ARRAY INDEX)
		     SET-AR-1-FORCE ARRAY INDEX VAL) SETF)
(DEFPROP AR-1-FORCE ((AR-1-FORCE ARRAY INDEX)
		     AP-1-FORCE ARRAY INDEX) LOCF)

(DEFPROP AR-2 ((AR-2 ARRAY INDEX1 INDEX2)
	       SET-AR-2 ARRAY INDEX1 INDEX2 VAL) SETF)
(DEFPROP AR-2 ((AR-2 ARRAY INDEX1 INDEX2)
	       AP-2 ARRAY INDEX1 INDEX2) LOCF)

(DEFPROP AR-2-REVERSE ((AR-2-REVERSE ARRAY INDEX1 INDEX2)
		       AS-2-REVERSE VAL ARRAY INDEX1 INDEX2) SETF)

(DEFPROP AR-3 ((AR-3 ARRAY INDEX1 INDEX2 INDEX3)
	       SET-AR-3 ARRAY INDEX1 INDEX2 INDEX3 VAL) SETF)
(DEFPROP AR-3 ((AR-3 ARRAY INDEX1 INDEX2 INDEX3)
	       AP-3 ARRAY INDEX1 INDEX2 INDEX3) LOCF)

(DEFPROP ARRAY-LEADER ((ARRAY-LEADER ARRAY INDEX)
		       SET-ARRAY-LEADER ARRAY INDEX VAL) SETF)
(DEFPROP ARRAY-LEADER ((ARRAY-LEADER ARRAY INDEX)
		       AP-LEADER ARRAY INDEX) LOCF)

(DEFPROP ELT ((ELT SEQUENCE INDEX) . (SETELT SEQUENCE INDEX VAL)) SETF)

(DEFPROP ARRAYCALL ARRAYCALL-SETF SETF)

(DEFUN ARRAYCALL-SETF (REF VAL)
  `(SET-AREF ,@(CDDR REF) ,VAL))

(DEFPROP ARRAYCALL ARRAYCALL-LOCF LOCF)
(DEFUN ARRAYCALL-LOCF (REF)
  `(ALOC . ,(CDDR REF)))

(DEFPROP CDR ((CDR ITEM) . (SETCDR ITEM VAL)) SETF)
(DEFPROP CDR ((CDR LIST) . LIST) LOCF)

(DEFPROP CAR ((CAR LIST) . (SETCAR LIST VAL)) SETF)
(DEFPROP CAR ((CAR LIST) . (CAR-LOCATION LIST)) LOCF)

(DEFPROP CDDR ((CDDR ITEM) . (CDR (CDR ITEM))) SETF-EXPANDER)
(DEFPROP CDDDR ((CDDDR ITEM) . (CDR (CDDR ITEM))) SETF-EXPANDER)
(DEFPROP CDDDDR ((CDDDDR ITEM) . (CDR (CDDDR ITEM))) SETF-EXPANDER)
(DEFPROP CDDDAR ((CDDDAR ITEM) . (CDR (CDDAR ITEM))) SETF-EXPANDER)
(DEFPROP CDDAR ((CDDAR ITEM) . (CDR (CDAR ITEM))) SETF-EXPANDER)
(DEFPROP CDDADR ((CDDADR ITEM) . (CDR (CDADR ITEM))) SETF-EXPANDER)
(DEFPROP CDDAAR ((CDDAAR ITEM) . (CDR (CDAAR ITEM))) SETF-EXPANDER)
(DEFPROP CDAR ((CDAR ITEM) . (CDR (CAR ITEM))) SETF-EXPANDER)
(DEFPROP CDADR ((CDADR ITEM) . (CDR (CADR ITEM))) SETF-EXPANDER)
(DEFPROP CDADDR ((CDADDR ITEM) . (CDR (CADDR ITEM))) SETF-EXPANDER)
(DEFPROP CDADAR ((CDADAR ITEM) . (CDR (CADAR ITEM))) SETF-EXPANDER)
(DEFPROP CDAADR ((CDAADR ITEM) . (CDR (CAADR ITEM))) SETF-EXPANDER)
(DEFPROP CDAAAR ((CDAAAR ITEM) . (CDR (CAAAR ITEM))) SETF-EXPANDER)
(DEFPROP CADR ((CADR ITEM) . (CAR (CDR ITEM))) SETF-EXPANDER)
(DEFPROP CADDR ((CADDR ITEM) . (CAR (CDDR ITEM))) SETF-EXPANDER)
(DEFPROP CADDDR ((CADDDR ITEM) . (CAR (CDDDR ITEM))) SETF-EXPANDER)
(DEFPROP CADDAR ((CADDAR ITEM) . (CAR (CDDAR ITEM))) SETF-EXPANDER)
(DEFPROP CADAR ((CADAR ITEM) . (CAR (CDAR ITEM))) SETF-EXPANDER)
(DEFPROP CADADR ((CADADR ITEM) . (CAR (CDADR ITEM))) SETF-EXPANDER)
(DEFPROP CADAAR ((CADAAR ITEM) . (CAR (CDAAR ITEM))) SETF-EXPANDER)
(DEFPROP CAAR ((CAAR ITEM) . (CAR (CAR ITEM))) SETF-EXPANDER)
(DEFPROP CAADR ((CAADR ITEM) . (CAR (CADR ITEM))) SETF-EXPANDER)
(DEFPROP CAADDR ((CAADDR ITEM) . (CAR (CADDR ITEM))) SETF-EXPANDER)
(DEFPROP CAADAR ((CAADAR ITEM) . (CAR (CADAR ITEM))) SETF-EXPANDER)
(DEFPROP CAAADR ((CAAADR ITEM) . (CAR (CAADR ITEM))) SETF-EXPANDER)
(DEFPROP CAAAAR ((CAAAAR ITEM) . (CAR (CAAAR ITEM))) SETF-EXPANDER)

(DEFPROP NTH ((NTH N LIST) . (CAR (NTHCDR N LIST))) SETF-EXPANDER)

(DEFPROP NTHCDR ((NTHCDR N LIST) . (CDR (NTHCDR (1- N) LIST))) SETF-EXPANDER)

(DEFPROP FSYMEVAL ((FSYMEVAL SYMBOL) . (FSET SYMBOL VAL)) SETF)
(DEFPROP FSYMEVAL ((FSYMEVAL SYMBOL) . (FUNCTION-CELL-LOCATION SYMBOL)) LOCF)

(DEFPROP MACRO-FUNCTION ((MACRO-FUNCTION S) . (FSET S (CONS 'MACRO SI:VAL))) SETF)

(DEFPROP FDEFINITION ((FDEFINITION FUNCTION-SPEC)
		      . (FDEFINE FUNCTION-SPEC VAL T)) SETF)
(DEFPROP FDEFINITION ((FDEFINITION FUNCTION-SPEC)
		      . (FDEFINITION-LOCATION FUNCTION-SPEC)) LOCF)

(DEFPROP SYMEVAL ((SYMEVAL SYMBOL) . (SET SYMBOL VAL)) SETF)
(DEFPROP SYMEVAL ((SYMEVAL SYMBOL) . (VALUE-CELL-LOCATION SYMBOL)) LOCF)

(DEFPROP SYMEVAL-IN-CLOSURE ((SYMEVAL-IN-CLOSURE CLOSURE PTR)
			     SET-IN-CLOSURE CLOSURE PTR VAL) SETF)
(DEFPROP SYMEVAL-IN-CLOSURE ((SYMEVAL-IN-CLOSURE CLOSURE PTR)
			     LOCATE-IN-CLOSURE CLOSURE PTR) LOCF)

(DEFPROP SYMBOL-PACKAGE ((SYMBOL-PACKAGE SYMBOL)
			 . (SETCDR (PACKAGE-CELL-LOCATION SYMBOL) VAL)) SETF)
(DEFPROP SYMBOL-PACKAGE ((SYMBOL-PACKAGE SYMBOL)
			 . (PACKAGE-CELL-LOCATION SYMBOL)) LOCF)

(DEFPROP DOCUMENTATION ((DOCUMENTATION SYMBOL DOC-TYPE) 
			. (SET-DOCUMENTATION SYMBOL DOC-TYPE VAL)) SETF)

(defprop values values-setf setf)
(defun values-setf (values-form value)
  `(multiple-value ,(cdr values-form) ,value))

;;; This really should be called SEND or something like that
(DEFPROP FUNCALL FUNCALL-SETF SETF)
(DEFUN FUNCALL-SETF (REF VAL &AUX MESSAGE-NAME SPECIAL-EXPANDER REST)
  (AND (OR (ATOM (CADDR REF)) (NEQ (CAADDR REF) 'QUOTE))
       (ERROR "Can only SETF message-sending FUNCALLs." REF))
  (SETQ REST (CDDR REF)
	MESSAGE-NAME (CADAR REST))
  (SETQ REST (IF (SETQ SPECIAL-EXPANDER (GET MESSAGE-NAME 'FUNCALL-SETF))
		 (LOCF-APPLY SPECIAL-EXPANDER REST T VAL)
		 (OR (= (LENGTH REST) 1)
		     (ERROR "Too many arguments for SETF of FUNCALL." REF))
		 `(',(INTERN (STRING-APPEND "SET-" MESSAGE-NAME) "") ,VAL)))
  `(FUNCALL ,(CADR REF) ,@REST))

(DEFPROP GET (('GET INDICATOR) . ('PUTPROP VAL INDICATOR)) FUNCALL-SETF)

(defprop function function-setf setf)
(defun function-setf (ref val)
       (or (symbolp (cadr ref))
	   (error "Cannot setf this." ref))
       `(fset ',(cadr ref) ,val))

(defprop function function-locf locf)
(defun function-locf (ref)
       (or (symbolp (cadr ref))
	   (error "Cannot locf this." ref))
       `(function-cell-location ',(cadr ref)))

(defprop plist ((plist foo) . (setplist foo val)) setf)
(defprop plist ((plist foo) . (property-cell-location foo)) locf)

(defprop ldb-test setf-ldb-test setf)
(defun setf-ldb-test (ref val)
  `(setf (ldb ,(cadr ref) ,(caddr ref))
	 (if ,val 1 0)))

;The old thing.  Also evals ref twice, lose lose.
(DEFPROP LDB ((LDB PPSS REF) . (SETF REF (DPB VAL PPSS REF))) SETF)

;The following tried to fix a hairy bug associated with (setf (ldb (cdr x)) 105).
; Unfortunately, it suffers from a worse problem, namely, the ref can be a
; array element of a numeric array, in which case it is illegal (and impossible)
; to make a locative pointer.
;(DEFPROP LDB ((LDB PPSS REF) . (DPB-VIA-LOCATIVE VAL PPSS (LOCF REF))) SETF)
;(IF-FOR-LISPM
;(DEFUN DPB-VIA-LOCATIVE (VAL PPSS LOCATIVE)  ;THIS MUST BE IN QRAND BECAUSE IT MUST BE
;    (RPLACD LOCATIVE (DPB VAL PPSS (CDR LOCATIVE)))))  ;IN THE COLD LOAD

(DEFPROP GET ((GET ATOM PROP) . (SETPROP ATOM PROP VAL)) SETF)
(DEFPROP GET ((GET ATOM PROP) . (GET-LOCATION ATOM PROP)) LOCF)

(DEFPROP GETHASH
	 ((GETHASH KEY HASH-TABLE) . (SETHASH KEY HASH-TABLE VAL)) SETF)

(DEFPROP GETHASH-EQUAL
	 ((GETHASH-EQUAL KEY HASH-TABLE) . (SETHASH KEY HASH-TABLE VAL)) SETF)

(DEFPROP ARG ((ARG N) . (SETARG N VAL)) SETF)

(DEFPROP %UNIBUS-READ ((%UNIBUS-READ ADDR) . (%UNIBUS-WRITE ADDR VAL)) SETF)
(DEFPROP %XBUS-READ ((%XBUS-READ ADDR) . (%XBUS-WRITE ADDR VAL)) SETF)

(DEFPROP %P-CONTENTS-OFFSET ((%P-CONTENTS-OFFSET BASE OFFSET)
			     %P-STORE-CONTENTS-OFFSET VAL BASE OFFSET) SETF)
(DEFPROP %P-CONTENTS-OFFSET ((%P-CONTENTS-OFFSET POINTER OFFSET)
			     %MAKE-POINTER-OFFSET DTP-LOCATIVE POINTER OFFSET) LOCF)

(DEFPROP %P-LDB ((%P-LDB PPSS POINTER)
		 %P-DPB VAL PPSS POINTER) SETF)

(DEFPROP %P-LDB-OFFSET ((%P-LDB-OFFSET PPSS POINTER OFFSET)
			%P-DPB-OFFSET VAL PPSS POINTER OFFSET) SETF)

(DEFPROP %P-MASK-FIELD ((%P-MASK-FIELD PPSS POINTER)
			%P-DEPOSIT-FIELD VAL PPSS POINTER) SETF)

(DEFPROP %P-MASK-FIELD-OFFSET ((%P-MASK-FIELD-OFFSET PPSS POINTER OFFSET)
			       %P-DEPOSIT-FIELD-OFFSET VAL PPSS POINTER OFFSET) SETF)

(DEFPROP %P-POINTER ((%P-POINTER POINTER)
		     %P-STORE-POINTER POINTER VAL) SETF)

(DEFPROP %P-DATA-TYPE ((%P-DATA-TYPE POINTER)
		       %P-STORE-DATA-TYPE POINTER VAL) SETF)

(DEFPROP %P-CDR-CODE ((%P-CDR-CODE POINTER)
		      %P-STORE-CDR-CODE POINTER VAL) SETF)

;Handle SETF of backquote expressions, for decomposition.
;For example, (SETF `(A ,B (D ,XYZ)) FOO)
;sets B to the CADR and XYZ to the CADADDR of FOO.
;The constants in the pattern are ignored.

;Backquotes which use ,@ or ,. other than at the end of a list
;expand into APPENDs or NCONCs and cannot be SETF'd.

(COMMENT
;This was used for making (setf `(a ,b) foo) return t if
;foo matched the pattern (had A as its car).
;The other change for reinstalling this
;would be to replace the PROGNs with ANDs
;in the expansions produced by (LIST SETF), etc.
(DEFUN SETF-MATCH (PATTERN OBJECT)
  (COND ((NULL PATTERN) T)
	((SYMBOLP PATTERN)
	 `(PROGN (SETQ ,PATTERN ,OBJECT) T))
	((EQ (CAR PATTERN) 'QUOTE)
	 `(EQUAL ,PATTERN ,OBJECT))
	((MEMQ (CAR PATTERN)
	       '(CONS LIST LIST*))
	 `(SETF ,PATTERN ,OBJECT))
	(T `(PROGN (SETF ,PATTERN ,OBJECT) T)))))

;This is used for ignoring any constants in the
;decomposition pattern, so that (setf `(a ,b) foo)
;always sets b and ignores a.
(DEFUN SETF-MATCH (PATTERN OBJECT)
  (COND ((AND (NOT (ATOM PATTERN)) (EQ (CAR PATTERN) 'QUOTE))
	 NIL)
	(T `(SETF ,PATTERN ,OBJECT))))

(DEFUN (LIST SETF) (PATTERN VALUE-FORM &AUX VARIABLE)
  (COND ((SYMBOLP VALUE-FORM)
	 (SETQ VARIABLE VALUE-FORM
	       VALUE-FORM NIL))
	(T (SETQ VARIABLE (GENSYM))))
  (DO ((I 0 (1+ I))
       (ACCUM)
       (ARGS (CDR PATTERN) (CDR ARGS)))
      ((NULL ARGS)
       (COND (VALUE-FORM
	       `(LET ((,VARIABLE ,VALUE-FORM))
		  (PROGN . ,(NREVERSE ACCUM))))
	     (T (CONS 'PROGN (NREVERSE ACCUM)))))
    (PUSH (SETF-MATCH (CAR ARGS) `(NTH ,I ,VARIABLE)) ACCUM)))

(DEFUN (LIST* SETF) (PATTERN VALUE-FORM &AUX VARIABLE)
  (COND ((SYMBOLP VALUE-FORM)
	 (SETQ VARIABLE VALUE-FORM
	       VALUE-FORM NIL))
	(T (SETQ VARIABLE (GENSYM))))
  (DO ((I 0 (1+ I))
       (ACCUM)
       (ARGS (CDR PATTERN) (CDR ARGS)))
      ((NULL ARGS)
       (COND (VALUE-FORM
	       `(LET ((,VARIABLE ,VALUE-FORM))
		  (PROGN . ,(NREVERSE ACCUM))))
	     (T (CONS 'PROGN (NREVERSE ACCUM)))))
    (COND ((CDR ARGS)
	   (PUSH (SETF-MATCH (CAR ARGS) `(NTH ,I ,VARIABLE)) ACCUM))
	  (T (PUSH (SETF-MATCH (CAR ARGS) `(NTHCDR ,I ,VARIABLE)) ACCUM)))))

(DEFUN (CONS SETF) (PATTERN VALUE-FORM &AUX VARIABLE)
  (COND ((SYMBOLP VALUE-FORM)
	 (SETQ VARIABLE VALUE-FORM
	       VALUE-FORM NIL))
	(T (SETQ VARIABLE (GENSYM))))
  (LET ((TEM `(PROGN ,(SETF-MATCH (CADR PATTERN) `(CAR ,VARIABLE))
		     ,(SETF-MATCH (CADDR PATTERN) `(CDR ,VARIABLE)))))
    (COND (VALUE-FORM
	    `(LET ((,VARIABLE ,VALUE-FORM))
	       ,TEM))
	  (T TEM))))

(DEFPROP LET LET-SETF SETF)

(DEFUN LET-SETF (PATTERN VALUE-FORM)
  (LET ((VAR (GENSYM))
	(NEW-BODY (COPYLIST PATTERN)))
    (SETF (CAR (LAST NEW-BODY))
	  `(SETF ,(CAR (LAST NEW-BODY)) ,VAR))
    `(LET ((,VAR ,VALUE-FORM))
       ,NEW-BODY)))

(DEFPROP LET LET-LOCF LOCF)

(DEFUN LET-LOCF (PATTERN)
  (LET ((NEW-BODY (COPYLIST PATTERN)))
    (SETF (CAR (LAST NEW-BODY))
	  `(LOCF ,(CAR (LAST NEW-BODY))))
    NEW-BODY))

(DEFPROP PROGN PROGN-SETF SETF)

(DEFUN PROGN-SETF (PATTERN VALUE-FORM)
  (LET ((NEW-BODY-TAIL (COPYLIST (CDR PATTERN))))
    ;; Discard any declarations from front of body of PROGN.
    (SETQ NEW-BODY-TAIL (EXTRACT-DECLARATIONS NEW-BODY-TAIL NIL))
    (IF (= (LENGTH NEW-BODY-TAIL) 1)
	`(SETF ,(CAR NEW-BODY-TAIL) ,VALUE-FORM)
      (LET ((VAR (GENSYM)))
	(SETF (CAR (LAST NEW-BODY-TAIL))
	      `(SETF ,(CAR (LAST NEW-BODY-TAIL)) ,VAR))
	`(LET ((,VAR ,VALUE-FORM))
	   . ,NEW-BODY-TAIL)))))

(DEFPROP PROGN PROGN-LOCF LOCF)

(DEFUN PROGN-LOCF (PATTERN)
  (LET ((NEW-BODY (COPYLIST PATTERN)))
    (SETF (CAR (LAST NEW-BODY))
	  `(LOCF ,(CAR (LAST NEW-BODY))))
    NEW-BODY))

;; Handle (SETF (DONT-OPTIMIZE (defsubst-function args)) ...)
;; Return a call to a function that will be created at load time.

(DEFPROP DONT-OPTIMIZE SETF-DONT-OPTIMIZE SETF)

(DEFUN SETF-DONT-OPTIMIZE (REF VAL)
  (LET* ((FORM (CADR REF))
	 (FUN (CAADR REF))
	 (DEF (AND (FDEFINEDP FUN) (FDEFINITION (UNENCAPSULATE-FUNCTION-SPEC FUN)))))
    (UNLESS (MEMQ (CAR (COND ((CONSP DEF) DEF)
			     ((TYPEP DEF ':COMPILED-FUNCTION)
			      (CADR (ASSQ 'INTERPRETED-DEFINITION
					  (DEBUGGING-INFO DEF))))))
		  '(SUBST NAMED-SUBST))
      (FERROR 'UNKNOWN-SETF-REFERENCE "~S is not a subst function." FUN))
    `(FUNCALL (QUOTE-EVAL-AT-LOAD-TIME (SETF-FUNCTION ',FUN ,(1- (LENGTH FORM))))
	      ,@(CDR FORM) ,VAL)))

;; Return the function to do the work of setf'ing FUNCTION applied to NARGS args.
;; If no such function has been created yet, one is created now.
;; We must have different functions for different numbers of args
;; so that problems with how args get defaulted are avoided.
(DEFUN SETF-FUNCTION (FUNCTION NARGS)
  (OR (NTH NARGS (GET FUNCTION 'RUN-TIME-SETF-FUNCTIONS))
      (LET* ((VARS (SETF-FUNCTION-N-VARS NARGS))
	     (NAME (MAKE-SYMBOL (FORMAT NIL "SETF-~A-~D-ARGS" FUNCTION NARGS) T)))
;This may not be a good idea, really.
;	(IF (SYMBOL-PACKAGE FUNCTION)
;	    (INTERN NAME (SYMBOL-PACKAGE FUNCTION)))
	(COMPILER:COMPILE-NOW-OR-LATER NAME
		 `(LAMBDA (,@VARS VAL)
		    (SETF (,FUNCTION . ,VARS) VAL)))
	(UNLESS (> (LENGTH (GET FUNCTION 'RUN-TIME-SETF-FUNCTIONS)) NARGS)
	  (SETF (GET FUNCTION 'RUN-TIME-SETF-FUNCTIONS)
		(APPEND (GET FUNCTION 'RUN-TIME-SETF-FUNCTIONS)
			(MAKE-LIST (- (1+ NARGS)
				      (LENGTH (GET FUNCTION 'RUN-TIME-SETF-FUNCTIONS)))))))
	(SETF (NTH NARGS (GET FUNCTION 'RUN-TIME-SETF-FUNCTIONS))
	      NAME)
	NAME)))

(DEFPROP DONT-OPTIMIZE LOCF-DONT-OPTIMIZE LOCF)

(DEFUN LOCF-DONT-OPTIMIZE (REF)
  (LET* ((FORM (CADR REF))
	 (FUN (CAADR REF))
	 (DEF (AND (FDEFINEDP FUN) (FDEFINITION (UNENCAPSULATE-FUNCTION-SPEC FUN)))))
    (UNLESS (MEMQ (CAR (COND ((CONSP DEF) DEF)
			     ((TYPEP DEF ':COMPILED-FUNCTION)
			      (CADR (ASSQ 'INTERPRETED-DEFINITION
					  (DEBUGGING-INFO DEF))))))
		  '(SUBST NAMED-SUBST))
      (FERROR 'UNKNOWN-LOCF-REFERENCE "~S is not a subst function." FUN))
    `(FUNCALL (QUOTE-EVAL-AT-LOAD-TIME (LOCF-FUNCTION ',FUN ,(1- (LENGTH FORM))))
	      ,@(CDR FORM))))

(DEFUN LOCF-FUNCTION (FUNCTION NARGS)
  (OR (NTH NARGS (GET FUNCTION 'RUN-TIME-LOCF-FUNCTIONS))
      (LET* ((VARS (SETF-FUNCTION-N-VARS NARGS))
	     (NAME (MAKE-SYMBOL (FORMAT NIL "LOCF-~A-~D-ARGS" FUNCTION NARGS) T)))
;This may not be a good idea, really.
;	(IF (SYMBOL-PACKAGE FUNCTION)
;	    (INTERN NAME (SYMBOL-PACKAGE FUNCTION)))
	(COMPILER:COMPILE-NOW-OR-LATER NAME
		 `(LAMBDA ,VARS
		    (LOCF (,FUNCTION . ,VARS))))
	(UNLESS (> (LENGTH (GET FUNCTION 'RUN-TIME-LOCF-FUNCTIONS)) NARGS)
	  (SETF (GET FUNCTION 'RUN-TIME-LOCF-FUNCTIONS)
		(APPEND (GET FUNCTION 'RUN-TIME-LOCF-FUNCTIONS)
			(MAKE-LIST (- (1+ NARGS)
				      (LENGTH (GET FUNCTION 'RUN-TIME-LOCF-FUNCTIONS)))))))
	(SETF (NTH NARGS (GET FUNCTION 'RUN-TIME-LOCF-FUNCTIONS))
	      NAME)
	NAME)))

(DEFVAR SETF-FUNCTION-N-VARS NIL)

(DEFUN SETF-FUNCTION-N-VARS (N)
  "Return a list of N distinct symbols.
The symbols are reused each time this function is called."
  (DO () ((>= (LENGTH SETF-FUNCTION-N-VARS) N))
    (PUSH (GENSYM) SETF-FUNCTION-N-VARS))
  (FIRSTN N SETF-FUNCTION-N-VARS))
