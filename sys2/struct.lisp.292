;;; -*- Mode:LISP; Package:SYSTEM-INTERNALS; Base:8; Lowercase:TRUE; Fonts:(CPTFONT 5X5) -*-

;;;     ** (c) Copyright 1980 Massachusetts Institute of Technology **
;;;     ** (c) Copyright 1981 Massachusetts Institute of Technology **

;The current Lisp machine copy is in SYS:SYS2;STRUCT LISP (SRC:<L.SYS2>STRUCT.LISP)
; this version implements common-lisp-style-defstruct for mit zetalisp

;These are the original sources for this code -- they have not been munged for clisp
;The master copy of this file is in MC:ALAN;NSTRUCT >
;The current PDP10 MacLisp copy is in MC:ALAN;STRUCT >
;The current Multics MacLisp copy is in >udd>Mathlab>Bawden>defstruct.lisp
;  on MIT-Multics
;The current VMS-NIL copy is in [NIL.SRC.SPEC]STRUCT.LSP on HTJR

;*****  READ THIS PLEASE!  *****
;If you are thinking of munging anything in this file you might want to
;consider finding me (ALAN) and asking me to mung it for you.  There is more
;than one copy of this file in the world (it runs in PDP10 and Multics MacLisp,
;NIL, Franz, PSL and on LispMachines) and whatever amazing features you are
;considering adding might be usefull to those people as well.  If you still
;cannot contain yourself long enough to find me, AT LEAST send me a piece of
;mail describing what you did and why.  Thanks for reading this flame.
;                               Alan Bawden (ALAN@MC)


;**** I READ THAT! ****
;Date: Monday, 26 September 1983  18:59-EDT
;From: Alan Bawden <ALAN at MIT-MC>
;To:   Mly at MIT-ML
;Re:   structural problems
;
;       ... I expect to make a common-lisp compatible defstruct myself
;someday, which will probably run in the LMIT system just as it will in the
;Franz, NIL, symbolics, PSL and MacLisp dialects.
;
;Since I refuse to cooperate with RMS on anything, and the LMIT system is
;RMS's personal project, I don't care what you do to defstruct, just as long
;as you don't modify any of my copies.


;**** SO WHY DID I BOTHER? ****
;The following code is only tested to run in the mit lispmachine system (sys 98 and later)
;I have tried not to incorporate much code that will render future compatibility-
;  hacking too difficult
;Fascism and bickering are alive and well. Sigh. It also turns out that ALAN works
;  for Symbolics, Inc, a Delaware Corporation.
;I just wrote the code. Richard Mlynarik. (mly@random-place)


1(eval-when (eval compile)
  (cond ((and (status feature MacLisp) (status feature PDP10))*
        1 (sstatus feature MacLisp-10))*
        1(t (sstatus nofeature MacLisp-10))))

(eval-when (compile)
  (cond ((status feature ITS)*
        1 (load '|alan;lspenv init|))*
        1((status feature Multics)*
        1 (load '|>udd>Mathlab>Bawden>lspenv.lisp|))))

#+MacLisp-10
(cond ((status nofeature noldmsg)
       (terpri msgfiles)
       (princ '#.(and (status feature MacLisp-10)*
                1      (maknam (nconc (exploden ";Loading DEFSTRUCT ")*
                                1     (exploden (caddr (truename infile))))))*
        1      msgfiles)))

#+NIL
(herald defstruct)

#+Multics
(declare (genprefix defstruct-internal-)*
        1 (macros t))

#+MacLisp
(eval-when (eval compile)
  (setsyntax #/: (ascii #\space) nil))

(eval-when (eval)
  ;;So we may run the thing interpreted we need the simple
  ;;defstruct that lives here:
  (cond ((status feature ITS)*
        1 (load '|alan;struct initial|))*
        1((status feature Multics)*
        1 (load '|>udd>Mathlab>Bawden>initial_defstruct|))))

(eval-when (compile)
  ;;To compile the thing this probably is an old fasl: (!)
  (cond ((status feature ITS)*
        1 (load '|alan;struct boot|))*
        1((status feature Multics)*
        1 (load '|>udd>Mathlab>Bawden>boot_defstruct|))))

#+Multics
(defun nth (n l)
  (do ((n n (1- n))
       (l l (cdr l)))
      ((zerop n) (car l))))

#+Multics
(defun nthcdr (n l)
  (do ((n n (1- n))
       (l l (cdr l)))
      ((zerop n) l)))

#+Multics
(defun displace (x y)
  (cond ((atom y)*
        1 (rplaca x 'progn)*
        1 (rplacd x (list y)))*
        1(t*
        1 (rplaca x (car y))*
        1 (rplacd x (cdr y))))
  x)*

(eval-when (eval compile load)

1#+MacLisp
(defun defstruct-retry-keyword (x)
  (let ((l (exploden x)))
    (if (= (car l) #/:)*
        1(implode (cdr l))*
        1x)))*

#+LispM
(defun defstruct-retry-keyword (x)
  (intern (get-pname x) si:pkg-keyword-package))

1#+NIL
(defmacro defstruct-retry-keyword (x)
  `(to-keyword ,x))*

#+(and LispM MIT)
(defsubst defstruct-divide (x y) (truncate x y))

1#-(and LispM MIT)
(defsubst defstruct-divide (x y) (// x y))*

);End of eval-when (eval compile load)

(eval-when (eval compile load)
#+LispM
(defun defstruct-append-symbols (&rest args)
  (intern (apply 'string-append args)))
)

;;; Eval this before attempting incremental compilation
(eval-when #+(AND LISPM MIT) (EVAL COMPILE LOAD)	;less lossage for patching
	   1#-(AND LISPM MIT) (eval compile)

#+MacLisp-10
(defmacro defstruct-append-symbols args
  (do ((l (reverse args) (cdr l))
       (x)
       (a nil (if (or (atom x)*
                1      (not (eq (car x) 'quote)))*
                1  (if (null a)*
                1      `(exploden ,x)*
                1      `(nconc (exploden ,x) ,a))*
                1  (let ((l (exploden (cadr x))))*
                1    (cond ((null a) `',l)*
                        1  ((= 1 (length l)) `(cons ,(car l) ,a))*
                        1  (t `(append ',l ,a)))))))
      ((null l) `(implode ,a))
    (setq x (car l))))

#+Multics
(defmacro defstruct-append-symbols args
  `(make_atom (catenate ,@args)))

#+NIL
(defmacro defstruct-append-symbols args
  `(symbolconc ,@args))*

(defmacro defstruct-putprop (sym val ind)
  `(push `(defprop ,,sym ,,val ,,ind) returns))

1#+Multics
;;;lcp gobbles (defprop ... macro) at compile time, so we have to use
;;;putprop to be certain macro definitions make it into the object:
(defmacro defstruct-put-macro (sym fcn)
  `(push `(putprop ',,sym ',,fcn 'macro) returns))

#+MacLisp-10
(defmacro defstruct-put-macro (sym fcn)
  `(push `(defprop ,,sym ,,fcn macro) returns))

#+(and LispM (NOT MIT))
(defmacro defstruct-put-macro (sym fcn)
  (setq fcn (if (and (not (atom fcn))*
                1     (eq (car fcn) 'quote))*
                1`'(macro . ,(cadr fcn))*
                1`(cons 'macro ,fcn)))
  `(push `(fdefine ',,sym ',,fcn t) returns))*

#+(and lispm MIT)
(defmacro defstruct-put-macro (sym fcn)
  (setq fcn (if (and (not (atom fcn))
                     (eq (car fcn) 'quote))
                `'(macro . ,(cadr fcn))
              `(cons 'macro ,fcn)))
  `(push `(deff-macro ,,sym ',,fcn) returns))

1#+NIL
(defmacro defstruct-put-macro (sym fcn)
  `(push `(add-macro-definition ',,sym ',,fcn) returns))*
                                                        
(defmacro make-empty () `'%%defstruct-empty%%)

(defmacro emptyp (x) `(eq ,x '%%defstruct-empty%%))

;;;Here we must deal with the fact that error reporting works
;;;differently everywhere!

1#+MacLisp-10
;;;first arg is ALWAYS a symbol or a quoted symbol:
(defmacro defstruct-error (message &rest args)
  (let* ((chars (nconc (exploden (if (atom message)*
                                1     message*
                                1     (cadr message)))*
                1       '(#/.)))*     1;"Bad frob" => "Bad frob."*
        1 (new-message*
        1  (maknam (if (null args)*
                1      chars*
                1      (let ((c (car chars)))*   1;"Bad frob." => "-- bad frob."*
                        1(or (< c #/A)*
                        1    (> c #/Z)*
                        1    (rplaca chars (+ c #o40)))*
                        1(append '(#/- #/- #\space) chars))))))
  `(error ',new-message*
        1  ,@(cond ((null args) `())*
                1  ((null (cdr args)) `(,(car args)))*
                1  (t `((list ,@args)))))))

#+Multics
;;;first arg is ALWAYS a string:
(defmacro defstruct-error (message &rest args)
  `(error ,(catenate "defstruct: "*
                1     message*
                1     (if (null args)*
                        1 "."*
                        1 ": "))*
        1  ,@(cond ((null args) `())*
                1  ((null (cdr args)) `(,(car args)))*
                1  (t `((list ,@args))))))*

#+(or LispM NIL)
;;;first arg is ALWAYS a string:
(defmacro defstruct-error (message &rest args)
  (do ((l args (cdr l))
       (fs "")
       (na nil))
      ((null l)
      `(ferror nil
               ,(string-append message
                               (if (null args)
                                   "."
                                   (string-append ":" fs)))
               ,.(nreverse na)))
    (cond ((and (not (atom (car l)))
                (eq (caar l) 'quote)
                (symbolp (cadar l)))
           (setq fs (string-append fs " " (string-downcase (cadar l)))))
          (t
           (push (car l) na)
           (setq fs (string-append fs " ~S"))))))

);End of eval-when (eval compile) [(eval compile load) for mit lispm]

;;;If you mung the the ordering af any of the slots in this structure,
;;;be sure to change the version slot and the definition of the function
;;;get-defstruct-description.  Munging the defstruct-slot-description 
;;;structure should also cause you to change the version "number" in this
;;;manner.
(defstruct (defstruct-description
             (:type :list)
             (:default-pointer description)
             (:conc-name defstruct-description-)
             (:alterant ())
          #+stingy-defstruct
             (:eval-when (eval compile)))
  (version 'one)
  type
  dummy ;used to be the displace function
  slot-alist                                    ;of form (var-1 slot-desc-1 var-2 ...)
  named-p
  constructors
  (default-pointer nil)
  (but-first nil)
  size
  (property-alist nil)
  ;;end of "expand-time" slots ;not true now --- extra stuff added below!!! mly
  name
  include
  (initial-offset 0)
  (eval-when '(eval compile load))
  alterant
  (conc-name nil)
  (callable-accessors #-(or LispM NIL) nil #+(or LispM NIL) t)
  (size-macro nil)
  (size-symbol nil)
  (predicate nil)
  (copier nil)
  (print nil)
  (CALLABLE-CONSTRUCTORS NIL)                   ;defaults to T for clisp
  (SUBTYPE NIL)
  )

(defun get-defstruct-description (name)
  (let ((description (get name 'defstruct-description)))
    (cond ((null description)
           (defstruct-error
             "A structure with this name has not been defined" name))
          ((not (eq (defstruct-description-version) 'one))
           (defstruct-error "The internal description of this structure is
incompatible with the currently loaded version of DEFSTRUCT,
you will need to recompile its definition"
                  name))
          (t description))))

;;;See note above defstruct-description structure before munging this one.
(defstruct (defstruct-slot-description
             (:type :list)
             (:default-pointer slot-description)
             (:conc-name defstruct-slot-description-)
             (:alterant ())
          #+stingy-defstruct
             (:eval-when (eval compile)))
  number
  (ppss nil)
  init-code
  (type T)	;clisp universal supertype  -- was NOTYPE in original defstruct
  (property-alist nil)
  ref-macro-name
  DOCUMENTATION
  (READ-ONLY NIL)
  BITS		;how many bits needed to store this slot -- not yet used
  )

;;;Perhaps this structure wants a version slot too?
(defstruct (defstruct-type-description
             (:type :list)
             (:default-pointer type-description)
             (:conc-name defstruct-type-description-)
             (:alterant ())
          #+stingy-defstruct
             (:eval-when (eval compile)))
  ref-expander
  ref-no-args
  cons-expander
  cons-flavor
  (cons-keywords nil)
  (named-type nil)
  (overhead 0)
  (defstruct-expander nil)
  (predicate nil)
  (copier nil)
  (DEFSTRUCT-KEYWORDS NIL)
  DOCUMENTATION
  )

#+LispM
(defprop defstruct "Structure" definition-type-name)

;;;The order of forms returned by defstruct is sometimes critical.  Keep this
;;;in mind when munging this code:
#-(AND LISPM MIT)				;mit lispm doc is wrong elsewhere
(DEFMACRO DEFSTRUCT (OPTIONS &BODY ITEMS)
  (DEFSTRUCT-1 OPTIONS ITEMS NIL))

#+(AND LISPM MIT)
(DEFMACRO DEFSTRUCT (OPTIONS &BODY ITEMS)
  "(DEFSTRUCT (<name> . <options>) . <slots>) or (DEFSTRUCT <name> . <slots>)

<options> is of the form (<option> <option> (<option> <val>) ...)

<slots> is of the form (<slot> (<slot> <initial-value>) ...)

Options:
  :TYPE defaults to :ARRAY
    other useful types include :ARRAY-LEADER :TYPED-ARRAY :FIXNUM-ARRAY :FLONUM-ARRAY
    :LIST :LIST* :TREE
  :CONSTRUCTOR defaults to "MAKE-<name>"
    More than one constructor may be specified. The syntax for defining a constructor
    is either: (:CONSTRUCTOR <name>) or (:CONSTRUCTOR <name> <arglist>)
    If no arglist is supplied, a constructor is defined which takes alternating
     slotnames and values as arguments and initializes those slots to those values.
    If an arglist is supplied, then the constructor defined will have this as its
     arglist. Meaningful lambda-list-keywords are &OPTIONAL &REST and &AUX.
     Use &AUX to initialize a slot to a value other then the usual default value.
    The first type of constructor behaves differently if :CALLABLE-CONSTRUCTORS is
    non-NIL. See below.
  :DEFAULT-POINTER defaults to empty (if no <val> given defaults to "<name>")
  :CONC-NAME defaults to empty (if no <val> given defaults to "<name>-")
    This what to prepend to the names of slots to obtain the names of the slot-accessor
    functions.
  :SIZE-SYMBOL defaults to empty (if no <val> given defaults to "<name>-SIZE")
  :SIZE-MACRO defaults to empty (if no <val> given defaults to "<name>-SIZE")
  :ALTERANT defaults to "ALTER-<name>"
  :BUT-FIRST must have a <val> given
  :INCLUDE must have a <val> given
  :PROPERTY (:property foo bar) gives the structure a foo
    property of bar.  (:property foo) gives a foo property of T.
  :INITIAL-OFFSET can cause defstruct to skip over that many slots.
  :NAMED takes no value.  Tries to make the structure a named type.
  :CALLABLE-ACCESSORS defaults to T, which means that the slot-accessors
    may be called (they are defsubsts in this case) If NIL, the accessors
    are defined as macros.
  :CALLABLE-CONSTRUCTORS defaults to NIL -- the constructors are defined as macros.
    If non-NIL, they are functions, which is what Common Lisp wants.
    This will affect /"SETQ-style/" constructors, ie those which take alternating slotnames
     and values.
     If :CALLABLE-CONSTRUCTORS is T, those slotnames must be keywords, as the constructor
     is implemented as a function with an &KEY arglist. Keyword slotnames will ALSO work
     even if this is NIL, though non-keyword slotnames WILL NOT work if T.
     This also affects the quoting of arguments to the additional cons-keywords for these
     constructors. See SYS:DOC;SYS98 DEFSTRUCT for details.
  :PREDICATE defaults to empty (if no <val> given defaults
    to "<name>-P").  Generates a predicate if possible.
  :COPIER defaults to empty (if no <val> given defaults to
    "COPY-<name>").  Generates a function to copy this structure.
  :PRINT (:print "#<spaceship at ~S by ~S>" (x-pos spaceship)
    (y-pos spaceship))  The name of the structure is used as
    the variable.
  :PRINT-FUNCTION The value should be a function of three arguments, the structure to be
    printed, the stream to print it on, and the current print-depth.
  <type> any type name can be used without a <val> instead of
    saying (:TYPE <type>) 
  <other> any symbol which is specified as a :DEFSTRUCT-KEYWORD for the type of structure
    which we are creating."
  (DEFSTRUCT-1 OPTIONS ITEMS NIL))

#+(AND LISPM MIT)
(DEFMACRO CLI:DEFSTRUCT (OPTIONS &BODY ITEMS)
  "(DEFSTRUCT (<name> . <options>) . <slots>) or (DEFSTRUCT <name> . <slots>)

<options> is of the form (<option> <option> (<option> <val>) ...)

<slots> is of the form (<slot> (<slot> <initial-value>) ...)

Options:
  :TYPE defaults to VECTOR
    Possible values are VECTOR, (VECTOR <vector-type>) and LIST, as well as the types
    available for non-common-lisp defstruct (GLOBAL:DEFSTRUCT)
  :CONSTRUCTOR defaults to "MAKE-<name>"
    More than one constructor may be specified. The syntax for defining a constructor
    is either: (:CONSTRUCTOR <name>) or (:CONSTRUCTOR <name> <arglist>)
    If no arglist is supplied, a constructor is defined which takes alternating
     slotnames and values as arguments and initializes those slots to those values.
    If an arglist is supplied, then the constructor defined will have this as its
     arglist. Meaningful lambda-list-keywords are &OPTIONAL &REST and &AUX.
     Use &AUX to initialize a slot to a value other then the usual default value.
  :CONC-NAME defaults to <name>. This what to prepend to the names of slots to obtain
    the names of the slot-accessor functions
  :INCLUDE must have a <val> given
  :INITIAL-OFFSET can cause defstruct to skip over that many slots.
  :UNNAMED takes no value.  Tries to make the structure an unnamed type.
  :PREDICATE defaults to <name>-p.  Generates a predicate if possible. Give this option
    a value of NIL if you don't want a predicate.
  :PRINT-FUNCTION The value should be a function of three arguments, the structure to be
    printed, the stream to print it on, and the current print-depth.
  Many other (non-common-lisp, non-portable) options are available. See GLOBAL:DEFSTRUCT."
  (DEFSTRUCT-1 OPTIONS ITEMS T))

(DEFUN DEFSTRUCT-1 (OPTIONS ITEMS CLIP)         ;CLIP means "common lisp, incompatible"-p
  (let* ((description (defstruct-parse-options options CLIP))
         (type-description (get (defstruct-description-type)
                                'defstruct-type-description))
         (name (defstruct-description-name))
         (DOC (AND (STRINGP (CAR ITEMS)) (POP ITEMS)))
         (new-slots (defstruct-parse-items items description))	;now all slots -- mly
         (returns nil))
    ;;Keep the returns from this as close to last as possible
    ;;Evaluate this before everything else
    (AND (defstruct-type-description-defstruct-expander)
         (setq returns (funcall (defstruct-type-description-defstruct-expander) description)))
    (SETQ RETURNS
          (APPEND RETURNS
                  ;;This must be the last returned form, since to compile it
                  ;;might require that the structure already be operable:
                  (IF (DEFSTRUCT-DESCRIPTION-PRINT)
                      (LIST (DEFSTRUCT-DEFINE-PRINTER NAME (DEFSTRUCT-DESCRIPTION-PRINT))))
                  ;;Return the name symbol as our value
                  `(',NAME)))
1 #+(and LispM (NOT MIT))
    (push `(record-source-file-name ',name 'defstruct) returns)*
 #+(and LispM MIT)
    (push `(eval-when (load eval) (record-source-file-name ',name 'defstruct)) returns)
    (AND DOC (PUSH `(SETF (DOCUMENTATION ',NAME 'STRUCTURE) ,DOC) RETURNS))
    (let ((alterant (defstruct-description-alterant))
          (size-macro (defstruct-description-size-macro))
          (size-symbol (defstruct-description-size-symbol))
          (predicate (defstruct-description-predicate))
          (copier (defstruct-description-copier)))
      (cond (predicate
             (push (funcall (or (defstruct-type-description-predicate)
                                (defstruct-error
                                  "This DEFSTRUCT type cannot produce a predicate"
                                  (defstruct-description-type) 'in name))
                            description
                            predicate)
                   returns)))
      (cond (copier
             (push
               (let ((copy-fun (defstruct-type-description-copier)))
                 (cond (copy-fun
                        (funcall copy-fun description copier))
                       ((not (= 1 (defstruct-type-description-ref-no-args)))
                        (defstruct-error
                          "This defstruct type cannot produce a copying function"
                          (defstruct-description-type) 'in name))
                       (t (do ((i (1- (defstruct-description-size)) (1- i))
                               (l nil (cons (cons i
                                                  (funcall
                                                    (defstruct-type-description-ref-expander)
                                                    i description 'x))
                                            l)))
                              ((< i 0)
                               `(defun ,copier (x)
                                  ,(invoke-defstruct-constructor-expander
                                     description type-description l nil)))))))
               returns)))
      (cond (alterant
             (defstruct-put-macro alterant 'defstruct-expand-alter-macro)
             (defstruct-putprop alterant name 'defstruct-name)))
      (cond (size-macro
             (defstruct-put-macro size-macro 'defstruct-expand-size-macro)
             (defstruct-putprop size-macro name 'defstruct-name)))
      (cond (size-symbol
             (push `(defconst ,size-symbol
                      ,(+ (defstruct-description-size)
                          (defstruct-type-description-overhead)))
                   returns))))
    (defstruct-putprop name description 'defstruct-description)
    ;;what defstruct returns
    #-(OR LISPM NIL)			;retain eval-when so as not to cause hidden screws
    `(eval-when ,(defstruct-description-eval-when)
       ,.(defstruct-define-ref-macros new-slots description)
       ,.(DEFSTRUCT-DEFINE-CONSTRUCTORS DESCRIPTION)
       ,.returns)
    #+(OR LISPM NIL)			;losing eval-when flushed!! 
    (PROGN
      ,.(defstruct-define-ref-macros new-slots description))
      ,.(DEFSTRUCT-DEFINE-CONSTRUCTORS DESCRIPTION)
      ,.returns))

;;;General philosophy on the :print option is to not bother the
;;;user if printing cannot be controlled.  This allows for
;;;portability without pain.  This may prove to be a bogus philosophy.
1#+MacLisp-10
(defun defstruct-define-printer (name rest)
  (let ((stream (gensym))*
        1(CLIP (POP REST)))
    (IF CLIP*
        1NIL*                     1;don't know what to do ln maclisp
      `(defun (,name named-hunk-printer) (,name ,stream)*
        1 (?format ,stream ,@rest)))))*

#+LISPM				;should change this in view of defselect-incremental
(DEFUN DEFSTRUCT-DEFINE-PRINTER (NAME REST &AUX (CLIP (POP REST)))
  (LET ((OP (GENSYM))
        (ARGS (GENSYM)))
    (IF CLIP
        `(DEFUN (,NAME NAMED-STRUCTURE-INVOKE) (,OP ,NAME &REST ,ARGS)
           (SELECTQ ,OP
             (:PRINT-SELF
              (IF PRINT-READABLY (PRINT-NOT-READABLE ,NAME))
              (FUNCALL ,(CAR REST) ,NAME (CAR ,ARGS) (CADR ,ARGS)))
             (:WHICH-OPERATIONS '(:PRINT-SELF :WHICH-OPERATIONS))
             (T NIL)))                          ;don't barf on weird operations
       `(DEFUN (,NAME NAMED-STRUCTURE-INVOKE) (,OP ,NAME &REST ,ARGS)
          (SELECTQ ,OP
            (:PRINT-SELF
             (IF PRINT-READABLY (PRINT-NOT-READABLE ,NAME))
             (FORMAT (CAR ,ARGS) ,@REST))
            (:WHICH-OPERATIONS '(:PRINT-SELF :WHICH-OPERATIONS))
            (T NIL))))))
  

1#+NIL
(defun defstruct-define-printer (name rest)
  (let ((method-function-name (symbolconc name "->PRINT-SELF#METHOD"))*
        1(stream-var (gensym))*
        1(gubble (gensym))*
        1CLIP (POP REST))
    (IF CLIP*
        1NIL*              	1;don't know anything about nil either...
      `(progn 'compile*
	1      (defun ,method-function-name (,name () () ,stream-var &rest ,gubble)*
		1,gubble*	1;ignored*
		1(format ,stream-var ,@rest))*
	1      (add-flavor-method-info ',name ':print-self ',method-function-name)))))
  
#-(or LispM MacLisp-10 NIL)
(defun defstruct-define-printer (name rest)
  `(comment ,name ,@rest))*

(defun defstruct-parse-options (options CLIP)
  (let ((name (if (atom options) options (car options)))
	(type nil)
	(constructors (make-empty))
	(alterant (make-empty))
	(included nil)
	(named-p CLIP)				;structures named by default in common lisp
	(but-first nil)
	(description (make-defstruct-description))
	(OLD)
	(SPEC))
    (setf (defstruct-description-name) name)
    (WHEN CLIP
      (SETF (DEFSTRUCT-DESCRIPTION-CONC-NAME) (DEFSTRUCT-APPEND-SYMBOLS NAME '-))
      (SETF (DEFSTRUCT-DESCRIPTION-PREDICATE) (MAKE-EMPTY))
      (SETF (DEFSTRUCT-DESCRIPTION-CALLABLE-CONSTRUCTORS) T))
    (do ((op) (val) (vals)
	 (options (if (atom options) nil (cdr options))
		  (cdr options)))
	((null options))
      (if (atom (setq op (car options)))
	  (setq vals nil)
	  (setq op (prog1 (car op) (setq vals (cdr op)))))
      (setq val (if (null vals) (make-empty) (car vals)))
      (SETQ OLD NIL)
    AGAIN
      (selectq op
	(:type
	 (if (emptyp val)
	     (defstruct-error
	       "The :TYPE option to DEFSTRUCT must have a value given"
	       name))
	 (setq type val))
	(:default-pointer
	 (setf (defstruct-description-default-pointer)
	       (if (emptyp val) name val)))
	(:UNNAMED
	 (OR (EMPTYP VAL)
	     (DEFSTRUCT-ERROR
	       "The :UNNAMED option to DEFSTRUCT doesn't take a value" NAME))
	 (SETQ NAMED-P NIL))
	(:named
	 (or (emptyp val)
	     (defstruct-error
	       "The :NAMED option to DEFSTRUCT doesn't take a value" name))
	 (setq named-p t))
	(:conc-name
	 (setf (defstruct-description-conc-name)
	       (if (emptyp val)
		   (IF CLIP NIL
		     (defstruct-append-symbols name '-))
		 val)))
	(:print
	 (if (emptyp val)
	     (defstruct-error
	       "The :PRINT option to DEFSTRUCT requires a value"
	       name))
	 (setf (defstruct-description-print) (CONS NIL VALS)))	;clisp nil
	(:PRINT-FUNCTION
	 (AND (EMPTYP VAL)
	      (DEFSTRUCT-ERROR
		"The :PRINT-FUNCTION option to DEFSTRUCT requires a value"
		NAME))
	 (AND (CDR VALS)			;check against using :print syntax
	      (DEFSTRUCT-ERROR
		"The :PRINT-FUNCTION option to DEFSTRUCT takes only one value"))
	 (SETF (DEFSTRUCT-DESCRIPTION-PRINT) (CONS T VALS)))	;clisp t
	(:include
	 (if (emptyp val)
	     (defstruct-error
	       "The :INCLUDE option to DEFSTRUCT requires a value"
	       name))
	 (setq included val)
	 (setf (defstruct-description-include) vals))
	(:predicate
	 (setf (defstruct-description-predicate)
	       (if (emptyp val)
		   (defstruct-append-symbols name '-p)
		   val)))
	(:constructor
	 (cond ((null val)
		(setq constructors nil))
	       (t
		(and (emptyp val)
		     (setq val (defstruct-append-symbols 'make- name)))
		(setq val (cons val (cdr vals)))
		(if (emptyp constructors)
		    (setq constructors (list val))
		    (push val constructors)))))
	(:copier
	 (setf (defstruct-description-copier)
	       (if (emptyp val)
		   (defstruct-append-symbols 'copy- name)
		   val)))
	(:eval-when
	 (and (emptyp val)
	      (defstruct-error
		"The :EVAL-WHEN option to DEFSTRUCT requires a value"
		name))
	 (setf (defstruct-description-eval-when) val))
	(:alterant
	 (setq alterant val))
	(:but-first
	 (if (emptyp val)
	     (defstruct-error
	       "The :BUT-FIRST option to DEFSTRUCT must have a value given"
	       name))
	 (setq but-first val)
	 (setf (defstruct-description-but-first) val))
	(:size-macro
	 (setf (defstruct-description-size-macro)
	       (if (emptyp val)
		   (defstruct-append-symbols name '-size)
		   val)))
	(:size-symbol
	 (setf (defstruct-description-size-symbol)
	       (if (emptyp val)
		   (defstruct-append-symbols name '-size)
		   val)))
	(:callable-accessors
	 (setf (defstruct-description-callable-accessors)
	       (if (emptyp val) t val)))
	(:CALLABLE-CONSTRUCTORS
	 (SETF (DEFSTRUCT-DESCRIPTION-CALLABLE-CONSTRUCTORS)
	       (IF (EMPTYP VAL) T VAL)))
	(:property
	 (if (emptyp val)
	     (defstruct-error
	       "The :PROPERTY option to DEFSTRUCT requires a value"
	       name))
	 (push (cons val (if (null (cdr vals)) t (cadr vals)))
	       (defstruct-description-property-alist)))
	(:initial-offset
	 (and (or (emptyp val)
		  (not (fixp val)))
	      (defstruct-error
		"The :INITIAL-OFFSET option to DEFSTRUCT requires a fixnum"
		name))
	 (setf (defstruct-description-initial-offset) val))
	(t
	 (cond ((get op 'defstruct-type-description)
		(or (emptyp val)
		    (defstruct-error
		      "DEFSTRUCT type used as an option with a value"
		      op 'in name))
		(setq type op))
	       (T
		(IF OLD (SETQ OP OLD)
		  (LET ((NEW (DEFSTRUCT-RETRY-KEYWORD OP)))
		    (UNLESS (EQ NEW OP)
		      (SETQ OLD OP OP NEW)
		      (GO AGAIN))))
		(PUSH (CONS NIL (CONS OP (IF (EMPTYP VAL) T VAL))) ;nil flags not explicit
		      (DEFSTRUCT-DESCRIPTION-PROPERTY-ALIST)))))))
    (WHEN (AND CLIP (EMPTYP (DEFSTRUCT-DESCRIPTION-PREDICATE)))
      (SETF (DEFSTRUCT-DESCRIPTION-PREDICATE)
	    (AND NAMED-P (DEFSTRUCT-APPEND-SYMBOLS NAME '-P))))	    
    (if (emptyp constructors)
	(setq constructors (list (cons (defstruct-append-symbols 'make- name)
				       nil))))
    (setf (defstruct-description-constructors) constructors)
    (cond ((emptyp alterant)
	   (SETQ ALTERANT (IF CLIP NIL
			   (defstruct-append-symbols 'alter- name)))))
    (setf (defstruct-description-alterant) alterant)
    (WHEN TYPE
      (SETQ SPEC (AND (CONSP TYPE) (CAR (POP TYPE))))	;translate clisp types.
      (LET ((TYPE-DESCRIPTION (OR (AND CLIP (EQ TYPE 'LIST)
				       (GET ':LIST 'DEFSTRUCT-TYPE-DESCRIPTION))
				  (AND CLIP (EQ TYPE 'VECTOR)
				       (GET ':VECTOR 'DEFSTRUCT-TYPE-DESCRIPTION))
				  (GET TYPE 'DEFSTRUCT-TYPE-DESCRIPTION)
				  (LET ((NEW (DEFSTRUCT-RETRY-KEYWORD TYPE)))
				    (IF (EQ TYPE NEW) NIL
				      (SETQ TYPE NEW)
				      (GET TYPE 'DEFSTRUCT-TYPE-DESCRIPTION)))
				  (DEFSTRUCT-ERROR
				    "Unknown type in DEFSTRUCT"
				    TYPE 'IN NAME))))
	(if named-p
	    (setq type
		  (or (defstruct-type-description-named-type)
		      (defstruct-error
			"There is no way to make a :NAMED defstruct of this type"
			type 'in name))))))
    (cond (included
	     (let ((d (get-defstruct-description included)))
	       (if (null type)
		   (setq type (defstruct-description-type d))
		 (or (eq type (defstruct-description-type d))
		     (defstruct-error
		       "defstruct types must agree for :INCLUDE option"
		       included 'included 'by name)))
	       ;;should we check for subtype compatibility??? Now? -- probably not.
	       (and named-p
		    (NEQ type (defstruct-type-description-named-type
				(or (get type 'defstruct-type-description)
				    (defstruct-error
				      "Unknown type in DEFSTRUCT"
				      type 'in name 'including included))))
		    (defstruct-error
		      ":INCLUDEd defstruct's type isn't a named type"
		      included 'included 'by name))
	       (if (null but-first)
		   (setf (defstruct-description-but-first)
			 (defstruct-description-but-first d))
		 (or (equal but-first (defstruct-description-but-first d))
		     (defstruct-error
		       ":BUT-FIRST options must agree for :INCLUDE option"
		       included 'included 'by name)))))
	  ((null type)
	   (setq type
	     (cond (named-p
		    1#+MacLisp-10 ':named-hunk*
		    1#+Multics ':named-list*
		    #+LispM (IF CLIP ':NAMED-VECTOR ':named-array)
		    1#+NIL ':extend*)
		   (t
		    1#+MacLisp-10 ':hunk*
		    1#+Multics ':list*
		    #+LispM (IF CLIP ':VECTOR ':array)
		    1#+NIL ':vector*)))))
    (let ((type-description (or (get type 'defstruct-type-description)
				(defstruct-error
				  "Undefined defstruct type"
				  type 'in name))))
      (setf (defstruct-description-type) type)
      (setf (defstruct-description-named-p)
	    (eq (defstruct-type-description-named-type) type))
      (DO ((X (DEFSTRUCT-DESCRIPTION-PROPERTY-ALIST) (CDR X)))	;check validity
	  ((NULL X))
	(OR (CAAR X)				;defined explicitly via (:property foo bar)
	    (IF (OR (MEMQ (CADAR X) (DEFSTRUCT-TYPE-DESCRIPTION-DEFSTRUCT-KEYWORDS))
		    (GET (CADAR X) ':DEFSTRUCT-OPTION))	;obsolete form
		(SETF (CAR X) (CDAR X))
	      (DEFSTRUCT-ERROR
		"DEFSTRUCT doesn't understand this option"
		(CAR X) 'IN NAME))))
      (OR (MEMQ ':SUBTYPE (DEFSTRUCT-TYPE-DESCRIPTION-DEFSTRUCT-KEYWORDS))
	  (SETF (DEFSTRUCT-DESCRIPTION-SUBTYPE) NIL)))
    description))

(defun defstruct-parse-items (items description)
  (let ((name (defstruct-description-name))
	(offset (defstruct-description-initial-offset))
	(include (defstruct-description-include))
	(o-slot-alist nil)
	(conc-name (defstruct-description-conc-name))
	1#+MacLisp-10 (chars (exploden conc-name))*)
    (or (null include)
	(let ((d (get (car include) 'defstruct-description)))
	  (setq offset (+ offset (defstruct-description-size d))) 
	  (setq o-slot-alist
		(COPYTREE (defstruct-description-slot-alist d)))
	  (DOLIST (L O-SLOT-ALIST)
	    (SETF (DEFSTRUCT-SLOT-DESCRIPTION-REF-MACRO-NAME (CDR L))
		  (IF CONC-NAME 1#+MACLISP-10 (IMPLODE (APPEND CHARS (EXPLODEN (CAR L))))*
		                #-MACLISP-10 (DEFSTRUCT-APPEND-SYMBOLS CONC-NAME (CAR L))
		      (CAR L))))
	  (DOLIST (L (CDR INCLUDE))
	    (LET* ((IT (IF (CONSP L) (CAR L) L))
		   (REST (IF (CONSP L) (CDR L) NIL))
		   (slot-description (cdr (assq it o-slot-alist))))
	      (if (null slot-description)
		(defstruct-error
		  "Unknown slot in :INCLUDEd defstruct"
		  it 'in include 'included 'by name))
	      (DEFSTRUCT-PARSE-ONE-FIELD
		IT NIL NIL REST CONC-NAME 1#+MACLISP-10 (EXPLODEN CONC-NAME)* SLOT-DESCRIPTION)))))
    (do ((i offset (1+ i))
	 (l items (cdr l))
	 (slot-alist nil)
	 )
	((null l)
	 (setq slot-alist (nreverse slot-alist))
	 (setf (defstruct-description-size) i)
	 (setf (defstruct-description-slot-alist)
	       (nconc o-slot-alist slot-alist)))	;now returns ALL slots
      (cond ((atom (car l))
	     (push (defstruct-parse-one-field
		     (car l) i nil nil conc-name1 #+MacLisp-10 chars*)
		   slot-alist))
	    ((atom (caar l))
	     (push (defstruct-parse-one-field
		     (caar l) i nil (cdar l) conc-name1 #+MacLisp-10 chars*)
		   slot-alist))
	    (t
	     (do ((ll (car l) (cdr ll)))
		 ((null ll))
	       (push (defstruct-parse-one-field
		       (caar ll) i (cadar ll)
		       (cddar ll) conc-name1 #+MacLisp-10 chars*)
		     slot-alist)))))))

(defun defstruct-parse-one-field (it number ppss rest conc-name1 #+MacLisp-10 chars*
				  &OPTIONAL SLOT-DESCRIPTION)
  (let* ((mname (if conc-name 1#+MacLisp-10 (implode (append chars (exploden it)))*
		              #-MacLisp-10 (defstruct-append-symbols conc-name it)
		    it))
	 (TYPE T) (ALIST NIL) (READ-ONLY NIL) (BITS NIL) (DOCUMENTATION NIL)
	 TYPEP INITP DOCP ROP
	 (INIT-CODE (IF (NULL REST) (MAKE-EMPTY)
		      (SETQ INITP T)
		      (DO ((L (CDR REST) (CDDR L)))
			  ((NULL L) (CAR REST))
			(SELECTQ (CAR L)
			  (:DOCUMENTATION (SETQ DOCUMENTATION (CADR L) DOCP T))
			  (:READ-ONLY (SETQ READ-ONLY (CADR L) ROP T))
			  (:TYPE (SETQ TYPE (CADR L) TYPEP T))
			  (T (DEFSTRUCT-ERROR
			       "Unknown DEFSTRUCT slot-option" (CAR L))))))))
    (IF (NULL SLOT-DESCRIPTION)
	(cons it (make-defstruct-slot-description
		   number number
		   ppss ppss
		   init-code INIT-CODE
		   ref-macro-name mname
		   TYPE TYPE
		   PROPERTY-ALIST ALIST
		   READ-ONLY READ-ONLY
		   BITS BITS
		   DOCUMENTATION DOCUMENTATION))
      (SETF (DEFSTRUCT-SLOT-DESCRIPTION-REF-MACRO-NAME) MNAME)
      (IF INITP (SETF (DEFSTRUCT-SLOT-DESCRIPTION-INIT-CODE) INIT-CODE))
      (IF DOCP  (SETF (DEFSTRUCT-SLOT-DESCRIPTION-DOCUMENTATION) DOCUMENTATION))
      (IF TYPEP (IF (SUBTYPEP TYPE (LET ((TEM (DEFSTRUCT-SLOT-DESCRIPTION-TYPE)))
				     (IF (EQ TEM 'NOTYPE) T TEM)))
		    (SETF (DEFSTRUCT-SLOT-DESCRIPTION-TYPE) TYPE)
		  (DEFSTRUCT-ERROR
		    "The slot :TYPE specified is incompatible with the :INCLUDEd slot type"
		    IT)))
      (IF ROP (IF (AND (DEFSTRUCT-SLOT-DESCRIPTION-READ-ONLY) (NOT READ-ONLY))
		  (DEFSTRUCT-ERROR "A slot is not :READ-ONLY, but the :INCLUDEd slot is"
				   IT)
		(SETF (DEFSTRUCT-SLOT-DESCRIPTION-READ-ONLY) READ-ONLY))))))

(defun defstruct-define-ref-macros (new-slots description)
  (let ((name (defstruct-description-name))
	(returns nil))
    (if (not (defstruct-description-callable-accessors))
	(do ((l new-slots (cdr l))
	     (mname))
	    ((null l))
	  (setq mname (defstruct-slot-description-ref-macro-name (cdar l)))
	  (defstruct-put-macro mname 'defstruct-expand-ref-macro)
	  (defstruct-putprop mname (cons name (caar l)) 'defstruct-slot))
      (let* ((type-description
	       (get (defstruct-description-type)
		    'defstruct-type-description))
	     (code (defstruct-type-description-ref-expander))
	     (n (defstruct-type-description-ref-no-args))
	     #+LispM
	     (parent `(,name defstruct))
	     (but-first (defstruct-description-but-first))
	     (default-pointer (defstruct-description-default-pointer)))
	(do ((args nil (cons (gensym) args))
	       (i n (1- i)))
	      ((< i 2)
	       ;;Last arg (if it exists) is name of structure,
	       ;; for documentation purposes.
	       (and (= i 1)
		    (setq args (cons name args)))
	       (let ((body (cons (if but-first
				     `(,but-first ,(car args))
				   (car args))
				 (cdr args))))
		 (and default-pointer
		      (setq args `((,(car args) ,default-pointer)
				   &optional ,@(cdr args))))
		 (setq args (reverse args))
		 (setq body (reverse body))
		 (do ((l new-slots (cdr l))
		      (mname))
		     ((null l))
		   (setq mname (defstruct-slot-description-ref-macro-name
				 (cdar l)))
		   (IF (DEFSTRUCT-SLOT-DESCRIPTION-READ-ONLY (CDAR L))
		       (DEFSTRUCT-PUTPROP MNAME '(MACRO . UNSETFABLE) 'SETF-METHOD))
		   1#+MacLisp *
		   1;;This must come BEFORE the defun. THINK!*
		   1(defstruct-put-macro mname 'defstruct-expand-ref-macro)*
		   (let ((ref (lexpr-funcall
				code
				(defstruct-slot-description-number (cdar l))
				description
				body))
			 (ppss (defstruct-slot-description-ppss (cdar l)))
			 (DOC (DEFSTRUCT-SLOT-DESCRIPTION-DOCUMENTATION (CDAR L))))
		     (push `(#+LispM		defsubst-with-parent
			     1#+NIL*		1defsubst*
			     1#-(or LispM NIL)*	1defun*
			     ,mname #+LispM ,parent ,args
			     ,DOC
			     ,(if (null ppss) ref `(ldb ,ppss ,ref)))
			   returns))
		   (defstruct-putprop mname
				      (cons name (caar l))
		     'defstruct-slot)))))))
    returns))

#+LispM 
(defprop defstruct-expand-cons-macro
	 defstruct-function-parent
	 macroexpander-function-parent)

#+LispM 
(defprop defstruct-expand-size-macro
	 defstruct-function-parent
	 macroexpander-function-parent)

#+LispM 
(defprop defstruct-expand-alter-macro
	 defstruct-function-parent
	 macroexpander-function-parent)

#+LispM 
(defprop defstruct-expand-ref-macro 
	 defstruct-function-parent
	 macroexpander-function-parent)

#+LispM
(defun defstruct-function-parent (sym)
  (values (or (get sym 'defstruct-name)
	      (car (get sym 'defstruct-slot)))
	  'defstruct))

(defun defstruct-expand-size-macro (x)
  (let ((description (get-defstruct-description (get (car x) 'defstruct-name))))
    (let ((type-description (or (get (defstruct-description-type)
				     'defstruct-type-description)
				(defstruct-error
				  "Unknown defstruct type"
				  (defstruct-description-type)))))
      (+ (defstruct-description-size)
	 (defstruct-type-description-overhead)))))

(defun defstruct-expand-ref-macro (x)
  (let* ((pair (get (car x) 'defstruct-slot))
	 (description (get-defstruct-description (car pair)))
	 (type-description (or (get (defstruct-description-type)
				    'defstruct-type-description)
			       (defstruct-error
				 "Unknown defstruct type"
				 (defstruct-description-type))))
	 (code (defstruct-type-description-ref-expander))
	 (n (defstruct-type-description-ref-no-args))
	 (args (reverse (cdr x)))
	 (nargs (length args))
	 (default (defstruct-description-default-pointer))
	 (but-first (defstruct-description-but-first)))
    (cond ((= n nargs)
	   (and but-first
		(rplaca args `(,but-first ,(car args)))))
	  ((and (= n (1+ nargs)) default)
	   (setq args (cons (if but-first
				`(,but-first ,default)
				default)
			    args)))
	  (t
	   (defstruct-error
	     "Wrong number of args to an accessor macro" x)))
    (let* ((slot-description 
	     (cdr (or (assq (cdr pair)
			    (defstruct-description-slot-alist))
		      (defstruct-error
			"This slot no longer exists in this structure"
			(cdr pair) 'in (car pair)))))
	    (ref (lexpr-funcall
		   code
		   (defstruct-slot-description-number)
		   description
		   (nreverse args)))
	    (ppss (defstruct-slot-description-ppss)))
      (if (null ppss)
	  ref
	  `(ldb ,ppss ,ref)))))

(defun defstruct-parse-setq-style-slots (l slots others x)
  (do ((l l (cddr l))
       (kludge (cons nil nil)))
      ((null l) kludge)
    (or (and (cdr l)
	     (symbolp (car l)))
	(defstruct-error
	  "Bad argument list to constructor or alterant macro" x))
    (defstruct-make-init-dsc kludge (car l) (cadr l) slots others x)))

(defun defstruct-make-init-dsc (kludge name code slots others x)
  (let ((p (OR (assq name slots)
	       ;;clisp uses keywords -- this is if (:callable-constructors nil) specified
	       (ASS #'STRING= (GET-PNAME NAME) SLOTS))))
    (if (null p)
	(if (memq name others)
	    (push (cons name code) (cdr kludge))
	  (let ((new (defstruct-retry-keyword name)))
	    (if (memq new others)
		(push (cons new code) (cdr kludge))
	      (defstruct-error
		"Unknown slot to constructor or alterant macro"
		name 'in x))))
      (let* ((slot-description (cdr p))
	     (number (defstruct-slot-description-number))
	     (ppss (defstruct-slot-description-ppss))
	     (dsc (assoc number (car kludge))))
	(cond ((null dsc)
	       (setq dsc (list* number nil (make-empty) 0 0 nil))
	       (push dsc (car kludge))))
	(cond ((null ppss)
	       (setf (car (cddr dsc)) code)
	       (setf (cadr dsc) t))
	      (t (cond ((and (numberp ppss) (numberp code))
			(setf (ldb ppss (cadr (cddr dsc))) -1)
			(setf (ldb ppss (caddr (cddr dsc))) code))
		       (t
			(push (cons ppss code) (cdddr (cddr dsc)))))
		 (or (eq t (cadr dsc))
		     (push name (cadr dsc)))))))))

(defun defstruct-code-from-dsc (dsc)
  (let ((code (car (cddr dsc)))
	(mask (cadr (cddr dsc)))
	(bits (caddr (cddr dsc))))
    (if (emptyp code)
	(setq code bits)
	(or (zerop mask)
	    (setq code (if (numberp code)
			   (boole 7 bits (boole 2 mask code))
			   (if (zerop (logand mask
					      (1+ (logior mask (1- mask)))))
			       (let ((ss (haulong (boole 2 mask (1- mask)))))
				 `(dpb ,(lsh bits (- ss))
				       ,(logior (lsh ss 6)
						(logand #o77
							(- (haulong mask) ss)))
				       ,code))
			       `(boole 7 ,bits (boole 2 ,mask ,code)))))))
    (do ((l (cdddr (cddr dsc)) (cdr l)))
	((null l))
      (setq code `(dpb ,(cdar l) ,(caar l) ,code)))
    code))

(defun defstruct-expand-cons-macro (x)
  (let* ((description (get-defstruct-description (get (car x) 'defstruct-name)))
	 (type-description (or (get (defstruct-description-type)
				    'defstruct-type-description)
			       (defstruct-error
				 "Unknown defstruct type"
				 (defstruct-description-type))))
	 (slot-alist (defstruct-description-slot-alist))
	 (cons-keywords (defstruct-type-description-cons-keywords))
	 (kludge nil)
	 (constructor-description 
	   (cdr (or (assq (car x) (defstruct-description-constructors))
		    (defstruct-error
		      "This constructor is no longer defined for this structure"
		      (car x) 'in (defstruct-description-name)))))
	 (aux nil)
	 (aux-init nil))
     (if (null constructor-description)
	 (setq kludge (defstruct-parse-setq-style-slots (cdr x)
							slot-alist
							cons-keywords
							x))
       (prog (args l)
	     (setq kludge (cons nil nil))
	     (setq args (cdr x))
	     (setq l (car constructor-description))
	  R  (cond ((null l)
		    (if (null args)
			(return nil)
		      (go barf-tma)))
		   ((atom l) (go barf))
		   ((eq (car l) '&optional) (go O))
		   ((eq (car l) '&rest) (go S))
		   ((eq (car l) '&aux) (go A))
		   ((null args) (go barf-tfa)))
	     (defstruct-make-init-dsc kludge
				      (pop l)
	                              (pop args)
				      slot-alist
                                      cons-keywords
                                      x)
             (go R)
          O  (and (null args) (go OD))
             (pop l)
             (cond ((null l) (go barf-tma))
                   ((atom l) (go barf))
                   ((eq (car l) '&optional) (go barf))
                   ((eq (car l) '&rest) (go S))
                   ((eq (car l) '&aux) (go barf-tma)))
             (defstruct-make-init-dsc kludge
                                      (if (atom (car l)) (car l) (caar l))
                                      (pop args)
                                      slot-alist
                                      cons-keywords
                                      x)
             (go O)
          OD (pop l)
             (cond ((null l) (return nil))
                   ((atom l) (go barf))
                   ((eq (car l) '&optional) (go barf))
                   ((eq (car l) '&rest) (go S))
                   ((eq (car l) '&aux) (go A)))
             (or (atom (car l))
                 (defstruct-make-init-dsc kludge
                                          (caar l)
                                          (cadar l)
                                          slot-alist
                                          cons-keywords
                                          x))
             (go OD)
          S  (and (atom (cdr l)) (go barf))
             (defstruct-make-init-dsc kludge
                                      (cadr l)
                                      `(list ,@args)
                                      slot-alist
                                      cons-keywords
                                      x)
             (setq l (cddr l))
             (and (null l) (return nil))
	     (and (atom l) (go barf))
	     (or (eq (car l) '&aux) (go barf))
	  A  (pop l)
	     (cond ((null l) (return nil))
		   ((atom l) (go barf))
		   ((atom (car l))
		    (push (car l) aux)
		    (push (make-empty) aux-init))
		   (t
		    (push (caar l) aux)
		    (push (cadar l) aux-init)))
	     (go A)
	  BARF (defstruct-error
		 "Bad format for defstruct constructor arglist"
		 `(,(car x) ,@(car constructor-description)))
	  BARF-TFA (defstruct-error "Too few arguments to constructor macro" x)
	  BARF-TMA (defstruct-error "Too many arguments to constructor macro" x)))
     (do ((l slot-alist (cdr l)))
	 ((null l))
       (let* ((name (caar l))
	      (slot-description (cdar l))
	      (code (do ((aux aux (cdr aux))
			 (aux-init aux-init (cdr aux-init)))
			((null aux) (defstruct-slot-description-init-code))
		      (and (eq name (car aux)) (return (car aux-init)))))
	      (ppss (defstruct-slot-description-ppss)))
	 (or (and (emptyp code) (null ppss))
	     (let* ((number (defstruct-slot-description-number))
		    (dsc (assoc number (car kludge))))
	       (cond ((null dsc)
		      (setq dsc (list* number nil (make-empty) 0 0 nil))
		      (push dsc (car kludge))))
	       (cond ((emptyp code))
		     ((eq t (cadr dsc)))
		     ((null ppss)
		      (and (emptyp (car (cddr dsc)))
			   (setf (car (cddr dsc)) code)))
		     ((memq name (cadr dsc)))
		     ((and (numberp ppss) (numberp code))
		      (setf (ldb ppss (cadr (cddr dsc))) -1)
		      (setf (ldb ppss (caddr (cddr dsc))) code))
		     (t
		      (push (cons ppss code) (cdddr (cddr dsc)))))))))
     (do ((l (car kludge) (cdr l)))
	 ((null l))
       (rplacd (car l) (defstruct-code-from-dsc (car l))))
     (invoke-defstruct-constructor-expander
       description type-description
       (car kludge) (cdr kludge))))

;;; callable, clisp-style constructors
(DEFUN DEFSTRUCT-DEFINE-CONSTRUCTORS (DESCRIPTION)
  (LET ((NAME (DEFSTRUCT-DESCRIPTION-NAME))
	RETURNS)
    (IF (NOT (DEFSTRUCT-DESCRIPTION-CALLABLE-CONSTRUCTORS))
	(DOLIST (CS (DEFSTRUCT-DESCRIPTION-CONSTRUCTORS))
	  (DEFSTRUCT-PUT-MACRO (CAR CS) 'DEFSTRUCT-EXPAND-CONS-MACRO)
	  (DEFSTRUCT-PUTPROP (CAR CS) NAME 'DEFSTRUCT-NAME))
      (LET* ((SLOT-ALIST (DEFSTRUCT-DESCRIPTION-SLOT-ALIST))
	     (SIZE (DEFSTRUCT-DESCRIPTION-SIZE))
	     (TYPE-DESCRIPTION (GET (DEFSTRUCT-DESCRIPTION-TYPE) 'DEFSTRUCT-TYPE-DESCRIPTION))
	     (CONS-KEYWORDS (DEFSTRUCT-TYPE-DESCRIPTION-CONS-KEYWORDS))
	     (FL (DEFSTRUCT-TYPE-DESCRIPTION-CONS-FLAVOR))
	     MNAME BODY SYM ARGLIST ARGS REST FROB FROBPPSS X S INIT INIT-LIST BOAP
	     OPT OPTPPSS OPT-SLOT OPTPPSS-SLOT FLAGS PPSS-FLAGS
	     NOPT NOPTPPSS NOPT-SLOT NOPTPPSS-SLOT
	     (F (GENSYM)) (L (GENSYM)) (R (GENSYM)) (D (GENSYM)) (Y (GENSYM))
	     (SL (GENSYM)) (TEM (GENSYM))
	     CW CWN
	     (CONS-WORDS (DO ((V CONS-KEYWORDS (CDR V))
			      R W)
			     ((NULL V) R)
			   ;;will this win everywhere?
			   (SETQ W (INTERN (GET-PNAME (CAR V))))	;in *package*
			   (PUSH W CW)
			   (PUSH (LIST 'QUOTE (CAR V)) CW)
			   (PUSH (GENSYM) CW)
			   (PUSH (LIST W NIL (CAR CW)) R)
			   (PUSH W CWN)))
	     )
	(DOLIST (CS (DEFSTRUCT-DESCRIPTION-CONSTRUCTORS))
	  (SETQ MNAME (CAR CS) BOAP T
		ARGLIST () ARGS () REST NIL
		OPT () OPT-SLOT () FLAGS () OPTPPSS () OPTPPSS-SLOT () PPSS-FLAGS ()
		NOPT () NOPT-SLOT () NOPTPPSS () NOPTPPSS-SLOT ())
	  (IF (CDR CS)
	      ;;it's a boa-constructor!
	      (IF (CDDR CS) (DEFSTRUCT-ERROR
			      "DEFSTRUCT constructors can only be specified by arglist"
			      CS)
		(DO ((AL (CADR CS)))
		    (NIL)
		 REQUIRED
		  (SELECTQ (SETQ X (POP AL))
		    (&OPTIONAL (GO OPTIONAL))
		    (&REST (GO REST))
		    (&AUX (GO AUX))
		    (NIL (RETURN))
		    (T (OR (SETQ S (CDR (ASSOC X SLOT-ALIST))) (GO SLOT-ERROR))
		       (PUSH X ARGS)
		       (PUSH X ARGLIST)
		       (IF (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S)
			   (PROGN (PUSH X NOPTPPSS)
				  (PUSH (CONS (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
					      (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S))
					NOPTPPSS-SLOT))
			 (PUSH X NOPT)
			 (PUSH (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
			       NOPT-SLOT))
		       (GO REQUIRED)))
		 OPTIONAL
		  (PUSH '&OPTIONAL ARGS)
		  (PUSH '&OPTIONAL ARGLIST)
		 OPT
		  (SELECTQ (SETQ X (POP AL))
		    (&OPTIONAL (GO OPT))
		    (&REST (GO REST))
		    (&AUX (GO AUX))
		    (NIL (RETURN))
		    (T (PUSH X ARGLIST)		     
		       (IF (CONSP X)
			   (IF (CDDR X) (GO ARG-ERROR)
			     (PSETQ X (CAR X) INIT (CADR X)))
			 (SETQ INIT (MAKE-EMPTY)))
		       (OR (SETQ S (CDR (ASSOC X SLOT-ALIST))) (GO SLOT-ERROR))
		       (IF (EMPTYP INIT) (SETQ INIT (DEFSTRUCT-SLOT-DESCRIPTION-INIT-CODE S)))
		       (IF (EMPTYP INIT)
			   (PROGN
			     (SETQ SYM (GENSYM))
			     (PUSH (LIST X NIL SYM) ARGS)
			     (IF (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S)
				 (PROGN (PUSH SYM PPSS-FLAGS)
					(PUSH X OPTPPSS)
					(PUSH (CONS (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
						    (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S))
					      OPTPPSS-SLOT))
			       (PUSH SYM FLAGS)
			       (PUSH X OPT)
			       (PUSH (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
				     OPT-SLOT)))
			 (PUSH (LIST X INIT) ARGS)
			 (IF (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S)
			     (PROGN (PUSH X NOPTPPSS)
				    (PUSH (CONS (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
						(DEFSTRUCT-SLOT-DESCRIPTION-PPSS S))
					  NOPTPPSS-SLOT))
			   (PUSH X NOPT)
			   (PUSH (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
				 NOPT-SLOT)))
		       (GO OPT)))
		 REST
		  (PUSH '&REST ARGS)
		  (PUSH '&REST ARGLIST)
		  (SELECTQ (SETQ X (POP AL))
		    ((&OPTIONAL &REST &AUX NIL) (GO ARG-ERROR))
		    (T (OR (SETQ S (CDR (ASSOC X SLOT-ALIST))) (GO SLOT-ERROR))
		       (SETQ REST X)
		       (PUSH X ARGS)
		       (PUSH X ARGLIST)
		       (IF (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S)
			   (PROGN (PUSH X NOPTPPSS)
				  (PUSH (CONS (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
					      (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S))
					NOPTPPSS-SLOT))
			 (PUSH X NOPT)
			 (PUSH (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
			       NOPT-SLOT))
		       (SELECTQ (SETQ X (POP AL))
			 (&AUX (GO AUX))
			 (NIL (RETURN))
			 (T (GO ARG-ERROR)))))
		 AUX
		  (PUSH '&AUX ARGLIST)
		  (PUSH '&AUX ARGS)
		 OX
		  (SELECTQ (SETQ X (POP AL))
		    ((&OPTIONAL &REST &AUX) (GO ARG-ERROR))
		    (NIL (RETURN))
		    (T (PUSH X ARGLIST)
		       (IF (CONSP X)
			   (IF (CDDR X) (GO ARG-ERROR)
			     (PSETQ X (CAR X) INIT (CADR X)))
			 (SETQ INIT (MAKE-EMPTY)))
		       (OR (SETQ S (CDR (ASSOC X SLOT-ALIST))) (GO SLOT-ERROR))
		       (IF (EMPTYP INIT) (SETQ INIT (DEFSTRUCT-SLOT-DESCRIPTION-INIT-CODE S)))
		       (IF (EMPTYP INIT) NIL
			 (PUSH (LIST X INIT) ARGS)
			 (IF (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S)
			     (PROGN (PUSH X OPTPPSS)
				    (PUSH (CONS (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
						(DEFSTRUCT-SLOT-DESCRIPTION-PPSS S))
					  NOPTPPSS-SLOT))
			   (PUSH X NOPT)
			   (PUSH (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
				 NOPT-SLOT)))
		       (GO OX)))
		 ARG-ERROR
		  (DEFSTRUCT-ERROR "Bad defstruct :CONSTRUCTOR argument list" AL 'FOR MNAME)
		 SLOT-ERROR
		  (DEFSTRUCT-ERROR "Invalid defstruct slot-name" X 'WHILE 'DEFINING MNAME)))
	    ;;do this for non-boa-constructors
	    (SETQ BOAP NIL)
	    (PUSH '&KEY ARGLIST)
	    (PUSH '&KEY ARGS)
	    (DOLIST (S SLOT-ALIST)
	      (SETQ X (CAR S) S (CDR S)		;standardize our nomenclature
		    INIT (DEFSTRUCT-SLOT-DESCRIPTION-INIT-CODE S))
	      (IF (EMPTYP INIT)
		  (PROGN
		    (PUSH X ARGLIST)
		    (SETQ SYM (GENSYM))
		    (PUSH (LIST X NIL SYM) ARGS)
		    (IF (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S)
			(PROGN (PUSH SYM PPSS-FLAGS)
			       (PUSH X OPTPPSS)
			       (PUSH (CONS (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
					   (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S))
				     OPTPPSS-SLOT))
		      (PUSH SYM FLAGS)
		      (PUSH X OPT)
		      (PUSH (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
			    OPT-SLOT)))
		(PUSH (LIST X INIT) ARGS)
		(PUSH (CAR ARGS) ARGLIST)
		(IF (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S)
		    (PROGN (PUSH X NOPTPPSS)
			   (PUSH (CONS (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
				       (DEFSTRUCT-SLOT-DESCRIPTION-PPSS S))
				 NOPTPPSS-SLOT))
		  (PUSH X NOPT)
		  (PUSH (DEFSTRUCT-SLOT-DESCRIPTION-NUMBER S)
			NOPT-SLOT))))
	    (WHEN CONS-KEYWORDS
	      (SETQ ARGLIST (NCONC (REVERSE CONS-KEYWORDS) (LIST* '&OPTIONAL NIL) ARGLIST))
	      (SETQ ARGS (NCONC (COPYLIST* CONS-WORDS) ARGS))))
	  ;;crunch the args now that we've snarfed them
	  (SETQ ARGLIST (NREVERSE ARGLIST) ARGS (NREVERSE ARGS))
          (SELECTQ FL
	      (:LIST
	       (SETQ INIT-LIST (MAKE-LIST SIZE))
	       (DO ((X INIT-LIST (CDR X))) ((NULL X))
		 (SETF (CAR X) (LIST 'QUOTE NIL)))
	       (DOLIST (X SLOT-ALIST)		;put zero inits where appropriate
		 (IF (DEFSTRUCT-SLOT-DESCRIPTION-PPSS (CDR X)) (SETF (CADR (NTH (CAR X) INIT-LIST)) 0)))
	       (SETQ FROB `((SETF (CADR (NTH (CAR ,SL) ,L))) (CAR ,Y))))
	       (SETQ FROBPPSS `((SETF (LDB (CDAR ,SL) (CADR (NTH (CAAR ,SL) ,L))) (CAR ,Y))))
	      (:ALIST
	       (SETQ INIT-LIST ())
	       (SETQ FROB `((IF (SETQ ,TEM (ASSOC (CAR ,SL) ,L))
				(SETF (CADDR ,TEM) (CAR ,Y))
			      (PUSH (CONS (CAR ,SL) (LIST 'QUOTE (CAR ,Y))) ,L))))
	       (SETQ FROBPPSS `((IF (SETQ ,TEM (ASSOC (CAAR ,SL) ,L))
				    (SETF (LDB (CDAR ,S) (CADDR ,TEM)) (CAR ,Y))
				  (PUSH (CONS (CAAR ,SL) (DPB (CAR ,Y) (CDAR ,SL) 0)) ,L)))))
	      (T (DEFSTRUCT-ERROR
		   "Unknown constructor kind"
		   FL 'IN TYPE-DESCRIPTION)))
	    (SETQ BODY
		  (NCONC (IF INIT-LIST
			     `((SETQ ,L ,INIT-LIST)))
			 #+LISPM				;needed elsewhere??
			 (IF REST
			     `((SETQ ,REST (COPYLIST ,REST))))	;can't trust stack lists
			 (IF (AND (NOT BOAP) CONS-KEYWORDS)
			     `((DO ((,F (LIST ,@CW) (CDDDR ,F)))
				   ((NULL ,F))
				 (WHEN (CAR ,F)
				   (PUSH (CONS (CADR ,F) (CADDR ,F)) ,R)))
			       ,@CWN))				;prevent compiler barfage
			 (IF OPT
			     `((DO ((,F (LIST ,@FLAGS) (CDR ,F))
				    (,SL ',OPT-SLOT (CDR ,SL))
				    (,Y (LIST ,@OPT) (CDR ,Y)))
				   ((NULL ,Y))
				 (WHEN (CAR ,F) ,@FROB))))
			 (IF OPTPPSS
			     `((DO ((,F (LIST ,@PPSS-FLAGS) (CDR ,F))
				    (,SL ',OPTPPSS-SLOT (CDR ,SL))
				    (,Y (LIST ,@OPTPPSS) (CDR ,Y)))
				   ((NULL ,Y))
				 (WHEN (CAR ,F) ,@FROBPPSS))))
			 (IF NOPT
			     `((DO ((,SL ',NOPT-SLOT (CDR ,SL))
				    (,Y (LIST ,@NOPT) (CDR ,Y)))
				   ((NULL ,Y))
				 ,@FROB)))
			 (IF NOPTPPSS
			     `((DO ((,SL ',NOPTPPSS-SLOT (CDR ,SL))
				    (,Y (LIST ,@NOPTPPSS) (CDR ,Y)))
				   ((NULL ,Y))
				 ,@FROBPPSS)))))
	    (DEFSTRUCT-PUTPROP MNAME NAME 'DEFSTRUCT-NAME)
	    (PUSH 
	      `(DEFUN ,MNAME ,ARGS
		 (DECLARE (ARGLIST ,ARGLIST))
		 (LET ((,D (GET-DEFSTRUCT-DESCRIPTION ',NAME))
		       ,L ,TEM ,R)
		   ,@BODY
		   (EVAL 
		     (FUNCALL (DEFSTRUCT-TYPE-DESCRIPTION-CONS-EXPANDER
				(GET (DEFSTRUCT-DESCRIPTION-TYPE ,D) 'DEFSTRUCT-TYPE-DESCRIPTION))
			      ,L
			      ,D
			      ,R))))
	      RETURNS))))
    RETURNS))

(defun invoke-defstruct-constructor-expander (description type-description arg etc)
  (funcall (defstruct-type-description-cons-expander)
	   (selectq (defstruct-type-description-cons-flavor)
	     (:list
	      (do ((l nil (cons nil l))
		   (i (defstruct-description-size) (1- i)))
		  ((= i 0)
		   (do ((arg arg (cdr arg)))
		       ((null arg))
		     (setf (nth (caar arg) l) (cdar arg)))
		   l)))
	     (:alist arg)
	     (t
	      (defstruct-error
		"Unknown constructor kind in this defstruct type"
		(defstruct-description-type))))
	   description etc))

(defun defstruct-expand-alter-macro (x)
  (let* ((description (get-defstruct-description (get (car x) 'defstruct-name)))
	 (type-description (or (get (defstruct-description-type)
				    'defstruct-type-description)
			       (defstruct-error
				 "Unknown defstruct type"
				 (defstruct-description-type))))
	 (ref-code (defstruct-type-description-ref-expander))
	 (ref-nargs (defstruct-type-description-ref-no-args)))
    (do ((l (car (defstruct-parse-setq-style-slots 
		   (nthcdr (1+ ref-nargs) x)
		   (defstruct-description-slot-alist)
		   nil
		   x))
	    (cdr l))
	 (but-first (defstruct-description-but-first))
	 (body nil)
	 (avars (do ((i 0 (1+ i))
		     (l nil (cons (gensym) l)))
		    ((= i ref-nargs) l)))
	 (vars nil)
	 (vals nil))
	((null l)
	 `((lambda ,avars
	     ,@(if (null vars)
		   body
		   `(((lambda ,vars ,@body) ,.vals))))
	   ,@(do ((i (1- ref-nargs) (1- i))
		  (l `(,(if but-first
			    `(,but-first ,(nth ref-nargs x))
			    (nth ref-nargs x)))
		     (cons (nth i x) l)))
		 ((= i 0) l))))
      (let ((ref (lexpr-funcall ref-code (caar l) description avars)))
	(and (emptyp (car (cddr (car l))))
	     (setf (car (cddr (car l))) ref))
	(let ((code (defstruct-code-from-dsc (car l))))
	  (if (null (cdr l))
	      (push `(setf ,ref ,code) body)
	      (let ((sym (gensym)))
		(push `(setf ,ref ,sym) body)
		(push sym vars)
		(push code vals))))))))

(defmacro defstruct-define-type (type &body options)
  "Defines a new type of defstruct structure, with name TYPE.
OPTIONS may include:
 (:CONS (init desc kwds) kind body)
   Body returns code to construct a structure of type TYPE. Init, desc and kwds are bound to
     the initialization defaults, the structure description and an alist of values of
     additional keywords arguments supplied to DEFSTRUCT. Kind is either :LIST or :ALIST.
 (:REF (slot-number desc arg-1 arg-2 ...) body)
   Body returns the contents of slot-number in the structure. desc is bound to the structure
    description. The arg-n's are bound to values supplied to the accessor as arguments.
 (:OVERHEAD slots)
   Reserves a given number of slots as overhead to this structure-type, which are thus
     unavailable for storing structure data.
 :NAMED
   Indicates that this is a named structure-type.
 (:NAMED named-type)
   Defines the associated named structure type to this unnamed TYPE.
 (:CONS-KEYWORDS kwd-1 ...) or (:KEYWORDS kwd-1 ...)
   Defines keywords which may be supplied to a constructor to affect the construction of an
     instance of this structure. These keywords will appear in the kwds alist supplied to the
     :CONS code.
 (:DEFSTRUCT-KEYWORDS kwd-1 ...)
   Defines keywords which may be supplied to DEFSTRUCT to affect the definition of a stucture
     of this TYPE. These keywords will appear in the property-alist slot of the desc supplied
     to the :defstruct code
 (:PREDICATE (desc name) body)
   Body is code which generates a predicate named name for a structure with description desc.
 (:COPIER (desc name) body)
   Body defines code to define a structure-copier named name.
 (:DEFSTRUCT (desc) body)
   Body is run whenever DEFSTRUCT expands a structure of this TYPE. It should return a list
     of forms to be included in the DEFSTRUCT expansion, or else NIL."
  (DO* ((DOC (IF (STRINGP (CAR OPTIONS)) (POP OPTIONS)))
	(options options (cdr options))
	(op) (args)
	(type-description (make-defstruct-type-description))
	(cons-expander nil)
	(ref-expander nil)
	(returns))
       ((null options)
	(SETF (DEFSTRUCT-TYPE-DESCRIPTION-DOCUMENTATION) DOC)
	(or cons-expander
	    (defstruct-error "No :CONS option in DEFSTRUCT-DEFINE-TYPE" type))
	(or ref-expander
	    (defstruct-error "No :REF option in DEFSTRUCT-DEFINE-TYPE" type))
	`(progn 'compile
		#+LISPM
		(LOCAL-DECLARE ((FUNCTION-PARENT ',TYPE 'DEFSTRUCT-DEFINE-TYPE))
		  ,cons-expander
		  ,ref-expander
		  ,@returns)
		#-LISPM ,cons-expander
		#-LISPM ,ref-expander
		#-LISPM ,@RETURNS
		(defprop ,type ,type-description defstruct-type-description)
		',TYPE))
    (cond ((atom (setq op (car options)))
	   (setq args nil))
	  (t
	   (setq args (cdr op))
	   (setq op (car op))))
 AGAIN
    (selectq op
      (:cons
	(or (> (length args) 2)
	    (defstruct-error
	      "Bad :CONS option in DEFSTRUCT-DEFINE-TYPE"
	      (car options) 'in type))
	(let ((n (length (car args)))
	      (name (defstruct-append-symbols type '-defstruct-cons)))
	  (or (= n 3)
	      (defstruct-error
		"Bad :CONS option in DEFSTRUCT-DEFINE-TYPE"
		(car options) 'in type))
	  (setf (defstruct-type-description-cons-flavor)
		(defstruct-retry-keyword (cadr args)))
	  (setf (defstruct-type-description-cons-expander) name)
	  (setq cons-expander `(defun ,name ,(car args)
				 ,@(cddr args)))))
      (:ref
	(or (> (length args) 1)
	    (defstruct-error
	      "Bad :REF option in DEFSTRUCT-DEFINE-TYPE"
	      (car options) 'in type))
	(let ((n (length (car args)))
	      (name (defstruct-append-symbols type '-defstruct-ref)))
	  (or (> n 2)
	      (defstruct-error
		"Bad :REF option in DEFSTRUCT-DEFINE-TYPE"
		(car options) 'in type))
	  (setf (defstruct-type-description-ref-no-args) (- n 2))
	  (setf (defstruct-type-description-ref-expander) name)
	  (setq ref-expander `(defun ,name ,(car args)
				,@(cdr args)))))
      (:predicate
	(or (> (length args) 1)
	    (defstruct-error
	      "Bad :PREDICATE option in DEFSTRUCT-DEFINE-TYPE"
	      (car options) 'in type))
	(let ((name (defstruct-append-symbols type '-defstruct-predicate)))
	  (setf (defstruct-type-description-predicate) name)
	  (push `(defun ,name ,(car args)
		   ,@(cdr args))
		returns)))
      (:copier
	(or (> (length args) 1)
	    (defstruct-error
	      "Bad :COPIER option in DEFSTRUCT-DEFINE-TYPE"
	      (car options) 'in type))
	(let ((name (defstruct-append-symbols type '-defstruct-copier)))
	  (setf (defstruct-type-description-copier) name)
	  (push `(defun ,name ,(car args)
		   ,@(cdr args))
		returns)))
      (:overhead
	(setf (defstruct-type-description-overhead)
	      (if (null args)
		  (defstruct-error
		    "Bad :OVERHEAD option to DEFSTRUCT-DEFINE-TYPE"
		    (car options) 'in type)
		  (car args))))
      (:named
	(setf (defstruct-type-description-named-type)
	      (if (null args)
		  type
		  (car args))))
      ((:CONS-KEYWORDS :keywords)
	(setf (defstruct-type-description-cons-keywords) args))
      (:DEFSTRUCT-KEYWORDS
       (SETF (DEFSTRUCT-TYPE-DESCRIPTION-DEFSTRUCT-KEYWORDS) ARGS))
      (:defstruct
	(or (> (length args) 1)
	    (defstruct-error
	      "Bad :DEFSTRUCT option in DEFSTRUCT-DEFINE-TYPE"
	      (car options) 'in type))
	(let ((name (defstruct-append-symbols type '-defstruct-expand)))
	  (setf (defstruct-type-description-defstruct-expander) name)
	  (push `(defun ,name ,@args) returns)))
      (t
       (let ((new (defstruct-retry-keyword op)))
	 (cond ((not (eq op new))
		(setq op new)
		(go AGAIN)))
	 (defstruct-error
	   "Unknown option to DEFSTRUCT-DEFINE-TYPE"
	   op 'in type))))))

;#+LispM
;(defprop :make-array t :defstruct-option)

#+LispM
(defstruct-define-type :array
  (:named :named-array)
  (:CONS-KEYWORDS :make-array :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  (:DEFSTRUCT (DESCRIPTION)
    (DEFSTRUCT-HACK-ARRAY-SUPERTYPE DESCRIPTION))
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
			       description etc nil nil nil 1 NIL))
  (:ref (n description arg)
    description		;ignored
    `(aref ,arg ,n)))

#+LispM
(defstruct-define-type :named-array
  (:CONS-KEYWORDS :make-array :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  :named (:overhead 1)
  (:DEFSTRUCT (DESCRIPTION)
    (DEFSTRUCT-HACK-ARRAY-SUPERTYPE DESCRIPTION))
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,(1+ i)))
			       description etc nil t nil 1 NIL))
  (:ref (n description arg)
    description		;ignored
    `(aref ,arg ,(1+ n)))
  (:predicate (description name)
    `(defsubst ,name (x)
       (typep x ',(defstruct-description-name)))))

1#+MacLisp
(defstruct-define-type :array
  (:cons (arg description etc) :alist
    etc
    (maclisp-array-for-defstruct arg description 't))
  (:ref (n description arg)
    description*		1;ignored
    `(arraycall t ,arg ,n)))

#+NIL
(defstruct-define-type :array
  (:cons (arg description etc) :alist
    etc
    (NIL-array-for-defstruct arg description))
  (:ref (n description arg)
    description*		1;ignored
    `(aref ,arg ,n)))*

#+LISPM
(DEFSTRUCT-DEFINE-TYPE :TYPED-ARRAY		;an array with the named-structure-symbol
  (:NAMED :NAMED-TYPED-ARRAY)			;(if any) in the leader
  (:CONS-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  (:DEFSTRUCT (DESCRIPTION)
    (DEFSTRUCT-HACK-ARRAY-SUPERTYPE DESCRIPTION))
  (:CONS (ARG DESCRIPTION ETC) :ALIST
    (LISPM-ARRAY-FOR-DEFSTRUCT ARG #'(LAMBDA (V A I) `(ASET ,V ,A ,I))
			       DESCRIPTION ETC NIL NIL NIL 1 NIL))
  (:REF (N DESCRIPTION ARG)
    DESCRIPTION		;ignored
    `(AREF ,ARG ,N)))


#+LISPM
(DEFSTRUCT-DEFINE-TYPE :NAMED-TYPED-ARRAY	;type in leader -- data in array
  (:CONS-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  :NAMED
  (:DEFSTRUCT (DESCRIPTION)
    (DEFSTRUCT-HACK-ARRAY-SUPERTYPE DESCRIPTION))
  (:CONS (ARG DESCRIPTION ETC) :ALIST
    (LISPM-ARRAY-FOR-DEFSTRUCT ARG #'(LAMBDA (V A I) `(ASET ,V ,A ,I))
			       DESCRIPTION ETC NIL T NIL 1 T))
  (:REF (N DESCRIPTION ARG)
    DESCRIPTION		;ignored
    `(AREF ,ARG ,N))
  (:PREDICATE (DESCRIPTION NAME)
    `(DEFSUBST ,NAME (X)
       (TYPEP X ',(DEFSTRUCT-DESCRIPTION-NAME)))))

#+LISPM
(DEFSTRUCT-DEFINE-TYPE :VECTOR			;same as :TYPED-ARRAY
  (:NAMED :NAMED-VECTOR)
  (:CONS-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  (:DEFSTRUCT (DESCRIPTION)
    (DEFSTRUCT-HACK-ARRAY-SUPERTYPE DESCRIPTION))
  (:CONS (ARG DESCRIPTION ETC) :ALIST
    (LISPM-ARRAY-FOR-DEFSTRUCT ARG #'(LAMBDA (V A I) `(ASET ,V ,A ,I))
			       DESCRIPTION ETC NIL NIL NIL 1 NIL))
  (:REF (N DESCRIPTION ARG)
    DESCRIPTION		;ignored
    `(AREF ,ARG ,N)))

#+LISPM
(DEFSTRUCT-DEFINE-TYPE :NAMED-VECTOR		;same as :NAMED-TYPED-ARRAY
  (:CONS-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  :NAMED
  (:DEFSTRUCT (DESCRIPTION)
    (DEFSTRUCT-HACK-ARRAY-SUPERTYPE DESCRIPTION))
  (:CONS (ARG DESCRIPTION ETC) :ALIST
    (LISPM-ARRAY-FOR-DEFSTRUCT ARG #'(LAMBDA (V A I) `(ASET ,V ,A ,I))
			       DESCRIPTION ETC NIL T NIL 1 T))
  (:REF (N DESCRIPTION ARG)
    DESCRIPTION		;ignored
    `(AREF ,ARG ,N))
  (:PREDICATE (DESCRIPTION NAME)
    `(DEFSUBST ,NAME (X)
       (TYPEP X ',(DEFSTRUCT-DESCRIPTION-NAME)))))

1#+(or MacLisp-10 NIL)
(defstruct-define-type :vector
  (:named :named-vector)
  (:cons (arg description etc) :list
    description*		1;ignored
    etc*			1;ignored
    `(vector ,@arg))
  (:ref (n description arg)
    description*		1;ignored
    `(vref ,arg ,n)))

#+(or MacLisp-10 NIL)
(defstruct-define-type :named-vector
  :named (:overhead 1)
  (:cons (arg description etc) :list
    etc*			1;ignored
    `(vector ',(defstruct-description-name) ,@arg))
  (:ref (n description arg)
    description*		1;ignored
    `(vref ,arg ,(1+ n)))
  (:predicate (description name)
    `(defun ,name (x)
       (and (vectorp x)*
	1    (eq (vref x 0) ',(defstruct-description-name))))))*


#+LispM
(defstruct-define-type :fixnum-array
  (:CONS-KEYWORDS :make-array)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY)
  (:NAMED :NAMED-FIXNUM-ARRAY)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
			       description etc 'art-32b nil nil 1 NIL))
  (:ref (n description arg)
    description		;ignored
    `(aref ,arg ,n)))

#+LISPM
(DEFSTRUCT-DEFINE-TYPE :NAMED-FIXNUM-ARRAY
  (:CONS-KEYWORDS :MAKE-ARRAY)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY)
  :NAMED
  (:CONS (ARG DESCRIPTION ETC) :ALIST
    (LISPM-ARRAY-FOR-DEFSTRUCT ARG #'(LAMBDA (V A I) `(ASET ,V ,A ,I))
			       DESCRIPTION ETC 'ART-32B NIL NIL 1 NIL))
  (:REF (N DESCRIPTION ARG)
    DESCRIPTION		;ignored
    `(AREF ,ARG ,N)))

1#+MacLisp
(defstruct-define-type :fixnum-array
  (:cons (arg description etc) :alist
    etc
    (maclisp-array-for-defstruct arg description 'fixnum))
  (:ref (n description arg)
    description*		1;ignored
    `(arraycall fixnum ,arg ,n)))*

#+LispM
(defstruct-define-type :flonum-array
  (:CONS-KEYWORDS :make-array)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY)
  (:NAMED :NAMED-FLONUM-ARRAY)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
			       description etc 'art-float nil nil 1 NIL))
  (:ref (n description arg)
    description		;ignored
    `(aref ,arg ,n)))

#+LISPM
(DEFSTRUCT-DEFINE-TYPE :NAMED-FLONUM-ARRAY
  (:CONS-KEYWORDS :MAKE-ARRAY)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY)
  :NAMED
  (:CONS (ARG DESCRIPTION ETC) :ALIST
    (LISPM-ARRAY-FOR-DEFSTRUCT ARG #'(LAMBDA (V A I) `(ASET ,V ,A ,I))
			       DESCRIPTION ETC 'ART-FLOAT NIL NIL 1 T))
  (:REF (N DESCRIPTION ARG)
    DESCRIPTION		;ignored
    `(AREF ,ARG ,N)))

1#+MacLisp
(defstruct-define-type :flonum-array
  (:cons (arg description etc) :alist
    etc
    (maclisp-array-for-defstruct arg description 'flonum))
  (:ref (n description arg)
    description*		1;ignored
    `(arraycall flonum ,arg ,n)))

#+MacLisp-10
(defstruct-define-type :un-gc-array
  (:cons (arg description etc) :alist
    etc*			1;ignored
    (maclisp-array-for-defstruct arg description nil))
  (:ref (n description arg)
    description*		1;ignored
    `(arraycall nil ,arg ,n)))*

#+LispM
(defstruct-define-type :array-leader
  (:named :named-array-leader)
  (:CONS-KEYWORDS :make-array :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i)
				       `(store-array-leader ,v ,a ,i))
			       description etc nil nil t 1 NIL))
  (:ref (n description arg)
    description		;ignored
    `(array-leader ,arg ,n)))

#+LispM
(defstruct-define-type :named-array-leader
  (:CONS-KEYWORDS :make-array :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :SUBTYPE)
  :named (:overhead 1)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct
      arg
      #'(lambda (v a i)
	  `(store-array-leader ,v ,a ,(if (zerop i)
					  0
					  (1+ i))))
      description etc nil t t 1 T))
  (:ref (n description arg)
    description		;ignored
    (if (zerop n)
	`(array-leader ,arg 0)
	`(array-leader ,arg ,(1+ n))))
  (:predicate (description name)
    `(defsubst ,name (x)
       (typep x ',(defstruct-description-name)))))

;#+LispM
;(defprop :times t :defstruct-option)

#+LispM
(defstruct-define-type :grouped-array
  (:CONS-KEYWORDS :make-array :times :SUBTYPE)
  (:DEFSTRUCT-KEYWORDS :MAKE-ARRAY :TIMES :SUBTYPE)
  (:DEFSTRUCT (DESCRIPTION)
    (DEFSTRUCT-HACK-ARRAY-SUPERTYPE DESCRIPTION))
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct
      arg
      #'(lambda (v a i) `(aset ,v ,a ,i))
      description etc nil nil nil
      (or (cdr (or (assq ':times etc)
		   (assq ':times (defstruct-description-property-alist))))
	  1)
      NIL))
  (:ref (n description index arg)
    description		;ignored
    (cond ((numberp index)
	   `(aref ,arg ,(+ n index)))
	  ((zerop n)
	   `(aref ,arg ,index))
	  (t `(aref ,arg (+ ,n ,index))))))

#+LispM
(defun lispm-array-for-defstruct (arg
				  cons-init
				  description
				  etc
				  type
				  &OPTIONAL (NAMED-P NIL)
					    (LEADER-P NIL)
					    (TIMES 1)
					    (TYPE-IN-LEADER NIL)
				  &AUX (P (CONS NIL NIL))
				       NO-OP
				       ARRAY-TYPE)
;arg is slot arg
;cons-init is code to initialize the structure per-slot
;description is a structure description
;etc is cons-keyword args/values
;type is the array-type to make
;named-p is t if to make a named structure
;leader-p is t if the data is to be stored in the leader (as in :{named-}array-leader)
;times if the #times for :grouped-array
;type-in-leader is t if the structure-type is to be put in array-leader 1 rather than
; in aref 0
  (defstruct-grok-make-array-args
    (cdr (assq ':make-array (defstruct-description-property-alist)))
    p)
  (defstruct-grok-make-array-args
    (cdr (assq ':make-array etc))
    p)
  (COND (TYPE
	 (PUTPROP P TYPE ':TYPE))
	((SETQ TYPE (CDR (ASSQ ':SUBTYPE ETC)))
	 (PUTPROP P `',(SETQ TYPE (ARRAY-TYPE-FROM-ELEMENT-TYPE TYPE T)) ':TYPE))
	((SETQ TYPE (DEFSTRUCT-DESCRIPTION-SUBTYPE))
	 (PUTPROP P `',(SETQ TYPE (ARRAY-TYPE-FROM-ELEMENT-TYPE TYPE T)) ':TYPE)))
  (and named-p (putprop p `',(defstruct-description-name) ':named-structure-symbol))
  (putprop p
	   (let ((size (if named-p
			   (1+ (defstruct-description-size))
			 (defstruct-description-size))))
	     (if (numberp times)
		 (* size times)
	       `(* ,size ,times)))	     
	   (if leader-p ':leader-length ':dimensions))
  (AND TYPE-IN-LEADER (OR (NOT (GET P ':LEADER-LENGTH))
			  (< (GET P ':LEADER-LENGTH 2)))
       (PUTPROP P 2 ':LEADER-LENGTH))
  (SETQ ARRAY-TYPE (OR (LET ((TYPE (GET P ':TYPE)))
			 (OR (ATOM TYPE)
			     (NEQ (CAR TYPE) 'QUOTE)
			     (SETQ TYPE (CADR TYPE)))
			 (ARRAY-CANONICALIZE-TYPE TYPE))
		       'ART-Q))
  (OR LEADER-P
      (IF (OR (GET P ':INITIAL-ELEMENT)
	      (GET P ':INITIAL-VALUE))
	  (SETQ NO-OP (MAKE-EMPTY))
	(SETQ NO-OP (SELECTQ ARRAY-TYPE
		      ((NIL ART-Q ART-Q-LIST) NIL)
		      ((ART-32B ART-16B ART-8B ART-4B ART-2B ART-1B ART-HALF-FIX
				ART-STRING ART-FAT-STRING)
		       0)
		      ((ART-FLOAT ART-FPS-FLOAT)
		       0.0)
		      (ART-COMPLEX
		       (COMPLEX 0 0))
		      ((ART-COMPLEX-FLOAT ART-COMPLEX-FPS-FLOAT)
		       (COMPLEX 0.0 0.0))
		      (T (MAKE-EMPTY))))))
  ;;make sure that we can store tha named-structure-symbol safely
  (OR (NOT NAMED-P)
      (MEMQ ARRAY-TYPE '(ART-Q ART-Q-LIST ART-SPECIAL-PDL ART-REG-PDL ART-STACK-GROUP-HEAD))
      (GET P ':LEADER-LENGTH)
      (SETQ ARRAY-TYPE 'ART-Q)
      (PUTPROP P 'ART-Q ':TYPE))
  (do ((creator
	 (let ((dims (remprop p ':dimensions)))
	   (do ((l (cdr p) (cddr l)))
	       ((null l))
	     (rplaca l `',(car l)))
	   `(make-array ,(if (null dims) 0 (car dims)) ,@(cdr p))))
       (var (gensym))
       (set-ups nil (if (equal (cdar l) no-op)
			set-ups
		      (PUSH (funcall cons-init (cdar l) var (caar l)) SET-UPS)))
       (l arg (cdr l)))
      ((null l)
       (if set-ups
	   `((lambda (,var)
	       ,@(nreverse set-ups)
	       ,var)
	     ,creator)
	 creator))))

#+LISPM
(DEFUN DEFSTRUCT-GROK-MAKE-ARRAY-ARGS (ARGS P)
  (DO ((L ARGS (CDDR L)))
      ((NULL L) P)
    (UNLESS (AND (CDR L)
		 (MEMQ (CAR L) '(:AREA :TYPE :DISPLACED-TO :LEADER-LIST
				 :LEADER-LENGTH :DISPLACED-INDEX-OFFSET
				 :NAMED-STRUCTURE-SYMBOL :DIMENSIONS
				 :LENGTH :INITIAL-VALUE :INITIAL-ELEMENT :FILL-POINTER
				 :ELEMENT-TYPE)))
      (DEFSTRUCT-ERROR
	"DEFSTRUCT can't grok these MAKE-ARRAY arguments"
	ARGS))
    (PUTPROP P
	     (CADR L)
	     (IF (EQ (CAR L) ':LENGTH)
		 ':DIMENSIONS
		 (CAR L)))))
#+LISPM
(DEFUN DEFSTRUCT-HACK-ARRAY-SUPERTYPE (DESCRIPTION)
  (OR (DEFSTRUCT-DESCRIPTION-SUBTYPE)
      (DO* ((SL (DEFSTRUCT-DESCRIPTION-SLOT-ALIST) (CDR SL))
	    (SLOT-TYPE)
	    (TY ART-ERROR))
	   ((OR (NULL SL) (MEMQ TY '(ART-Q ART-ERROR)))
	    (IF (EQ TY 'ART-ERROR) (SETQ TY 'ART-Q))
	    (SETF (DEFSTRUCT-DESCRIPTION-SUBTYPE) TY))
	(SETQ SLOT-TYPE (DEFSTRUCT-SLOT-DESCRIPTION-TYPE (CDAR SL)))
	(IF (MEMQ SLOT-TYPE '(NIL T NOTYPE)) (SETQ SLOT-TYPE 'ART-Q))
	(SETQ TY (ARRAY-SUPERTYPE T TY (ARRAY-TYPE-FROM-ELEMENT-TYPE SLOT-TYPE T)))))
  NIL)

1#+NIL
(defun nil-array-for-defstruct (arg description)
  (do ((creator `(make-array ',(defstruct-description-size)))
       (var (gensym))
       (set-ups nil (if (null (cdar l))*
                        1set-ups*
                        1(cons `(aset ,(cdar l) ,var ,(caar l))*
                        1      set-ups)))
       (l arg (cdr l)))
      ((null l)
       (if set-ups*
        1   `((lambda (,var)*
        1       ,@(nreverse set-ups)*
        1       ,var)*
        1     ,creator)*
        1   creator))))

#+MacLisp
(defun maclisp-array-for-defstruct (arg description type)
  (do ((creator `(array nil ,type ,(defstruct-description-size)))
       (var (gensym))
       (no-op (caseq type*
                1(fixnum 0)*
                1(flonum 0.0)*
                1((t nil) nil)))
       (set-ups nil (if (equal (cdar l) no-op)*
                        1set-ups*
                        1(cons `(store (arraycall ,type ,var ,(caar l))*
                                1      ,(cdar l))*
                        1      set-ups)))
       (l arg (cdr l)))
      ((null l)
       (if set-ups*
        1   `((lambda (,var)*
        1       ,@(nreverse set-ups)*
        1       ,var)*
        1     ,creator)*
        1   creator))))*

1;#+(or MacLisp-10 NIL)
;(defprop :sfa-function t :defstruct-option)

;#+(or MacLisp-10 NIL)
;(defprop :sfa-name t :defstruct-option)

#+(or MacLisp-10 NIL)
(defstruct-define-type :sfa
  (:CONS-KEYWORDS :sfa-function :sfa-name)
  (:DEFSTRUCT-KEYWORDS :SFA-NAME :SFA-FUNCTION)
  (:cons (arg description etc) :alist
    (do ((creator `(sfa-create ,(or (cdr (or (assq ':sfa-function etc)*
                                        1     (assq ':sfa-function (defstruct-description-property-alist))))*
                                1     `',(defstruct-description-name))*
                        1       ,(defstruct-description-size)*
                        1       ,(or (cdr (or (assq ':sfa-name etc)*
                                        1     (assq ':sfa-name (defstruct-description-property-alist))))*
                                1    `',(defstruct-description-name))))*
        1 (l arg (cdr l))*
        1 (var (gensym))*
        1 (set-ups nil (if (null (cdar l))*
                        1  set-ups*
                        1  (cons `(sfa-store ,var ,(caar l)*
                                        1    ,(cdar l))*
                                1set-ups))))*
        1((null l)*
        1 (if set-ups*
        1     `((lambda (,var)*
                1 ,@(nreverse set-ups)*
                1 ,var)*
        1       ,creator)*
        1     creator))))
  (:ref (n description arg)
    description*     1;ignored
    `(sfa-get ,arg ,n))
  (:predicate (description name)
    `(defun ,name (x)
       (and (sfap x)*
        1    (eq (sfa-get x 'pname)*
                1,(or (cdr (assq ':sfa-name (defstruct-description-property-alist)))*
                1     `',(defstruct-description-name)))))))

#+MacLisp-10
(defstruct-define-type :hunk
  (:named :named-hunk)
  (:cons (arg description etc) :list
    description*     1;ignored
    etc*			1;ignored
    (if arg*
	1`(hunk ,.(nconc (cdr arg) (ncons (car arg))))*
	1(defstruct-error "No slots in hunk type defstruct")))
  (:ref (n description arg)
    description*		1;ignored
    `(cxr ,n ,arg)))

#+MacLisp-10
(defstruct-define-type :named-hunk
  :named (:overhead 1)
  (:cons (arg description etc) :list
    etc*			1;ignored
    (if arg*
	1`(hunk ',(defstruct-description-name)*
	1       ,.(nconc (cdr arg) (ncons (car arg))))*
	1`(hunk ',(defstruct-description-name) nil)))
  (:ref (n description arg)
    description*		1;ignored
    (cond ((= n 0) `(cxr 0 ,arg))*
	1  (t `(cxr ,(1+ n) ,arg))))
  (:predicate (description name)
    `(defun ,name (x)
       (and (hunkp x)*
	1    (eq (car x) ',(defstruct-description-name))))))*


;1#+NIL
;(defprop :class-symbol t :defstruct-option)

#+NIL
(defstruct-define-type :extend
  :named
  (:DEFSTUCT-KEYWORDS :CLASS-SYMBOL)
  (:defstruct (description)
    (if (assq ':class-symbol (defstruct-description-property-alist))*
	1;; if class-symbol is given then assume user is setting up*
	1;; his own class.*
	1()*
	1(let* ((name (defstruct-description-name))*
	1       (class-symbol (defstruct-append-symbols name '-class)))*
	1  (push (cons ':class-symbol class-symbol)*
		1(defstruct-description-property-alist))*
	1  `((defstruct-class-setup ,name ,class-symbol)))))
  (:cons (arg description etc) :alist
    etc*			1;ignored
    (do ((l arg (cdr l))*
	1 (creator `(si:make-extend*
		1    ,(defstruct-description-size)*
		1    ,(cdr (assq ':class-symbol*
				1(defstruct-description-property-alist)))))*
	1 (var (gensym))*
	1 (set-ups () (if (null (cdar l))*
			1 set-ups*
			1 (cons `(si:xset ,var ,(caar l) ,(cdar l))*
			1       set-ups))))*
	1((null l)*
	1 (if set-ups*
	1     `((lambda (,var)*
		1 ,.(nreverse set-ups)*
		1 ,var)*
	1       ,creator)*
	1     creator))))
  (:ref (n description arg)
    description*		1;ignored
    `(si:xref ,arg ,n))
  (:predicate (description name)
    `(defsubst ,name (x)
       (of-type x ',(defstruct-description-name)))))*

(defstruct-define-type :list
  (:named :named-list)
  (:cons (arg description etc) :list
    description		;ignored
    etc			;ignored
    `(list ,.arg))
  (:ref (n description arg)
    description		;ignored
1 #+Multics
    `(,(let ((i (\ n 4)))*
	1 (cond ((= i 0) 'car)*
	1       ((= i 1) 'cadr)*
	1       ((= i 2) 'caddr)*
	1       (t 'cadddr)))
      ,(do ((a arg `(cddddr ,a))*
	1    (i (// n 4) (1- i)))*
	1   ((= i 0) a)))*
 #-Multics
    `(nth ,n ,arg))
  (:copier (description name)
    (do ((l `((car x)) (cons `(prog1 (car x) (setq x (cdr x))) l))
	 (i (defstruct-description-size) (1- i)))
	((<= i 1)
	 `(defun ,name (x)
	    (list ,@l))))))

(defstruct-define-type :named-list
  :named (:overhead 1)
  (:cons (arg description etc) :list
    etc			;ignored
    `(list ',(defstruct-description-name) ,.arg))
  (:ref (n description arg)
    description		;ignored
1 #+Multics
    `(,(let ((i (\ (1+ n) 4)))*
	1 (cond ((= i 0) 'car)*
	1       ((= i 1) 'cadr)*
	1       ((= i 2) 'caddr)*
	1       (t 'cadddr)))
      ,(do ((a arg `(cddddr ,a))*
	1    (i (// (1+ n) 4) (1- i)))*
	1   ((= i 0) a)))*
 #-Multics
    `(nth ,(1+ n) ,arg))
  (:predicate (description name)
    `(defun ,name (x)
       (and
      #-MacLisp-10
	 (not (atom x))
      1#+MacLisp-10*	1;Watch out for hunks!*
	 1(eq (typep x) 'list)*
	1 *(eq (car x) ',(defstruct-description-name)))))
  (:copier (description name)
    (do ((l `((car x)) (cons `(prog1 (car x) (setq x (cdr x))) l))
	 (i (defstruct-description-size) (1- i)))
	((<= i 1)
	 `(defun ,name (x)
	    (setq x (cdr x))
	    (list ',(defstruct-description-name) ,@l))))))

(defstruct-define-type :list*
  (:cons (arg description etc) :list
    description		;ignored
    etc			;ignored
    `(list* ,.arg))
  (:ref (n description arg)
    (let ((size (1- (defstruct-description-size))))
1   #+Multics
      (do ((a arg `(cddddr ,a))*
	1   (i (// n 4) (1- i)))*
	1  ((= i 0)*
	1   (let* ((i (\ n 4))*
		1  (a (cond ((= i 0) a)*
			1   ((= i 1) `(cdr ,a))*
			1   ((= i 2) `(cddr ,a))*
			1   (t `(cdddr ,a)))))*
	1     (if (< n size) `(car ,a) a))))*
   #-Multics
      (if (< n size)
	  `(nth ,n ,arg)
	  `(nthcdr ,n ,arg))))
  (:defstruct (description)
    (and (defstruct-description-include)
	 (defstruct-error
	   "Structure of type :LIST* cannot include another"
	   (defstruct-description-name)))
    nil)
  (:copier (description name)
    (do ((l `(x) (cons `(prog1 (car x) (setq x (cdr x))) l))
	 (i (defstruct-description-size) (1- i)))
	((<= i 1)
	 `(defun ,name (x)
	    (list* ,@l))))))

(defstruct-define-type :tree
  (:cons (arg description etc) :list
    etc			;ignored
    (if (null arg) (defstruct-error
		     "defstruct cannot make an empty tree"
		     (defstruct-description-name)))
    (make-tree-for-defstruct arg (defstruct-description-size)))
  (:ref (n description arg)
    (do ((size (defstruct-description-size))
	 (a arg)
	 (tem))
	(nil)
      (cond ((= size 1) (return a))
	    ((< n (setq tem (defstruct-divide size 2)))
	     (setq a `(car ,a))
	     (setq size tem))
	    (t (setq a `(cdr ,a))
	       (setq size (- size tem))
	       (setq n (- n tem))))))
  (:defstruct (description)
    (and (defstruct-description-include)
	 (defstruct-error
	   "Structure of type :TREE cannot include another"
	   (defstruct-description-name)))
    nil)
  (:copier (description name)
    `(defun ,name (x)
       ,(copy-tree-for-defstruct nil (defstruct-description-size)))))

(defun make-tree-for-defstruct (arg size)
  (cond ((= size 1) (car arg))
	((= size 2) `(cons ,(car arg) ,(cadr arg)))
	(t (do ((a (cdr arg) (cdr a))
		(m (defstruct-divide size 2))
		(n (1- (defstruct-divide size 2)) (1- n)))
	       ((zerop n)
		`(cons ,(make-tree-for-defstruct arg m)
		       ,(make-tree-for-defstruct a (- size m))))))))

(defun copy-tree-for-defstruct (popx? size)
  (cond ((= size 1)
	 (if popx?
	     `(prog1 (car x) (setq x (cdr x)))
	     `x))
	((= size 2)
	 (if popx?
	     `((lambda (x) (cons (car x) (cdr x)))
	       (prog1 (car x) (setq x (cdr x))))
	     `(cons (car x) (cdr x))))
	(popx?
	 `((lambda (x)
	     (cons ,(copy-tree-for-defstruct t (defstruct-divide size 2))
		   ,(copy-tree-for-defstruct nil (- size (defstruct-divide size 2)))))
	   (prog1 (car x) (setq x (cdr x)))))
	(t
	 `(cons ,(copy-tree-for-defstruct t (defstruct-divide size 2))
		,(copy-tree-for-defstruct nil (- size (defstruct-divide size 2)))))))

(defstruct-define-type :fixnum
  (:cons (arg description etc) :list
    etc			;ignored
    (and (or (null arg)
	     (not (null (cdr arg))))
	 (defstruct-error
	   "Structure of type :FIXNUM must have exactly 1 slot to be constructable"
	   (defstruct-description-name)))
    (car arg))
  (:ref (n description arg)
    n			;ignored
    description		;ignored
    arg))

;1#+Multics
;(defprop :external-ptr t :defstruct-option)

#+Multics
(defstruct-define-type :external
  (:CONS-KEYWORDS :external-ptr)
  (:DEFSTRUCT-KEYWORDS :EXTERNAL-PTR)
  (:cons (arg description etc) :alist
    (let ((ptr (cdr (or (assq ':external-ptr etc)*
			1(assq ':external-ptr*
			1      (defstruct-description-property-alist))*
			1(defstruct-error*
			1  "No pointer given for external array"*
			1  (defstruct-description-name))))))
      (do ((creator `(array nil external ,ptr ,(defstruct-description-size)))*
	1   (var (gensym))*
	1   (alist arg (cdr alist))*
	1   (inits nil (cons `(store (arraycall fixnum ,var ,(caar alist))*
				1    ,(cdar alist))*
			1    inits)))*
	1  ((null alist)*
	1   (if (null inits)*
	1       creator*
	1       `((lambda (,var) ,.inits ,var)*
		1 ,creator))))))
  (:ref (n description arg)
    description*	1;ignored
    `(arraycall fixnum ,arg ,n)))*

(defvar *defstruct-examine&deposit-arg*)

(defun defstruct-examine (*defstruct-examine&deposit-arg*
			  name slot-name)
  (eval (list (defstruct-slot-description-ref-macro-name
		(defstruct-examine&deposit-find-slot-description
		  name slot-name))
	      '*defstruct-examine&deposit-arg*)))

(defvar *defstruct-examine&deposit-val*)

(defun defstruct-deposit (*defstruct-examine&deposit-val*
			  *defstruct-examine&deposit-arg*
			  name slot-name)
  (eval (list 'setf
	      (list (defstruct-slot-description-ref-macro-name
		     (defstruct-examine&deposit-find-slot-description
		       name slot-name))
		    '*defstruct-examine&deposit-arg*)
	      '*defstruct-examine&deposit-val*)))

#+LispM
(defun defstruct-get-locative (*defstruct-examine&deposit-arg*
			       name slot-name)
  (let ((slot-description (defstruct-examine&deposit-find-slot-description
			    name slot-name)))
    (or (null (defstruct-slot-description-ppss))
	(defstruct-error
	  "You cannot get a locative to a byte field"
	  slot-name 'in name))
    (eval (list 'locf
		(list (defstruct-slot-description-ref-macro-name)
		      '*defstruct-examine&deposit-arg*)))))

(defun defstruct-examine&deposit-find-slot-description (name slot-name)
  (let ((description (get-defstruct-description name)))
    (let ((slot-description
	    (cdr (or (assq slot-name (defstruct-description-slot-alist))
		     (defstruct-error
		       "No such slot in this structure"
		       slot-name 'in name))))
	  (type-description
	    (or (get (defstruct-description-type) 'defstruct-type-description)
		(defstruct-error
		  "Undefined defstruct type"
		  (defstruct-description-type)))))
      (or (= (defstruct-type-description-ref-no-args) 1)
	  (defstruct-error
	    "defstruct-examine and defstruct-deposit cannot handle structures of this type"
	    (defstruct-description-type)))
      slot-description)))

1#+MacLisp-10
(defprop defstruct*
	1 #.(and (status feature MacLisp-10)*
		1(caddr (truename infile)))*
	1 version)*

(sstatus feature defstruct)
