.c This file is part of the Lisp Machine Manual.  -*-Bolio-*-
.c Debugger

.section The Debugger
.cindex debugger
.setq debugger section-page

	When an error condition is signaled and no handlers decide to
handle the error, an interactive debugger is entered to allow the user to
look around and see what went wrong, and to help him continue the program
or abort it.  This section describes how to use the debugger.

.subsection Entering the Debugger

	There are two kinds of errors; those generated by the Lisp Machine's
microcode, and those generated by Lisp programs (by using 3ferror* or
related functions).  When there
is a microcode error, the debugger prints out a message such as the following:

.lisp
>>TRAP 5543 (TRANS-TRAP)
The symbol FOOBAR is unbound.
While in the function LOSE-XCT  LOSE-COMMAND-LOOP  LOSE
.end_lisp

	The first line of this error message indicates entry to
the debugger and contains some mysterious internal microcode information:
the micro program address, the microcode trap name and parameters, and a microcode backtrace.
Users can ignore this line in most cases.  The second line contains a description
of the error in English.  The third line indicates where the error
happened by printing a very abbreviated ``backtrace'' of the stack (see
below); in the example, it is saying that the error was signaled inside the
function 3lose-xct*, which was called by 3lose-command-loop*.

	Here is an example of an error from Lisp code:
.lisp
>>ERROR: The argument X was 1, which is not a symbol,
While in the function FOO  SI:EVAL1  SI:LISP-TOP-LEVEL1
.end_lisp

	Here the first line contains the English description of the
error message, and the second line contains the abbreviated backtrace.
3foo* signaled the error by calling 3ferror*; however, 3ferror*
is censored out of the backtrace.

	After the debugger's initial message, it prints the function that
got the error and its arguments.  Then it prints a list of commands you
can use to proceed from the error, or to abort to various command loops.  The
possibilities depend on the kind of error and where it happened, so the
list is different each time; that is why the debugger prints it.  The
commands in the list all start with 3Super-A*, 3Super-B* and continue as far
as is necessary.

.defvar eh:*inhibit-debugger-proceed-prompt*
If this is non-3nil*, the list of 3Super* commands is not printed
when the debugger is entered.  Type 3Help P* to see the list.
.end_defvar

The debugger normally uses the stream 3*debug-io** for all its input and output
(see (debug-io-var)).  By default it is a synonym for 3*terminal-io**.
The value of this variable in the stack group in which the error was
signaled is the one that counts.

.defvar eh:*debug-io-override*
If this is non-3nil*, it is used by the debugger instead of the value
of 3*debug-io**.  The value in the stack group where the error was signaled
is the one that counts.
.end_defvar

	The debugger can be manually entered either by causing an error
(e.g. by typing a ridiculous symbol name such as 3ahsdgf* at the Lisp
read-eval-print loop) or by typing the 3Break* key with the 3Meta* shift
held down while the program is reading from the terminal.  Typing the 3Break*
key with both 3Control* and 3Meta* held down forces the program
into the debugger immediately, even if it is running.  If the 3Break*
key is typed without 3Meta*, it puts you into a read-eval-print loop
using the 3break* function (see (break-fun)) rather than into the debugger.

.defun eh &optional process
Causes 2process* to enter the debugger, and directs the debugger to
read its commands from the ambient value of 3*terminal-io**, current
when you call 3eh*, rather than 2process*'s own value of
3*terminal-io** which is what would be used if 2process* got an error
in the usual way.  The process in which you invoked 3eh* waits while
you are in the debugger, so there is no ambiguity about which process will
handle your keyboard input.

If 2process* had already signaled an error and was waiting for
exposure of a window, then it enters the debugger to handle that error.
Otherwise, the 3break* condition is signaled in it (just like what
3Control-Meta-Break* does) to force it into the debugger.

The 3Resume* command makes 2process* resume execution.  You can also
use other debugger commands such as 3Abort*, 3Control-R*, 3Control-Meta-R*
and 3Control-T* to start it up again.  Exiting the debugger in any way
causes 3eh* to return in its process.

2process* can also be a window, or any flavor instance which understands
the 3:process* operation and returns a process.

If 2process* is not a process but a stack group, the current state of
the stack group is examined.  In this case, the debugger runs in
``examine-only'' mode, and executes in the process in which you invoked
3eh*.  You cannot resume execution of the debugged stack group, but
3Resume* exits the debugger.  It is your responsibility to ensure that
no one tries to execute in the stack group being debugged while the
debugger is looking at it.

If 2process* is 3nil*, 3eh* finds all the processes waiting to enter
the debugger and asks you which one to use.
.end_defun

.subsection How to Use the Debugger

	Once inside the debugger, the user may give a wide variety
of commands.  This section describes how to give the commands, then
explains them in approximate order of usefulness.  A summary is provided
at the end of the listing.

	When the debugger is waiting for a command, it prompts
with an arrow:

.lisp
7 *
.end_lisp

If the error took place in the evaluation of an expression that you
typed at the debugger, you are in a second level (or deeper) error.
The number of arrows in the prompt indicates the depth.

The debugger also warns you about certain unusual circumstances that may
cause paradoxical results.  For example, if 3default-cons-area* is
anything except 3working-storage-area*, a message to that effect is
printed.  If 3*read-base** and 3*print-base** are not the same, a
message is printed.

At this point, you may type either a Lisp expression or a
command; a 3Control* or 3Meta* character is interpreted as a command,
whereas most normal characters are interpreted as the first character of
an expression.  If you type the 3Help* key or the 3?* key, you can
get some introductory help with the debugger.

If you type a Lisp expression, it is interpreted as a Lisp form
and evaluated in the context of the current frame.
That is, all dynamic bindings used for the evaluation are those
in effect in the current frame, with certain
exceptions explained below.  The results of the evaluation are
printed, and the debugger prompts again with an arrow.  If, during
the typing of the form, you change your mind and want to get back to the
debugger's command level, type the 3Abort* key or a 3Control-G*; the debugger responds
with an arrow prompt.  In fact, at any time that input is expected from
you, while you are in the debugger, you may type 3Abort* or 3Control-G* to cancel
any debugger command that is in progress and get back to command level.
3Control-G* is useful because it can never exit from the debugger
as 3Abort* can.

This 3read-eval-print* loop maintains the values of 3+*, 3**, and
3-* almost like the Lisp listen loop.  The difference is that some
single-character debugger commands such as 3C-M-A* also set 3** and
3+* in their own way.

If an error occurs in the evaluation of the Lisp expression you type,
you may enter a second invocation of the debugger, looking at the new
error.  The prompt in this event is `7*' to make it clear which
level of error you are examining.  You can abort the computation and get
back to the first debugger level by typing the 3Abort* key (see
below).

Various debugger commands ask for Lisp objects, such as an object to
return or the name of a catch-tag.  You must type a form to be
evaluated; its value is the object that is actually used.  This provides
greater generality, since there are objects to which you might want to
refer that cannot be typed in (such as arrays).  If the form you type is
non-trivial (not just a constant form), the debugger shows you the
result of the evaluation and asks for confirmation before proceeding.
If you answer negatively, or if you abort, the command is canceled and the debugger
returns to command level.  Once again, the special bindings in effect for
evaluation of the form are those of the current frame you have selected.

The 3Meta-S* and 3Control-Meta-S* commands allow you to look at the
bindings in effect at the current frame.  A few variables are rebound by
the debugger itself whenever a user-provided form is evaluated, so you
you must use 3Meta-S* to find the values they actually had in the
erring computation.

.table 3
.item *terminal-io*
3*terminal-io** is rebound to the stream the debugger is using.

.item *standard-input*
.item1 *standard-output*
3*standard-input** and 3*standard-output** are rebound to be synonymous with
3*terminal-io**.

.item 13+*, 3++*, 3+++**
.item1 13**, 3***, 3*****, 3*values**
3+* and 3** are rebound to the debugger's previous form and previous
value.  Commands for examining arguments and such, including 3C-M-A*,
3C-M-L* and 3C-M-V*, leave 3** set to the value examined and 3+*
set to a locative to where the value was found.  When the debugger is
first entered, 3+* is the last form typed, which is typically the one
that caused the error, and 3** is the value of the 2previous* form.

.item evalhook
.item1 applyhook
These variables (see (evalhook-var)) are rebound to 3nil*, turning off
the 3step* facility if it was in use when the error occurred.

.item eh:condition-handlers
.item1 eh:condition-default-handlers
These are rebound to 3nil*,
so that errors occurring within forms you type while in the debugger do not
magically resume execution of the erring program.

.item eh:condition-resume-handlers
To prevent resume handlers established outside the error from being invoked
automatically by deeper levels of error, this variable is rebound to a new value,
which has an element 3t* added in the front.
.end_table

.subsection "Debugger Commands"

All debugger commands are single characters, usually with the 3Control* or
3Meta* bits.  The single most useful command is 3Abort* (or 3Control-Z*),
which exits from the debugger and throws out of the computation that got
the error.  (This is the 3Abort* key, not a 5-letter command.)  Often you are not
interested in using the debugger at all and just want to get back to
Lisp top level; so you can do this in one keystroke.

If the error happened while you were innocently using a system utility
such as the editor, then it represents a bug in the system.  Report the
bug using the debugger command 3Control-M*.  This gives you an editor
preinitialized with the error message and a backtrace.  You should type
in a 2precise* description of what you did that led up to the problem,
then send the message by typing 3End*.  Be as complete as possible,
and always give the exact commands you typed, exact filenames, etc.
rather then general descriptions, as much as possible.  The person who
investigates the bug report will have to try to make the problem happen
again; if he does not know where to find 2your* file, he will have a
difficult time.

The 3Abort* command signals the 3sys:abort* condition, returning
control to the most recent command loop.
This can be Lisp top level, a 3break*, or the debugger command loop
associated with another error.  Typing 3Abort* multiple times throws
back to successively older read-eval-print or command loops until top level
is reached.  Typing 3Meta-Abort*, on the other hand, always throws
to top level.  3Meta-Abort* is not a debugger command, but a system
command that is always available no matter what program you are in.

Note that typing 3Abort* in the middle of typing a form to be evaluated
by the debugger aborts that form and returns to the debugger's command level,
while typing 3Abort* as a debugger command returns out of the debugger
and the erring program, to the 2previous* command level.
Typing 3Abort* after entering a numeric argument just discards the argument.

Self-documentation is provided by the 3Help* or 3?* command,
which types out some documentation on the debugger commands, including any
special commands that apply to the particular error currently being handled.

Often you want to try to proceed from the error.  When the debugger is
entered, it prints a table of commands you can use to proceed, or abort
to various levels.  The commands are 3Super-A*, 3Super-B*, and so on.  How
many there are and what they do is different each time there is an
error, but the table says what each one is for.  If you want to see the
table again, type 3Help* followed by 3P*.

The 3Resume* (or 3Control-C*) command is often synonymous with
3Super-A*.  But 3Resume* only proceeds, never aborts.  If there is no
way to proceed, just ways to abort, then 3Resume* does not do anything.

The debugger knows about a current stack frame, and there
are several commands that use it.  The initially current stack frame
is the one which signaled the error, either the one which got the microcode-detected
error or the one which called 3ferror*, 3cerror*, or 3error*.
When the debugger starts it up it shows you this frame in the following format:
.lisp
FOO:
   Arg 0 (X): 13
   Arg 1 (Y): 1
.end_lisp
and so on.  This means that 3foo* was called
with two arguments, whose names (in the Lisp source code) are 3x* and 3y*.
The current values of 3x* and 3y* are 313* and 31* respectively.  These
may not be the original arguments if 3foo* happens to 3setq* its argument variables.

The 3Clear-Screen* (or 3Control-L*) command clears the screen, retypes
the error message that was initially printed when the debugger was
entered, and prints out a description of the current frame, in the
above format.

Several commands are provided to allow you to examine the Lisp control
stack and to make frames current other than the one that got the error.
The control stack (or ``regular pdl'') keeps a record of all functions currently
active.  If you call 3foo* at Lisp's top level, and it calls 3bar*,
which in turn calls 3baz*, and 3baz* gets an error, then a
backtrace (a backwards trace of the stack) would show all of this
information.  The debugger has two backtrace commands.  3Control-B*
simply prints out the names of the functions on the stack; in the above
example it would print
.lisp
BAZ  BAR  FOO  SI:*EVAL
  SI:LISP-TOP-LEVEL1  SI:LISP-TOP-LEVEL
.end_lisp
The arrows indicate the direction of calling.  The 3Meta-B* command prints
a more extensive backtrace, indicating the names of the arguments to the functions
and their current values; for the example above it might look like:
.lisp
BAZ:
   Arg 0 (X): 13
   Arg 1 (Y): 1

BAR:
   Arg 0 (ADDEND): 13

FOO:
   Arg 0 (FROB): (A B C . D)
.end_lisp
and so on.  The backtrace commands all accept numeric arguments
which say how many frames to describe, the default being to describe
all the frames.

.need 1500
.nopara
Moving around in the stack:

The 3Control-N* command makes the ``next'' older frame be current.
This is the frame which
called the one that was current at before.  The new current frame's
function and arguments are printed in the format shown immediately above.

3Control-P* moves the current frame in the reverse direction.
If you use it immediately after getting an error it selects frames
that are part of the act of signaling.

3Meta-<* selects the frame in which the error occurred, the same frame
that was selected when the debugger was entered.  3Meta->* selects the
outermost or initial stack frame.  3Control-S* asks you for a string
and searches down the stack (toward older frames) from the current frame
for a frame whose executing function's name contains that string.  That
frame becomes current and is printed out.  These commands are easy to
remember since they are analogous to editor commands.

The 3Control-Meta-N*, 3Control-Meta-P*, and 3Control-Meta-B*
commands are like the corresponding 3Control* commands but don't
censor the stack to omit ``uninteresting'' functions.  When looking at
interpreted code, the debugger usually tries to skip over frames that
belong to the functions composing the interpreter, such as 3eval*,
3prog*, and 3cond*.  3Control-Meta-N*, 3Control-Meta-P*, and
3Control-Meta-B* show everything.  They also show frames that are not
yet active; that is, frames whose arguments are still being computed for
functions that are going to be called.  The 3Control-Meta-U* command
goes down the stack (to older frames) to the next interesting function
and makes that the current frame.

3Meta-L* prints out the current frame in ``full screen'' format, which shows
the arguments and their values, the local variables and their values,
and the machine code with an arrow pointing to the next instruction to
be executed.  Refer to (understanding-compiled-code) for help in reading
this machine code.

Commands such as 3Control-N* and 3Control-P*, which are useful to
issue repeatedly, take a prefix numeric argument and repeat that many types.
The numeric argument is typed by using 3Control* or 3Meta* and the number
keys, as in the editor.  Some other commands such as 3Control-M* also
use the numeric argument; refer to the table at the end of the section
for detailed information.

.need 1500
.nopara
Resuming execution:

3Meta-C* is similar to 3Control-C*, but in the case of an unbound
variable or undefined function, actually 3setq*s the variable or
defines the function, so that the error will not happen again.
3Control-C* (or 3Resume*) provides a replacement value but does not
actually change the variable.  3Meta-C* proceeds using the proceed type
3:store-new-value*, and is available only if that proceed type is
provided.

3Control-R* is used to return a value or values from the current frame; the frame
that called that frame continues running as if the function of the current frame
had returned.  This command prompts you for each value that the caller
expects; you can type either a form which evaluates to the desired value
or 3End* if you wish to return no more values.

The 3Control-T* command does a 3throw* to a given tag with a given value; you
are prompted for the tag and the value.

3Control-Meta-R* 2reinvokes* the current frame; it starts execution
at the beginning of the function, with the arguments currently present
in the stack frame.  These are the same arguments the function was
originally called with unless either the function itself has changed them
with 3setq* or you have set them in the debugger.  If the
function has been redefined in the meantime (perhaps you edited it and
fixed its bug) the new definition is used.  3Control-Meta-R* asks for
confirmation before resuming execution.

3Meta-R* is similar to 3Control-Meta-R* but allows you to change the
arguments if you wish.  You are prompted for the new arguments one by one;
you can type a form which evaluates to the desired argument, or 3Space*
to leave that argument unchanged, or 3End* if you do not want any more
arguments.  3Space* is allowed only if this argument was previously passed,
and 3End* is not allowed for a required argument.  Once you have finished
specifying the arguments, you must confirm before execution resumes.

.need 1500
.nopara
Stepping through function calls and returns:

You can request a trap to the debugger on exit from a particular frame,
or the next time a function is called.

Each stack frame has a ``trap on exit'' bit.  The 3Control-X* command
toggles this bit.  The 3Meta-X* command sets the bit to cause a trap
for the current frame and all outer frames.  If a program is in an
infinite loop, this is a good way to find out how far back on the stack
the loop is taking place.  This also enables you to see what values
are being returned.  The 3Control-Meta-X* command clears the
trap-on-exit bit for the current frame and outer frames.

The 3Control-D* command proceeds like 3Control-C* but requests a
trap the next time a function is called.  The 3Meta-D* command toggles
the trap-on-next-call bit for the erring stack group.  It is useful if
you wish to set the bit and then resume execution with something other
than 3Control-C*.  The function 3breakon* may be used to request a trap
on calling a particular function.  Trapping on entry to a frame
automatically sets the trap-on-exit bit for that frame; use
3Control-X* to clear it if you do not want another trap.

.need 1500
.nopara
Transfering to other systems:

3Control-E* puts you into the editor, looking at the source code for the
function in the current frame.  This is useful when you have found the function
that caused the error and that needs to be fixed.  The editor command 3Control-Z*
will return to the debugger, if it is still there.

3Control-M* puts you into the editor to mail a bug report.  The error message
and a backtrace are put into the editor buffer for you.  A numeric argument
says how many frames to include in the backtrace.

3Control-Meta-W* calls the window debugger, a display-oriented
debugger.  It is not documented in this manual, but should be usable
without further documentation.

.need 1500
.nopara
Examining and setting the arguments, local variables, and values:

3Control-Meta-A* takes a numeric argument, 2n*, and prints out the
value of the 2n*th argument of the current frame.  It leaves 3** set
to the value of the argument, so that you can use the Lisp
3read-eval-print* loop to examine it.  It also leaves 3+* set to a
locative pointing to the argument on the stack, so that you can change
that argument (by calling 3rplacd* on the locative).
3Control-Meta-L* is similar, but refers to the 2n*th local variable
of the frame.  3Control-Meta-V* refers to the 2n*th value this frame
has returned (in a trap-on-exit).  3Control-Meta-F* refers to the
function executing in the frame; it ignores its numeric argument and
doesn't allow you to change the function.

Another way to examine and set the arguments, locals and values of a
frame is with the functions 3eh-arg*, 3eh-loc*, 3eh-val* and
3eh-fun*.  Use these functions in expressions you evaluate inside
the debugger, and they refer to the arguments, locals, values and
function, respectively, of the debugger's current frame.

The names 3eh:arg*, 3eh:val*, etc. are for compatibility with
the Symbolics system.

.defun eh-arg arg-number-or-name
.defun1 eh:arg arg-number-or-name
When used in an expression evaluated in the debugger, 3eh-arg*
returns the value of the specifed argument in the debugger's
current frame.  Argument names are compared ignoring packages; only
the pname of the symbol you supply is relevant.  3eh-arg* can appear
in 3setf* and 3locf* to set an argument or get its location.
.end_defun

.defun eh-loc local-number-or-name
.defun1 eh:loc local-number-or-name
Like 3eh-arg* but accesses the current frame's
local variables instead of its arguments.
.end_defun

.defun eh-val &optional value-number-or-name
.defun1 eh:val &optional value-number-or-name
3eh-val* is used in an expression evaluated in the debugger
when the current frame is returning multiple values, to examine those
values.  This is only useful if the function has already begun to
return some values (as in a trap-on-exit), since otherwise they are
all 3nil*.  If a name is specified, it is looked for in the function's
3values* or 3return-list* declaration, if any.

3eh-val* can be used with 3setf* and 3locf*.  You can make a
frame return a specific sequence of values by setting all but the last
value with 3eh-val* and doing 3Control-R* to return the last value.

3eh-val* with no argument returns a list of all the
values this frame is returning.
.end_defun

.defun eh-fun
.defun1 eh:fun
3eh-fun* can be called in an expression being evalued inside the
debugger to return the function-object being called in the
current frame.  It can be used with 3setf* and 3locf*.
.end_defun

.subsection "Summary of Commands"

.table 3 0 1500
.item Control-A
Prints argument list of function in current frame.
.item Control-Meta-A
Sets 3** to the 2n*th argument of the current frame.
.item Control-B
Prints brief backtrace.
.item Meta-B
Prints longer backtrace.
.item Control-Meta-B
Prints longer backtrace with no censoring of ``uninteresting'' functions.
.item Control-C 1or* Resume
Attempts to continue, using the first proceed type on the list
of available ones for this error.
.item Meta-C
Attempts to continue, 3setq*'ing the unbound variable or otherwise
``permanently'' fixing the error.  This uses the proceed type
3:store-new-value*, and is available only if that proceed type is.
.item Control-D
Attempts to continue like 3Control-C*, but trap on the next function call.
.item Meta-D
Toggles the flag that causes a trap on the next function call after
you continue or otherwise exit the debugger.
.item Control-E
Switches to Zmacs to edit the source code for the function in the current frame.
.item Control-Meta-F
Sets 3** to the function in the current frame.
.item Control-G 1or* Abort
Quits to command level.  This is not a command, but something you can type to escape from
typing in an argument of a command.
.item Control-Meta-H
Describes the condition handlers and resume handlers established by the
current frame.
.item Control-L 1or* Clear-Screen
Redisplays error message and current frame.
.item Meta-L
Displays the current frame, including local variables and compiled code.
.item Control-Meta-L
Sets 3** to the value of local variable 2n* of the current frame.
.item Control-M
Sends a bug report containing the error message
and a backtrace of 2n* frames (default is 3).
.item Control-N 1or* Line
Moves to the next (older) frame.  With argument, moves down 2n* frames.
.item Meta-N
Moves to next frame and displays it like 3Meta-L*.  With argument, move down 2n* frames.
.item Control-Meta-N
Moves to next frame even if it is ``uninteresting'' or still accumulating
arguments.  With argument, moves down 2n* frames.
.item Control-P 1or* Return
Moves up to previous (newer) frame.  With argument, moves up 2n* frames.
.item Meta-P
Moves to previous frame and displays it like 3Meta-L*.  With argument, moves up 2n* frames.
.item Control-Meta-P
Moves to previous frame even if it is ``uninteresting'' or still
accumulating arguments.  With argument, moves up 2n* frames.
.item Control-R
Returns a value or values from the current frame.
.item Meta-R
Reinvokes the function in the current frame (restart its execution at the beginning),
optionally changing the arguments.
.item Control-Meta-R
Reinvokes the function in the current frame with the same arguments.
.item Control-S
Searches for a frame containing a specified function.
.item Meta-S
Reads the name of a special variable and returns that variable's value
in the current frame.  Instance variables of 3self* may also be
specified even if not special.
.item Control-Meta-S
Prints a list of special variables bound by the current frame and the
values they are bound to by the frame.  If the frame binds 3self*, all
the instance variables of 3self* are listed even if they are not special.
.item Control-T
Throws a value to a tag.
.item Control-Meta-U
Moves down the stack to the previous ``interesting'' frame.
.item Control-X
Toggles the flag in the current frame that causes a trap on exit or throw through
that frame.
.item Meta-X
Sets the flag causing a trap on exit or throw through the frame
for the current frame and all the frames outside of it.
.item Control-Meta-X
Clears the flag causing a trap on exit or throw through the frame
for the current frame and all the frames outside of it.
.item Control-Meta-V
Sets 3** to the 2n*th value being returned from the current frame.
This is non-3nil* only in a trap on exit from the frame.
.item Control-Meta-W
Switches to the window-oriented debugger.
.item Control-Z 1or* Abort
Aborts the computation and throw back to the most recent
3break* or debugger, to the program's command level,
or to Lisp top level.
.item ? 1or* Help
Prints debugger command self-documentation.
.item Meta-<
Moves to the frame in which the error was signaled, and
makes it current once again.
.item Meta->
Moves to the outermost (oldest) stack frame.
.item Control-0 1through* Control-Meta-9
Numeric arguments to the following command are specified by typing a decimal number
with 3Control* and/or 3Meta* held down.
.item Super-A1, etc.*
The commands 3Super-A*, 3Super-B*, etc. are assigned to all the available
proceed types for this error.  The assignments are different each time
the debugger is entered, so it prints a list of them when it starts up.
3Help P* prints the list again.
.end_table

.subsection Deexposed Windows and Background Processes

If the debugger is entered in a window that is not exposed, a
notification is used to inform you that it has happened.

In general, a
notification appears as a brief message printed inside square
brackets if the selected window can print it.  Otherwise,
blinking text appears in the mouse documentation line telling
you that a notification is waiting; to see the notification,
type 3Terminal N* or select a window that can print it.
In either case, an audible beep is made.

In the case of a notification that the debugger is waiting to
use a deexposed window, you can select and expose the window
in which the error happened by typing 3Terminal 0 S*.
You can do this even if the notification has not been printed yet
because the selected window cannot print it.  If you select
the waiting window, in this way or in any other way, the notification
is discarded since you already know what it was intended to tell you.

If the debugger is entered in a process that has no window or other suitable stream to
type out on, the window system assigns it a ``background window''.  Since this
window is initially not exposed, a notification is printed as above and you
must use 3Terminal 0 S* to see the window.

If an error happens in the scheduler stack group or the first level
error handler stack group which are needed for processes to function, or
in the keyboard or mouse process (both needed for the window system to
function), the debugger uses the 2cold load stream*, a primitive
facility for terminal I/O which bypasses the window system.

If an error happens in another process but the window system is locked
so that the notification mechanism cannot function, the cold load stream
is used to ask what to do.  You can tell the debugger to use the cold
load stream immediately, to forcibly clear the window system locks and
notify immediately as above, or to wait for the locks to become unlocked
and then notify as above.  If you tell it to wait, you can resume
operation of the machine.  Meanwhile, you can use the command 3Terminal
Control-Clear-Input* to forcibly unlock the locks, or 3Terminal Call*
to tell the debugger to use the cold load stream.  The latter command
normally enters a break-loop that uses the cold-load stream, but if
there are any background errors, it offers to enter the debugger to
handle them.  You can also handle the errors in a Lisp listen loop
of your choice by means of the function 3eh* ((eh-fun)), assuming
you can select a functioning Lisp listen loop.

.subsection Debugging after a Warm Boot

After a warm boot, the process that was running at the time of
booting (or at the time the machine crashed prior to booting)
may be debugged if you answer `no' when the system asks whether
to reset that process.

.defun si:debug-warm-booted-process
Invoke the debugger, like the function 3eh* ((eh-fun)),
on the process that was running as of the last warm boot
(assuming there was such a process).
.end_defun

On the CADR, the state you see in the debugger is not correct;
some of the information dates from some period of time in advance
of the boot or the crash.

On the Lambda, the state you see in the debugger will, in some
system version, be accurate.
