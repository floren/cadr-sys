.c This file is part of the Lisp Machine manual.	-*-Bolio-*-
.c The I/O System Chapter.
.c Need to add examples in the section on read, maybe print too.

.chapter "The I/O System"
.cindex input and output
.setq io-chapter chapter-number
.setq io section-page

	Zetalisp provides a powerful and flexible system for performing
input and output to peripheral devices.  To allow device independent I/O
(that is, to allow programs to be written in a general way so that the
program's input and output may be connected with any device), the
Zetalisp I/O system provides the concept of an "I/O stream".  Streams,
their usage, and their implementation are described in this chapter.
The following chapter describes the peculiar Lisp expression I/O
operations 3read* and 3print* and the printed representation they
use for Lisp objects.

.section Input Functions

The input functions read characters, lines, or bytes from an input
stream.  This argument is called 2stream*.  If unsupplied it
defaults to the value of 3*standard-input**, which in simple use reads
from the terminal keyboard.  If the stream is an interactive one, such
as the terminal, the input is echoed, and functions which read more
than a single character allow editing as well.  3peek-char* echoes
all of the characters that were skipped over if 3read-char* would
have echoed them; the character not removed from the stream is not
echoed either.

The functions accept an argument 2eof-option* or two arguments
2eof-error* and 2eof-value* to tell them what to do if end of file
is encountered instead of any input.  The functions that take two
2eof-* arguments are the Common Lisp ones.  For them, end of
file is an error if 2eof-error* is non-3nil* or if it is
unsupplied.  If 2eof-error* is 3nil*, then the function returns
2eof-value* at end of file.  The functions which have one
argument called 2eof=option* are old Maclisp functions and their
conventions are described in their own subsection below.

In functions that accept the 2eof-option* argument, end of file
signals an error if the argument is not supplied.  Otherwise, end of
file causes the function to return the argument's value.  Note that an
2eof-option* of 3nil* means to return 3nil* if the end of the
file is reached; it is 2not* equivalent to supplying no
2eof-option*.

.defcondition sys:end-of-file (3error*)
All errors signaled to report end of file possess this condition name.

The 3:stream* operation on the condition instance returns the stream
on which end of file was reached.
.end_defcondition

.subsection String Input Functions

.defun readline &optional stream eof-option options
.defun1 read-line &optional stream (eof-errorp 3t*) eof-value options
3readline* reads in a line of text, terminated by a return.  It
returns the line as a character string, 2without* the return
character.  This function is usually used to get a line of input from
the user.  If rubout processing is happening, then 2options* is passed
as the list of options to the rubout handler.  One option that is
particularly useful is the 3:do-not-echo* option (see
(:do-not-echo-option)), which you can use to suppress the echoing of the 3Return*
character that terminates the line.  (This function can
take its arguments in the other order, for Maclisp compatibility only;
see the note above.)

There is a second value, 3t* if end of file was reached.
.end_defun

.defun readline-trim &optional stream eof-option options
This is like 3readline* except that leading and trailing spaces and
tabs are discarded from the value before it is returned.
.end_defun

.defun readline-or-nil &optional stream eof-option options
Like 3readline-trim* except that 3nil* is returned if the line is empty
or all blank.
.end_defun

.defun read-delimited-string &optional delimiter stream eof rubout-handler-options buffer-size
Reads input from 2stream* until a delimiter character is reached, then
returns as a string all the input up to but not including the delimiter.
2delimiter* is either a character or a list of characters which all
serve as delimiters.  It defaults to the character 3End*.  2stream*
defaults to the value of 3*standard-input**.

If 2eof* is non-3nil*, then end of file on attempting to read the
first character is an error.  Otherwise it just causes an empty string
to be returned.  End of file once at least one character has been read
is never an error but it does cause the function to return all the input
so far.

Input is done using rubout handling and echoing if stream supports the
3:rubout-handler* operation.  In this case, 2rubout-handler-options*
are passed as the options argument to that operation.

2buffer-size* specifies the size of string buffer to allocate initially.

The second value returned is 3t* if input ended due to end of file.

The third value is the delimiter character which terminated input,
or 3nil* if input terminated due to end of file.
A character is represented as a fixnum, but perhaps someday
will be a character object instead.
.end_defun

.subsection Character-Level Input Functions

.defun read-char &optional stream (eof-errorp 3t*) eof-value
Reads a character from 2stream* and returns it as a character object.
End of file is an error if 2eof-errorp* is non-3nil*; otherwise, it
causes 3read-char* to return 2eof-value*.  This uses the 3:tyi*
stream operation.
.end_defun

.defun read-byte stream &optional (eof-errorp 3t*) eof-value
Like 3read-char* but returns an integer rather than a character
object.  In strict Common Lisp, only 3read-char* can be used
on character streams and only 3read-byte* can be used on binary streams.
.end_defun

.defun read-char-no-hang &optional stream (eof-errorp 3t*) eof-value
Similar but returns 3nil* immediately when no input is available on an interactive stream.
Uses the 3:tyi-no-hang* stream operation.
.end_defun

.defun unread-char char &optional stream
Untyi's 2char* on 2stream*.  2char* may be an integer or a character object.
Uses the 3:untyi* stream operation.
.end_defun

.defun peek-char peek-type &optional stream (eof-errorp 3t*) eof-value
If 2peek-type* is 3nil*, this is like 3read-char* except leaves the character
to be read again by the next input operation.

If 2peek-type* is 3t*, skips whitespace characters and peeks at the
first nonwhitespace character.  That character is the value, and is also
left to be reread.

If 2peek-type* is a character, reads input until that character is seen.
That character is unread and also returned.
.end_defun

.defun listen &optional stream
3t* if input is now available on 2stream*.  Uses the 3:listen* operation.
.end_defun

.defun clear-input &optional stream
Discards any input now available on 2stream*, if it is an interactive stream.
Uses the 3:clear-input* stream operation.
.end_defun

.subsection Maclisp Compatibility Input Functions

These functions accept an argument 2eof-option* to tell them what to
do if end of file is encountered instead of any input.  End of file
signals an error if the argument is not supplied.  Otherwise, end of
file causes the function to return the argument's value.  Note that an
2eof-option* of 3nil* means to return 3nil* if the end of the
file is reached; it is 2not* equivalent to supplying no
2eof-option*.

For Maclisp compatibility, 3nil* as the 2stream* argument also
means to use the value of 3*standard-input**, and 3t* as the
2stream* argument means to use the value of 3*terminal-io**.
Instead of the variable 3*standard-input** Maclisp has several
variables and complicated rules.

The arguments 2stream* and 2eof-option* can also be given in the
reverse order for compatibility with old Maclisp programs.  The
functions attempt to figure out which way they were called by seeing
whether each argument is a plausible stream.  Unfortunately, there is
an ambiguity with symbols: a symbol might be a stream and it might be
an eof-option.  If there are two arguments, one being a symbol and the
other being something that is a valid stream, or only one argument,
which is a symbol, then these functions interpret the symbol as an
eof-option instead of as a stream.  To force them to interpret a
symbol as a stream, give the symbol an 3si:io-stream-p* property
whose value is 3t*.

.defun tyi &optional stream eof-option
3tyi* inputs one character from 2stream* and returns it.
The character is echoed if 2stream* is interactive,
except that 3Rubout* is not echoed.
The 3Control*, 3Meta*, etc. shifts echo as "3C-*", "3M-*", etc.

The 3:tyi* stream operation is preferred over the 3tyi* function for
some purposes.  Note that it does not echo.  See (general-stream-ops).

(This function can take its arguments in the other order, for Maclisp
compatibility only; see the note above.)
.end_defun

.defun readch &optional stream eof-option
This function is provided only for Maclisp compatibility, since
in the Zetalisp characters are always represented as fixnums.
3readch* is just like 3tyi*, except that instead of returning
a fixnum character, it returns a symbol whose print name is the character
read in.  The symbol is interned in the current package.
'cindex character object
This is just like a Maclisp "character object".
(This function can take its arguments in the other order, for Maclisp
compatibility only; see the note above.)
.end_defun

.defun tyipeek &optional peek-type stream eof-option
This function is provided mainly for Maclisp compatibility;
the 3:tyipeek* stream operation is usually clearer (see (tyipeek-stream-operation)).

What 3tyipeek* does depends on the 2peek-type*, which
defaults to 3nil*.  With a 2peek-type* of 3nil*,
3tyipeek* returns the next character to be read from 
2stream*, without actually removing it from the input stream.
The next time input is done from 2stream* the character will still
be there; in general, 3(= (tyipeek) (tyi))* is 3t*.

If 2peek-type* is a fixnum less than 1000 octal, then 3tyipeek*
reads characters from 2stream* until it gets one equal to 2peek-type*.
That character is not removed from the input stream.

If 2peek-type* is 3t*, then 3tyipeek* skips over input characters
until the start of the printed representation of a Lisp object is reached.
As above, the last character (the one that starts an object)
is not removed from the input stream.

The form of 3tyipeek* supported by Maclisp in which 2peek-type*
is a fixnum not less than 1000 octal is not supported, since the readtable
formats of the Maclisp reader and the Zetalisp reader are quite different.

Characters passed over by 3tyipeek* are echoed if 2stream* is interactive.
.end_defun

.subsection Interactive Input with Prompting

.defun prompt-and-read type-of-parsing format-string &rest format-args
3prompt-and-read* reads some sort of object from 3*query-io**, parsing
it according to 2type-of-parsing*, and prompting by calling 3format*
using 2format-string* and 2format-args*.

2type-of-parsing* is either a keyword or a list starting with a
keyword and continuing with a list of options and values, whose meanings
depend on the keyword used.

Most keywords specify reading a line of input and parsing it in some
way.  The line can be terminated with 3Return* or 3End*.  Sometimes
typing just 3End* has a special meaning.

The keywords defined are
.table 3
.kitem :eval-sexp
.xitem1 :eval-form prompt-and-read
This keyword directs 3prompt-and-read* to accept a Lisp
expression.  It is evaluated, and the value is returned by 3prompt-and-read*.

If the Lisp expression is not a constant or quoted, the user is asked to
confirm the value it evaluated to.

A default value can be specified with an option, as in
.lisp
(:eval-sexp :default 2default*)
.end_lisp
Then, if the user types 3Space*, 3prompt-and-read* returns the
2default* as the first value and 3:default* as the second value.

.kitem :eval-sexp-or-end
.xitem1 :eval-form-or-end prompt-and-read
This keyword directs 3prompt-and-read* to accept a Lisp expression or
just the character 3End*.  If 3End* is typed, 3prompt-and-read*
returns 3nil* as its first value and 3:end* as its second value.
Otherwise, things proceed as for 3:eval-sexp*.

A default value is allowed, as in 3:eval-sexp*.

.kitem :read
.xitem1 :expression prompt-and-read
Either of these keywords directs 3prompt-and-read* to read an object
and return it, with no evaluation.

.kitem :expression-or-end
Is like 3:expression* except that the user is also allowed to type just
3End*.  If he does so, 3prompt-and-read* returns the two values
3nil* and 3:end*.

.kitem :number
This keyword directs 3prompt-and-read* to read and return a number.
It insists on getting a number, forcing the user to rub out anything else.
Additional features can be specified with options:
.lisp
(:number :input-radix 2radix* :or-nil 2nil-ok-flag*)
.end_lisp
parses the number using radix 2radix* if the number is a rational.  If
2nil-ok-flag* is non-3nil*, then the user is also permitted to type
just 3Return* or 3End*, and then 3nil* is returned.

.kitem :date
This keyword directs 3prompt-and-read* to read a date and time, terminated
with 2Return* or 3End*, and return it
as a universal time (see (get-universal-time-fun)).  It allows several options:
.lisp
(:date :never-p 2never-ok* :past-p 2past-required*)
.end_lisp
If 2past-required* is non-3nil*, the date must be before the
present time, or the user must rub out and use a different date.  If
2never-ok* is non-3nil*, the user may also type "never"; then
3nil* is returned.

.kitem :character
This keyword directs 3prompt-and-read* to read a single character and
return a character object representing it.

.kitem :string
This keyword directs 3prompt-and-read* to read a line and return its
contents as a string, using 3readline*.

.kitem :string-or-nil
This keyword directs 3prompt-and-read* to read a line and return its
contents as a string, using 3readline-trim*.  In addition, if the
result would be empty, 3nil* is returned instead of the empty string.

.kitem :pathname
This keyword directs 3prompt-and-read* to read a line and parse it as
a pathname, merging it with the defaults.  If the line is empty,
the default pathname is used.  These options are defined:
.lisp
(:pathname :defaults 2defaults-alist-or-pathname*
	   :version 2default-version*)
.end_lisp
uses 2defaults-alist-or-pathname* as the 2defaults* argument to
3fs:merge-pathname-defaults*, and 2default-version* as the
2version* argument to it.

.kitem :pathname-or-nil
Is like 3:pathname*, but if the user types just 3End* it
is interpreted as meaning "no pathname" rather than "use the default".
Then 3nil* is returned.

.kitem :fquery
This keyword directs 3prompt-and-read* to query the user for a fixed
set of alternatives, using 3fquery*.  2type-of-parsing* should always
be a list, whose car is 3:fquery* and whose cdr is a list to be passed
as the list of options (3fquery*'s first argument).
.lisp
.exdent 96 Example:
(prompt-and-read `(:fquery 
		   . ,format:y-or-p-options)
                 "Eat it? ")
.exdent 96 is equivalent to
(y-or-n-p "Eat it? ")
.end_lisp

This keyword is most useful as a way to get to 3fquery* when going
through an interface defined to call 3prompt-and-read*.
.end_table
.end_defun

.section "Output Functions"

These functions all take an optional argument called 2stream*, which is
where to send the output.  If unsupplied 2stream* defaults to the value of
3*standard-output**.  If 2stream* is 3nil*, the value of
3*standard-output** (i.e. the default) is used.  If it is 3t*, the value of
3*terminal-io** is used (i.e. the interactive terminal).  This is all
more-or-less compatible with Maclisp, except that instead of the
variable 3*standard-output** Maclisp has several variables and complicated rules.
For detailed documentation of streams, refer to (streams).

For 3print* and the other expression output functions, see
(expression-output).

.defun write-char char &optional stream
.defun1 tyo char &optional stream
Outputs 2char* to 2stream* (using 3:tyo*).  2char* may be an
integer or a character object; in the latter case, it is converted to an
integer before the 3:tyo*.
.end_defun

.defun write-byte number &optional stream
Outputs number to stream using 3:tyo*.
In strict Common Lisp, output to binary streams can be done only with
3write-byte* and output to character streams requires 3write-char*.
In fact, the two functions are identical.
.end_defun

.defun write-string string &optional stream &key (start 30*) end
Outputs 2string* (or the specified portion of it) to 2stream*.
.end_defun

.defun write-line string &optional stream &key (start 30*) end
Outputs 2string* (or the specified portion) to 2stream*, followed by a 3Return* character.
.end_defun

.defun fresh-line &optional stream
Outputs a 3Return* character to 3stream* unless either
.table 1 0 300
.item (1)
nothing has been output to 2stream* yet, or
.item (2)
the last thing output was a 3Return* character, or
.item (3)
2stream* does not remember what previous output there has been.
.end_table

This uses the 3:fresh-line* stream operation.
The value is 3t* if a 3Return* is output, 3nil* if nothing is output.
.end_defun

.defun force-output &optional stream
Causes 2stream*'s buffered output, if any, to be transmitted immediately.
This uses the 3:force-output* stream operation.
.end_defun

.defun finish-output &optional stream
Causes 2stream*'s buffered output, if any, to be transmitted immediately,
and waits until that is finished.
This uses the 3:finish* stream operation.
.end_defun

.defun clear-output &optional stream
Discards any output buffered in 2stream*.
This uses the 3:clear-output* stream operation.
.end_defun

.defun terpri &optional stream
3terpri* outputs a 3Return* character to 2stream*.
It returns 3t* for Maclisp compatibility.
.end_defun

.defun cli:terpri &optional stream
3cli:terpri* outputs a 3Return* character to 2stream*.
Returns 3nil* to meet Common Lisp specifications.
.end_defun

	The 3format* function (see (format-fun)) is very useful for producing
nicely formatted text.  It can do anything any of the above functions
can do, and it makes it easy to produce good looking messages and such.
3format* can generate a string or output to a stream.

.defun stream-copy-until-eof from-stream to-stream &optional leader-size
3stream-copy-until-eof* inputs characters from 2from-stream*
and outputs them to 2to-stream*, until it reaches the end of file
on the 2from-stream*.  For example, if 3x* is bound to a stream
for a file opened for input, then 3(stream-copy-until-eof x *terminal-io*)*
prints the file on the console.

If 2from-stream* supports the 3:line-in* operation and 2to-stream* 
supports the 3:line-out* operation, then 3stream-copy-until-eof*
uses those operations instead of 3:tyi* and 3:tyo*, for greater
efficiency.  2leader-size* is passed as the argument to the
3:line-in* operation.
.end_defun

.defun beep &optional beep-type (stream 3*terminal-io**)
This function is intended to attract the user's attention by causing
an audible beep, or flashing the screen, or something similar.  If
the stream supports the 3:beep* operation, then this function sends
it a 3:beep* message, passing 2beep-type* along as an argument.  Otherwise
it just causes an audible beep on the terminal.

2beep-type* is a keyword which explains the significance of this beep.
Users can redefine 3beep* to make different noises depending on the
beep type.  The defined beep types are:
.table 3
.kitem zwei:converse-problem
Used for the beep that is done when Converse is unable to send a message.
.kitem zwei:converse-message-received
Used for the beeps done when a Converse message is received.
.kitem zwei:no-completion
Used when you ask for completion in the editor and the string does not complete.
.kitem tv:notify
Used for the beep done when you get a notification that cannot 
be printed on the selected window.
.item nil
Used whenever no other beep type applies.
.end_table

The 3:beep* operation is described on (streams-beep-method).
.end_defun

.defun cursorpos &rest args
This function exists primarily for Maclisp compatibility.  Usually it is
preferable to send the appropriate messages (see the Window System manual).

3cursorpos* normally operates on the 3*standard-output** stream;
however, if the last argument is a stream or 3t* (meaning 3*terminal-io**)
then 3cursorpos* uses that stream and ignores it when doing the operations
described below.  3cursorpos* only works on streams
that are capable of these operations, such as windows.
A stream is taken to be any argument that is not a number and not a symbol,
or that is a symbol other than 3nil* with a name more than one character long.

3(cursorpos) => (2line* . 2column*)*, the current
cursor position.

3(cursorpos 2line* 2column*)* moves the cursor to that position.
It returns 3t* if it succeeds and 3nil* if it doesn't.

3(cursorpos 2op*)* performs a special operation coded by 2op*,
and returns 3t* if it succeeds and 3nil* if it doesn't.
2op* is tested by string comparison, it is not a keyword symbol
and may be in any package.
.table 3 500 250 0 0
.item f
Moves one space to the right.
.item b
Moves one space to the left.
.item d
Moves one line down.
.item u
Moves one line up.
.item t
Homes up (moves to the top left corner).  Note that 3t* as the last
argument to 3cursorpos* is interpreted as a stream, so a stream 2must*
be specified if the 3t* operation is used.
.item z
Home down (moves to the bottom left corner).
.item a
Advances to a fresh line.  See the 3:fresh-line* stream operation.
.item c
Clears the window.
.item e
Clear from the cursor to the end of the window.
.item l
Clear from the cursor to the end of the line.
.item k
Clear the character position at the cursor.
.item x
3b* then 3k*.
.end_table
.end_defun

.page
.c section on I/O streams
.insert stream



.c sections on FORMAT and OUTPUT
.insert fd-fio


.section "Rubout Handling"
.setq rubout-handler section-page
.setq rubout-handling section-page
.cindex rubout handler

The rubout handler is a feature of all interactive streams, that is, streams
that connect to terminals.  Its purpose is to allow the user to edit
minor mistakes in type-in.  At the same time, it is not supposed to
get in the way; input is to be seen by Lisp as soon as a syntactically complete
form has been typed.  The definition of "syntactically complete form"
depends on the function that is reading from the stream; for 3read*, it
is a Lisp expression.

Some interactive streams ("editing Lisp listeners") have a rubout handler
that allows input to be edited with the full power of the ZWEI editor.
Most windows have a rubout handler that apes ZWEI, implementing about twenty
common ZWEI commands.  The cold load stream has
a simple rubout handler that allows just rubbing out of single
characters, and a few simple commands like clearing the screen and
erasing the entire input typed so far.  All three kinds of rubout
handler use the same protocol, which is described in this section.  We
also say a little about the most common of the three rubout handlers.
.br
[Eventually some version of ZWEI will be used for all streams
except the cold load stream]

The tricky thing about the rubout handler is the need for it to figure
out when you are all done.  The idea of a rubout handler is that you can
type in characters, and they are saved up in a buffer so that if you
change your mind, you can rub them out and type different characters.
However, at some point, the rubout handler has to decide that the time
has come to stop putting characters into the buffer and to let the
function parsing the input, such as 3read*, return.  This is
called "activating".  The right time to activate depends on the function
calling the rubout handler, and may be very complicated (if the function
is 3read*, figuring out when one Lisp expression has been typed
requires knowledge of all the various printed representations, what all
currently-defined reader macros do, and so on).  Rubout handlers should
not have to know how to parse the characters in the buffer to
figure out what the caller is reading and when to activate; only the
caller should have to know this.  The rubout handler interface is
organized so that the calling function can do all the parsing, while the
rubout handler does all the handling of editing commands, and the two are kept
completely separate.

The basic way that the rubout handler works is as follows.  When
an input function that reads characters from a stream, such as 3read* or 3readline*
(but not 3tyi*), is invoked with a stream which has 3:rubout-handler*
in its 3:which-operations* list, that function "enters" the rubout handler.
It then goes ahead 3:tyi*'ing characters from the stream.  Because control
is inside the rubout handler, the stream echoes these characters so the user
can see what he is typing.  (Normally echoing is considered to be a higher-level
function outside of the province of streams, but when the higher-level function
tells the stream to enter the rubout handler it is also handing it the responsibility
for echoing.)  The rubout handler is also saving all these characters in a buffer,
for reasons disclosed in the following paragraph.
When the function, 3read* or whatever, decides it has enough
input, it returns and control "leaves" the rubout handler.  That was the easy case.

If the user types a rubout, a 3throw* is done out of all recursive levels
of 3read*, reader macros, and so forth, back to the point where the rubout
handler was entered.  Also the rubout is echoed by erasing from the screen
the character which was rubbed out.  Now the 3read* is tried over again,
re-reading all the characters that have not been rubbed out, not echoing
them this time.  When the saved characters have been exhausted, additional input is read
from the user in the usual fashion.

The effect of this is a complete separation of the functions of rubout
handling and parsing, while at the same time mingling the execution of
these two functions in such a way that input is always "activated" at
just the right time.  It does mean that the parsing function (in the
usual case, 3read* and all macro-character definitions) must be
prepared to be thrown through at any time and should not have
non-trivial side-effects, since it may be called multiple times.

If an error occurs while inside the rubout handler, the error message is printed
and then additional characters are read.  When the user types a rubout,
it rubs out the error message as well as the character that caused the error.
The user can then proceed to type the corrected expression;
the input will be reparsed from the beginning in the usual fashion.

The rubout handler based on the ZWEI editor interprets control
characters in the usual ZWEI way: as editing commands, allowing you to
edit your buffered input.

The common rubout handler also recognizes a subset of the editor
commands, including 3Rubout*, 3Control-F* and 3Meta-F* and others.
Typing 3Help* while in the rubout handler displays a list of the
commands.  The kill and yank commands in the rubout handler use the same
kill ring as the editor, so you can kill an expression in the editor and
yank it back into a rubout handler with 3Control-Y*, or kill an
expression in the rubout handler with 3Control-K* or 3Clear-input*
and yank it back in the editor.  The rubout processor also keeps a ring
buffer of most recent input strings (a separate ring for each stream),
and the commands 3Control-C* and 3Meta-C* retrieve from this ring
just as 3Control-Y* and 3Meta-Y* do from the kill ring.

When not inside the rubout handler, and when
typing at a program that uses control characters for its own purposes,
control characters are treated the same as ordinary characters.

Some programs such as the debugger allow the user to type either a
control character or an expression.  In such programs, you are really
not inside the rubout handler unless you have typed the beginning of an
expression.  When the input buffer is empty, a control character is
treated as a command for the program (such as, 3Control-C* to continue
in the debugger); when there is text in the rubout handler buffer, the
same character is treated as a rubout handler command.  Another
consequence of this is that the message you get by typing 3Help*
varies, being either the rubout handler's documentation or the
debugger's documentation. 

To write a parsing function that reads with rubout handling,
use 3with-input-editing*.

.defmac with-input-editing (stream options) body...
Invokes the rubout handler on 2stream*, if 2stream* supports it,
and then executes 2body*.  2body* is executed in any case,
within the rubout handler if possible.  3rubout-handler* is
non-3nil* while in 2body* if rubout handling is in use.

2options* are used as the rubout handler options.
If already within an invocation of the rubout handler, 2options* are
appended to the front of the options already in effect.  This happens if
a function which reads input using 3with-input-editing*, such as
3read* or 3readline*, is called from the body of another
3with-input-editing*.  The 3:norecursive* option can be used
to cause the outer set of options to be completely ignored even
when not overridden by new ones.

2body*'s values are returned by 3with-input-editing*.
2body* ought to read input from 2stream* and return
a Lisp object that represents the input.  It should have
no nontrivial side effects aside from reading input from 2stream*
structure, as it may be aborted at any time it reads input
and may be executed over and over.

If the 3:full-rubout* option is specified, and the user types some input
and rubs it all out, the 3with-input-editing* form returns immediately.
See 3:full-rubout*, below.

If a preemptive command is input by the user, 3with-input-editing*
returns immediately with the values being as specified below
under the 3:command* and 3:preemptable* options.  2body*
is aborted from its call to the 3:tyi* operation, and the input
read so far remains in the rubout handler editing buffer to be read
later.
.end_defmac

.defvar rubout-handler
3t* if control is inside the rubout handler in this process.
.end_defvar

.defmetamethod streams :rubout-handler options function &rest args
Invokes the rubout handler on the stream, with 2options* as
the options, and parses by applying 2function* to 2args*.
3with-input-editing* uses this operation.
.end_defmetamethod

.defmetamethod streams :read-bp
This operation may be used only from within the code for
parsing input from this stream inside the rubout handler.
It returns the index within the rubout handler buffer
which parsing has reached.
.end_defmetamethod

.defmetamethod streams :force-rescan
This operation may be used only from within the code for
parsing input from this stream inside the rubout handler.
It causes parsing to start again immediately from the beginning of the buffer.
.end_defmetamethod

.defmetamethod streams :rescanning-p
This operation may be used only from within the code for
parsing input from this stream inside the rubout handler.
It returns 3t* if parsing is now being done on input
already in the buffer, 3nil* if parsing has used up all
the buffered input and the next character parsed will come
from the keyboard.
.end_defmetamethod

Each option in the list of rubout handler options consists of a list
whose first element is a keyword and whose remaining elements are
"arguments" to that keyword.  Note that this is not the same format as
the arguments to a typical function that takes keyword arguments; rather
this is an alist of options.  The standard options are:
.table 3 500
.item (:activation 2fn* 2args*...) 
Activate if certain characters are typed in.
When the user types an activation character, the rubout handler
moves the editing pointer immediately to the end of the buffer
and inserts the activation character.  This immediately causes
the parsing function to begin rescanning the input.

2fn* is used to test characters for being activators.  It is called
with an input character as the first arg (possibly a fixnum, possibly a
character object) and 2args* as additional args.  If 2fn* returns
non-3nil*, the character is an activation.  2fn* is not called
for blips.

After the parsing function has read the entire contents of the buffer,
it sees the activation character as a blip 3(:activation 2char*
2numeric-arg*)* where 2char* is the character that activated and
2numeric-arg* is the numeric arg that was pending for the next rubout
handler command.  Normally the parsing function will return at this point.
Then the activation character does not echo.  But if the parsing function
continues to read input, the activation character echoes and is inserted
in the buffer.

.item (:do-not-echo 2chars*...) 
'setq :do-not-echo-option page
Poor man's activation characters.  Like 3:activation* except that the
characters that should activate are listed explicitly, and the character
itself is returned to the parsing function rather than a blip.

.item (:full-rubout 2val*)
If the user rubs out all the characters he typed, then control is returned
from the rubout handler immediately.  Two values are returned; the first is
3nil* and the second is 2val*.  (If the user doesn't rub out all the
characters, then the rubout handler propagates multiple values back
from the function that it calls, as usual.)  In the absence of this option, the rubout
handler would simply wait for more characters to be typed in and would ignore
any additional rubouts.

This is how the debugger knows to remove "Eval:" from the screen
if you type the beginning of a form and rub it all out.

.item (:pass-through 2char1* 2char2*...)
The characters 2char1*, 2char2*, etc. are not to be treated as special by
the rubout handler.  They are read as input by the parsing function.
If the parsing function does not return, they can be rubbed out.
This works only for characters with no modifier bits.

.item (:preemptable 2value*) 
Make all blips read as input by the rubout handler act as preemptive
commands.  If this option is specified, the rubout handler returns
immediately when it reads a blip.  It returns two values: the blip that
was read, and 2value*.  The parsing function is not allowed to finish
parsing up to a delimiter; instead, any buffered input remains in the
buffer for the next time input is done.  In the mean time, the
preemptive command character can be processed by the command loop.

While this applies to all blips, the blips which it is probably intended
for are mouse blips.

.item (:command 2fn* 2args*...) 
Makes certain characters preemptive commands.  A preemptive command
returns instantly to the caller of the 3:rubout-handler* operation,
regardless of the input in the buffer.  It returns two values: a list
3(:command 2char* 2numeric-arg*)* and the keyword 3:command*.
The parsing function is not allowed to finish parsing up to a delimiter;
instead, any buffered input remains in the buffer for the next time
input is done.  In the mean time, the preemptive command character can
be processed by the command loop.

The test for whether a character should be a preemptive command
is done using 2fn* and 2args* just as in 3:activation*.

.item (:editing-command (2char* 2doc*)...) 
Defines editing commands to be executed by the parsing function itself.
This is how 3qsend* implements the 3Control-Meta-Y* command.
Each 2char* is such a command, and 2doc* says what it does.
(2doc* is printed out by the rubout handler's 3Help* command.)
If any of these characters is read by the rubout handler,
it is returned immediately to the parsing function
regardless of where the editing pointer is in the buffer.
(Normal inserted text is not returned immediately when read unless the editing pointer
is at the end of the buffer.)

The parsing function should not regard these characters as part of the input.
There are two reasonable things that the parsing function can do
when it receives one of the editing command characters:
print some output, or force some input.

If it prints output, it should invoke the 3:refresh-rubout-handler* operation
afterward before the next 3:tyi*.  This causes the rubout handler to redisplay
so that the input being edited appears after the output that was done.

If the parsing function forces input, the input is read by the rubout
handler.  This can be used to modify the buffered input.  3qsend*'s
3Control-Meta-Y* command works by forcing the yanked text as input.
There is no way to act directly on the buffered input because different
implementations of the rubout handler store it in different ways.

.item (:prompt 2function*)
.item1 (:reprompt 2function*)
When it is time for the user to be prompted, 2function* is called with
two arguments.  The first is a stream it may print on; the second is the
character which caused the need for prompting, e.g. 3#\clear-input*
or 3#\clear-screen*, or 3nil* if the rubout handler was just entered.

The difference between 3:prompt* and 3:reprompt* is that the latter does
not call the prompt function when the rubout handler is first entered, but only
when the input is redisplayed (e.g. after a screen clear).  If both options
are specified then 3:reprompt* overrides 3:prompt* except when the rubout
handler is first entered.

2function* may also be a string.  Then it is simply printed.

If the rubout handler is exited with an empty buffer due to the
3:full-rubout* option, whatever prompt was printed is erased.

.item (:initial-input 2string*)
Pretends that the user typed 2string*.  When the rubout handler is entered,
2string* is typed out.  The user can input more characters or rub out
characters from it.

.item (:initial-input-index 2index*)
Positions the editing pointer initially 2index* characters into
the initial input string.  Used only together with 3:initial-input*.

.item (:no-input-save t) 
Don't save this batch of input in the input history when it is done.
3yes-or-no-p* specifies this option.

.item (:norecursive t)
If this invocation of the rubout handler is within another one,
the options specified in the previous call should be completely
ignored during this one.  Normally, individual options specified
this time override the previous settings for the same options,
but any of the previous options not individually overridden
are still in effect.
.end_table

Rubout handlers handle the condition 3sys:parse-error* if it is
signaled by the parsing function.  The handling consists of printing the
error message, waiting for the user to rub out, erasing the error message,
and parsing the input again.  All errors signaled by a parsing function
that signify that the user's input was syntactically invalid should have
this condition name.  For example, the errors 3read* signals have
condition name 3sys:parse-error* since it is is a consequence of 3sys:read-error*.

.defcondition sys:parse-error (3error*)
The condition name for errors in the syntax of input being parsed.
.end_defcondition

The compiler handles 3sys:parse-error* by proceeding with proceed-type
3:no-action*.  All signalers of 3sys:parse-error* should offer
this proceed type, and respond to its use by continuing to parse,
ignoring the invalid input.

.defun sys:parse-ferror format-string &rest args
Signals a 3sys:parse-error* error, using 2format-string* and 2args*
to print the error message.  The proceed-type 3:no-action* is provided,
and if a handler uses it, this function returns 3nil*.
.end_defun
